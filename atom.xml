<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NoObject&#39;s blog</title>
  
  <subtitle>hacker</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-17T10:36:25.195Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>NoObject</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTPOXY漏洞</title>
    <link href="http://yoursite.com/2020/03/17/HTTPOXY%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2020/03/17/HTTPOXY%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-03-17T10:25:31.000Z</published>
    <updated>2020-03-17T10:36:25.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><p> Guzzle<code>&gt;=4.0.0rc2,&lt;6.2.1</code>版本受此影响 </p><table><thead><tr><th align="center">Language</th><th align="center">Environment</th><th align="center">HTTP client</th></tr></thead><tbody><tr><td align="center">PHP</td><td align="center">php-fpm mod_php</td><td align="center">Guzzle 4+ Artax</td></tr><tr><td align="center">Python</td><td align="center">wsgiref.handlers.CGIHandler twisted.web.twcgi.CGIScript</td><td align="center">requests</td></tr><tr><td align="center">Go</td><td align="center">net/http/cgi</td><td align="center">net/http</td></tr></tbody></table><a id="more"></a><h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><blockquote><p>在CGI(RFC 3875)的模式的时候， 会把请求中的Header， 加上HTTP_ 前缀， 注册为环境变量, 所以如果你在Header中发送一个Proxy:xxxxxx, 那么PHP就会把他注册为HTTP_PROXY环境变量， 于是getenv(“HTTP_PROXY”)就变成可被控制的了. 那么如果你的所有类似的请求， 都会被代理到攻击者想要的地址，之后攻击者就可以伪造，监听，篡改你的请求了… </p></blockquote><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><blockquote><ul><li>代码以cgi模式运行，其中使用环境变量<code>HTTP_PROXY</code></li><li>信任 HTTP 客户端<code>HTTP_PROXY</code>并将其配置为代理</li><li>在请求处理程序中使用的该客户端发出HTTP（与HTTPS相对）请求</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;/blockquote&gt;&lt;p&gt; Guzzle&lt;code&gt;&amp;gt;=4.0.0rc2,&amp;lt;6.2.1&lt;/code&gt;版本受此影响 &lt;/p&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;Language&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Environment&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;HTTP client&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;PHP&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;php-fpm mod_php&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Guzzle 4+ Artax&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Python&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;wsgiref.handlers.CGIHandler twisted.web.twcgi.CGIScript&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;requests&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Go&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;net/http/cgi&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;net/http&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MD5绕过</title>
    <link href="http://yoursite.com/2020/03/17/MD5%E7%BB%95%E8%BF%87/"/>
    <id>http://yoursite.com/2020/03/17/MD5%E7%BB%95%E8%BF%87/</id>
    <published>2020-03-17T09:16:57.000Z</published>
    <updated>2020-03-17T09:29:00.883Z</updated>
    
    <content type="html"><![CDATA[<p>比较md5加密后的值是否为0，可以把value变成数组可以绕过</p><blockquote><p>因为md5加密一个数组值为null，而null==0</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;比较md5加密后的值是否为0，可以把value变成数组可以绕过&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;因为md5加密一个数组值为null，而null==0&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>php常用函数</title>
    <link href="http://yoursite.com/2020/03/17/php%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/03/17/php%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</id>
    <published>2020-03-17T09:16:37.000Z</published>
    <updated>2020-03-17T09:28:49.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="exif-imagetype"><a href="#exif-imagetype" class="headerlink" title="exif_imagetype()"></a>exif_imagetype()</h2><blockquote><p><code>exif_imagetype()</code>函数判断是不是图片，这个很好绕过，在文件头添加图片头就可以了，例如<code>gif</code>的文件头<code>GIF89a</code> </p></blockquote><h2 id="scandir"><a href="#scandir" class="headerlink" title="scandir()"></a>scandir()</h2><blockquote><p>列出 参数目录 中的文件和目录</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;exif-imagetype&quot;&gt;&lt;a href=&quot;#exif-imagetype&quot; class=&quot;headerlink&quot; title=&quot;exif_imagetype()&quot;&gt;&lt;/a&gt;exif_imagetype()&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>过滤绕过</title>
    <link href="http://yoursite.com/2020/03/17/%E8%BF%87%E6%BB%A4%E7%BB%95%E8%BF%87/"/>
    <id>http://yoursite.com/2020/03/17/%E8%BF%87%E6%BB%A4%E7%BB%95%E8%BF%87/</id>
    <published>2020-03-17T09:16:10.000Z</published>
    <updated>2020-03-17T09:28:38.175Z</updated>
    
    <content type="html"><![CDATA[<h4 id="绕过空格过滤"><a href="#绕过空格过滤" class="headerlink" title="绕过空格过滤"></a>绕过空格过滤</h4><p>注释绕过空格</p><blockquote><p>在MySQL中，用/**/来标记注释的内容。比如SQL查询：<br>select user() from dual<br>我们用注释替换空格，就可以变成：<br>select/**/user()/**/from/**/dual</p></blockquote><a id="more"></a><p>括号绕过空格 </p><blockquote><p>空格被过滤，但括号没有被过滤，可通过括号绕过。<br>我的经验是，在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。<br>括号绕过空格的方法，在time based盲注中，是屡试不爽的。<br>举例说明，我们有这样的一条SQL查询：<br>select user() from dual where 1=1 and 2=2<br>观察到user()可以算值，那么user()两边要加括号，变成：<br>select(user())from dual where 1=1 and 2=2;<br>继续，1=1和2=2可以算值，也加括号，去空格，变成：<br>select(user())from dual where(1=1)and(2=2)</p><p><a href="http://www.xxx.com/index.php?id=(sleep(ascii(mid(user()from(2)for(1)))=109" target="_blank" rel="noopener">http://www.xxx.com/index.php?id=(sleep(ascii(mid(user()from(2)for(1)))=109</a>))<br>这条语句是猜解user()第二个字符的ascii码是不是109，若是109，则页面加载将延迟。它：</p><p>1) 既没有用到逗号、大小于符号<br>2) 也没有使用空格</p></blockquote><p>可尝试Tab替代空格</p><h4 id="绕过特殊字符过滤"><a href="#绕过特殊字符过滤" class="headerlink" title="绕过特殊字符过滤"></a>绕过特殊字符过滤</h4><blockquote><p>可以用chr()函数绕过</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;绕过空格过滤&quot;&gt;&lt;a href=&quot;#绕过空格过滤&quot; class=&quot;headerlink&quot; title=&quot;绕过空格过滤&quot;&gt;&lt;/a&gt;绕过空格过滤&lt;/h4&gt;&lt;p&gt;注释绕过空格&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;在MySQL中，用/**/来标记注释的内容。比如SQL查询：&lt;br&gt;select user() from dual&lt;br&gt;我们用注释替换空格，就可以变成：&lt;br&gt;select/**/user()/**/from/**/dual&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>文件上传</title>
    <link href="http://yoursite.com/2020/03/17/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>http://yoursite.com/2020/03/17/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2020-03-17T09:15:53.000Z</published>
    <updated>2020-03-17T09:24:35.753Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li><code>gif</code>的文件头<code>GIF89a</code> </li></ul></blockquote><h2 id="user-ini"><a href="#user-ini" class="headerlink" title=".user.ini"></a>.user.ini</h2><p>PHP会在每个目录下扫描INI文件，我们可以通过.user.ini文件来实现隐藏后门的效果</p><p>在.user.ini中可以识别PHP_INI_PERDIR和PHP_INI_USER模式的INI设置<br>关于PHP_INI_*一共有四种：</p><a id="more"></a><blockquote><p>PHP_INI_USER 可在用户脚本以及.user.ini中设定</p></blockquote><blockquote><p>PHP_INI_PERDIR 可在php.ini，.htaccess或httpd.conf中设定</p></blockquote><blockquote><p>PHP_INI_SYSTEM 可在php.ini或httpd.conf中设定</p></blockquote><blockquote><p>PHP_INI_ALL 可在任何地方设定</p></blockquote><p>auto_prepend_file</p><p>该配置项会让php文件在执行前先包含一个指定的文件，通过这个配置项，我们就可以来隐藏自己的后门</p><p>.user.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto_prepend_file=test.jpg</span><br></pre></td></tr></table></figure><p>.user.ini利用条件</p><blockquote><p>服务器脚本语言为PHP</p><p>服务器使用CGI／FastCGI模式<br>上传目录下要有可执行的php文件<br>从这来看.user.ini要比.htaccess的应用范围要广一些，毕竟.htaccess只能用于Apache</p><p>但仔细推敲我们就会感到“上传目录下要有可执行的php文件”这个要求在文件上传中也比较苛刻，应该没有天才开发者会把上传文件放在主目录或者把php文件放在上传文件夹。</p><p>但也不是全无办法，如果我们根据实际情况配合其他漏洞使用可能会有奇效，当对上传时的路径没有检测../时，因此导致文件可被上传至任意目录，这种情况下我们就很有可能可以利用.user.ini</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gif&lt;/code&gt;的文件头&lt;code&gt;GIF89a&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;h2 id=&quot;user-ini&quot;&gt;&lt;a href=&quot;#user-ini&quot; class=&quot;headerlink&quot; title=&quot;.user.ini&quot;&gt;&lt;/a&gt;.user.ini&lt;/h2&gt;&lt;p&gt;PHP会在每个目录下扫描INI文件，我们可以通过.user.ini文件来实现隐藏后门的效果&lt;/p&gt;&lt;p&gt;在.user.ini中可以识别PHP_INI_PERDIR和PHP_INI_USER模式的INI设置&lt;br&gt;关于PHP_INI_*一共有四种：&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>文件包含</title>
    <link href="http://yoursite.com/2020/03/17/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>http://yoursite.com/2020/03/17/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</id>
    <published>2020-03-17T09:15:35.000Z</published>
    <updated>2020-03-17T09:28:23.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h2><h3 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h3><p>前提 phpinfo中的allow_url_include是开启的</p><blockquote><p><strong>php://input</strong> 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。 </p></blockquote><a id="more"></a><h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h3><p>php://filter在双off的情况下也可以正常使用；</p><p>allow_url_fopen ：off/on</p><p>allow_url_include：off/on</p><blockquote><p>php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 </p><p>?path=php://filter/read=convert.base64-encode/resource=xxxxx.php</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;php伪协议&quot;&gt;&lt;a href=&quot;#php伪协议&quot; class=&quot;headerlink&quot; title=&quot;php伪协议&quot;&gt;&lt;/a&gt;php伪协议&lt;/h2&gt;&lt;h3 id=&quot;php-input&quot;&gt;&lt;a href=&quot;#php-input&quot; class=&quot;headerlink&quot; title=&quot;php://input&quot;&gt;&lt;/a&gt;php://input&lt;/h3&gt;&lt;p&gt;前提 phpinfo中的allow_url_include是开启的&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;php://input&lt;/strong&gt; 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>模块注入</title>
    <link href="http://yoursite.com/2020/03/17/%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2020/03/17/%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%85%A5/</id>
    <published>2020-03-17T09:14:46.000Z</published>
    <updated>2020-03-17T09:23:00.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模板注入介绍"><a href="#模板注入介绍" class="headerlink" title="模板注入介绍"></a>模板注入介绍</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQL 注入</span></span><br><span class="line">$query = <span class="string">"select * from sometable where id="</span>.$_GET[<span class="string">'id'</span>];</span><br><span class="line">mysql_query($query);</span><br><span class="line">------------- 华丽的分割线 -------------</span><br><span class="line"><span class="comment">// 模版注入</span></span><br><span class="line">$temp-&gt;render(<span class="string">"Hello "</span>.$_GET[<span class="string">'username'</span>]);</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>而服务端模板注入和常见Web注入的成因一样，也是服务端接收了用户的输入，将其作为 Web 应用模板内容的一部分，在进行目标编译渲染的过程中，执行了用户插入的恶意内容，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。 </p></blockquote><h3 id="模板注入原理"><a href="#模板注入原理" class="headerlink" title="模板注入原理"></a>模板注入原理</h3><pre><code>模板注入涉及的是服务端Web应用使用模板引擎渲染用户请求的过程。</code></pre><p>考虑下面这段代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> dirname(<span class="keyword">__FILE__</span>).<span class="string">'/../lib/Twig/Autoloader.php'</span>;</span><br><span class="line">Twig_Autoloader::register(<span class="keyword">true</span>);</span><br><span class="line">$twig = <span class="keyword">new</span> Twig_Environment(<span class="keyword">new</span> Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(<span class="string">"Hello &#123;$_GET['name']&#125;"</span>);  <span class="comment">// 将用户输入作为模版内容的一部分</span></span><br><span class="line"><span class="keyword">echo</span> $output;</span><br></pre></td></tr></table></figure><p>​    使用 Twig 模版引擎渲染页面，其中模版含有   变量，其模版变量值来自于 GET 请求参数 $_GET[“name”] 。显然这段代码并没有什么问题，即使你想通过 name  参数传递一段 JavaScript 代码给服务端进行渲染，也许你会认为这里可以进行 XSS，但是由于模版引擎一般都默认对渲染的变量值进行编码和转义，所以并不会造成跨站脚本攻击。</p><p>​    如果渲染的模版内容受到用户的控制，情况就不一样了。修改代码为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> dirname(<span class="keyword">__FILE__</span>).<span class="string">'/../lib/Twig/Autoloader.php'</span>;</span><br><span class="line">Twig_Autoloader::register(<span class="keyword">true</span>);</span><br><span class="line">$twig = <span class="keyword">new</span> Twig_Environment(<span class="keyword">new</span> Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(<span class="string">"Hello &#123;$_GET['name']&#125;"</span>);  <span class="comment">// 将用户输入作为模版内容的一部分</span></span><br><span class="line"><span class="keyword">echo</span> $output;</span><br></pre></td></tr></table></figure><p>上面这段代码在构建模版时，拼接了用户输入作为模板的内容，现在如果再向服务端直接传递 JavaScript 代码，用户输入会原样输出。</p><h3 id="模板注入检测"><a href="#模板注入检测" class="headerlink" title="模板注入检测"></a>模板注入检测</h3><p> Twig 模板引擎里，  除了可以输出传递的变量以外，还能执行一些基本的表达式然后将其结果作为该模板变量的值，例如这里用户输入 name=20 ，则在服务端拼接的模版内容为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello &#123;&#123;<span class="number">2</span>*<span class="number">10</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>Twig 模板引擎在编译模板的过程中会计算 20  中的表达式 2*10 ，会将其返回值 20  作为模板变量的值输出</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模板注入介绍&quot;&gt;&lt;a href=&quot;#模板注入介绍&quot; class=&quot;headerlink&quot; title=&quot;模板注入介绍&quot;&gt;&lt;/a&gt;模板注入介绍&lt;/h3&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// SQL 注入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$query = &lt;span class=&quot;string&quot;&gt;&quot;select * from sometable where id=&quot;&lt;/span&gt;.$_GET[&lt;span class=&quot;string&quot;&gt;&#39;id&#39;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql_query($query);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------------- 华丽的分割线 -------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 模版注入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$temp-&amp;gt;render(&lt;span class=&quot;string&quot;&gt;&quot;Hello &quot;&lt;/span&gt;.$_GET[&lt;span class=&quot;string&quot;&gt;&#39;username&#39;&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>堆叠注入</title>
    <link href="http://yoursite.com/2020/03/17/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2020/03/17/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</id>
    <published>2020-03-17T09:14:25.000Z</published>
    <updated>2020-03-17T09:27:41.694Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在PHP中，<code>mysqli_multi_query()</code>函数可以多语句查询SQL </p></blockquote><h4 id="堆叠注入原理"><a href="#堆叠注入原理" class="headerlink" title="堆叠注入原理"></a>堆叠注入原理</h4><blockquote><p>​    在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products; 服务器端生成的sql语句为：（因未对输入的参数进行过滤）Select * from products where productid=1;DELETE FROM products;当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在PHP中，&lt;code&gt;mysqli_multi_query()&lt;/code&gt;函数可以多语句查询SQL &lt;/p&gt;
&lt;/blockquote&gt;&lt;h4 id=&quot;堆叠注入原理&quot;&gt;&lt;a href=&quot;#堆叠注入原理&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SQL注入</title>
    <link href="http://yoursite.com/2020/03/17/SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2020/03/17/SQL%E6%B3%A8%E5%85%A5/</id>
    <published>2020-03-17T09:14:01.000Z</published>
    <updated>2020-03-17T09:21:03.758Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>对表名为纯数字的表进行操作时，要在前后加上`符号。</li><li>对列名进行更改时，要在后面指定修改后的数据类型  </li><li>盲注时候多加一个^0或1是因为在盲注的时候可能出现了语法错误也无法判断,而改变这里的0或1,如果返回的结果是不同的,那就可以证明语法是没有问题的</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;对表名为纯数字的表进行操作时，要在前后加上`符号。&lt;/li&gt;
&lt;li&gt;对列名进行更改时，要在后面指定修改后的数据类型  &lt;/li&gt;
&lt;li&gt;盲注时候多加一个^0或1是因为在盲注的时候可能出现了语法错误也无法判断,而改变这里的0或1,如果
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CGI模式</title>
    <link href="http://yoursite.com/2020/03/17/CGI%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/17/CGI%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-17T09:12:23.000Z</published>
    <updated>2020-03-17T09:56:27.256Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CGI是common gateway interface的缩写，大家都译作通用网关接口 </p><p>这个规则会将header中的proxy参数设置为环境变量HTTP_PROXY </p></blockquote><h3 id="CGI介绍"><a href="#CGI介绍" class="headerlink" title="CGI介绍"></a>CGI介绍</h3><p>​    总所周知，web服务器所处理的任务都是静态的，假如其要想处理动态的任务，则需要web应用程序的帮助，比如PHP，jsp，python，perl等为了将web服务器的动态请求传递给这些应用程序，依靠cgi协议。</p><a id="more"></a><p> 简单的cgi工作方式： </p><p><img src="/2020/03/17/CGI%E6%A8%A1%E5%BC%8F/CGI%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.png" alt></p><blockquote><p> 有多种方式可以执行cgi程序，但对http的请求方法来说，只有get和post两种方法允许执行cgi脚本(即上面的search程序)。实际上post方法的内部本质还是get方法，只不过在发送http请求时，get和post方法对url中的参数处理方式不一样而已。 </p></blockquote><p> 通过cgi协议，再结合已搭建好的web应用程序，就可以让web server也能”处理”动态请求(或者说，当用户访问某个特定资源时，可以触发执行某个web应用程序来实现特定功能) ,例如，在谷歌搜索栏中搜索一个关键词”http”，对应的URL为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com/search?q=http&amp;oq=http&amp;aqs=chrome..69i57j69i60l4j0.1136j0j8&amp;sourceid=chrome&amp;ie=UTF-8</span><br></pre></td></tr></table></figure><p>当谷歌的web server收到该请求后，先分析该url，从中知道了要执行search程序，并且还知道了一系列要传递给search的参数及其对应的value。web server会将这些程序参数和其它一些环境变量根据cgi协议通过TCP或套接字等方式传递给已启动的cgi程序(可能是cgi进程，或者是已加载的模块cgi模块)。当cgi进程接收到web server的请求后，调用search程序并执行，同时还会传递参数给search程序。search执行结束后，cgi进程/线程将处理结果返回给web server，web server再返回给浏览器。</p><p>任何一种语言都能编写CGI，只不过有些语言比较擅长，有些语言则非常繁琐，例如用bash shell开发，那么需要用echo等打印语句将执行结果放在巨多无比的html的标签中输出给客户端。常用于编写CGI的语言有perl、php、python等，java也一样能写，但java的servlet完全能实现CGI的功能，且更优化、更利于开发。</p><h3 id="各种术语释疑"><a href="#各种术语释疑" class="headerlink" title="各种术语释疑"></a>各种术语释疑</h3><p> 刚接触cgi概念的时候肯定会有一堆疑问，这到底是什么鬼，处理动态内容的东西不是像php一样的应用程序吗 ？</p><p>以php为例，我将一次动态请求相关的概念大致都简单解释一遍。</p><ol><li><code>cgi</code>：它是一种协议。通过cgi协议，web server可以将动态请求和相关参数发送给专门处理动态内容的应用程序。</li><li><code>fastcgi</code>：也是一种协议，只不过是cgi的优化版。cgi的性能较烂，fastcgi则在其基础上进行了改进。</li><li><code>php-cgi</code>：fastcgi是一种协议，而php-cgi实现了这种协议。不过这种实现比较烂。它是单进程的，一个进程处理一个请求，处理结束后进程就销毁。</li><li><code>php-fmp</code>：是对php-cgi的改进版，它直接管理多个php-cgi进程/线程。也就是说，<strong>php-fpm是php-cgi的进程管理器</strong>因此它也算是fastcgi协议的实现。在一定程度上讲，php-fpm与php的关系，和tomcat对java的关系是类似的。</li><li><code>cgi进程/线程</code>：在php上，就是php-cgi进程/线程。专门用于接收web server的动态请求，<strong>调用并初始化zend虚拟机</strong>。</li><li><code>cgi脚本</code>：被执行的php源代码文件。</li><li><code>zend虚拟机</code>：对php文件做词法分析、语法分析、编译成opcode，并执行。最后关闭zend虚拟机。</li><li><code>cgi进程/线程和zend虚拟机的关系</code>：cgi进程调用并初始化zend虚拟机的各种环境。</li></ol><p>以php-fpm为例，web server从转发动态请求到结束的过程大致如下：</p><p>![](CGI模式/web server从转发动态请求到结束过程.png)</p><h3 id="web-server和CGI的交互模式"><a href="#web-server和CGI的交互模式" class="headerlink" title="web server和CGI的交互模式"></a>web server和CGI的交互模式</h3><p>​    web server对cgi进程/线程来说，它的作用就是发起动态处理请求，传递一些参数和环境变量，最后接收cgi的返回结果。再通俗而不严谨地说，web server通过cgi/fastcgi协议将动态请求转发给执行cgi脚本的应用程序。通过下面httpd.conf中的转发配置应该很容易理解(httpd和php-fpm的交互)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProxyRequests off</span><br><span class="line">ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/usr/local/apache/htdocs/$1</span><br></pre></td></tr></table></figure><p>以最典型的apache httpd和php为例，对于httpd来说，web server和php-cgi有3种交互模式。</p><ul><li><code>cgi模式</code>：httpd接收到一个动态请求就fork一个cgi进程，cgi进程返回结果给httpd进程后自我销毁。</li><li><code>动态模块模式</code>：将php-cgi的模块(例如php5_module)编译进httpd。在httpd启动时会加载模块，加载时也将对应的模块激活，php-cgi也就启动了。(注：纠正一个小小错误，很多人以为动态编译的模块是可以在需要的时候随时加载调用，不需要的时候它们就停止了，实际上不是这样的。和静态编译的模块一样，动态加载的模块在被加载时就被加入到激活链表中，无论是否使用它，它都已经运行在apache httpd的内部。可参考LoadModule指令的官方手册)</li><li><code>php-fpm模式</code>：使用php-fpm管理php-cgi，此时httpd不再控制php-cgi进程的启动。可以将php-fpm独立运行在非web服务器上，实现所谓的动静分离。</li></ul><p>实际上，借助模块mod_fastcgi还可以实现fastcgi模式。同cgi一样，管理模式的先天缺陷决定了这并不是一种好方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;CGI是common gateway interface的缩写，大家都译作通用网关接口 &lt;/p&gt;
&lt;p&gt;这个规则会将header中的proxy参数设置为环境变量HTTP_PROXY &lt;/p&gt;
&lt;/blockquote&gt;&lt;h3 id=&quot;CGI介绍&quot;&gt;&lt;a href=&quot;#CGI介绍&quot; class=&quot;headerlink&quot; title=&quot;CGI介绍&quot;&gt;&lt;/a&gt;CGI介绍&lt;/h3&gt;&lt;p&gt;​    总所周知，web服务器所处理的任务都是静态的，假如其要想处理动态的任务，则需要web应用程序的帮助，比如PHP，jsp，python，perl等为了将web服务器的动态请求传递给这些应用程序，依靠cgi协议。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>笔记</title>
    <link href="http://yoursite.com/2019/12/14/%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/12/14/%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-14T15:24:47.000Z</published>
    <updated>2020-03-17T09:26:54.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP字符串解析漏洞"><a href="#PHP字符串解析漏洞" class="headerlink" title="PHP字符串解析漏洞"></a>PHP字符串解析漏洞</h1><p><a href="https://www.freebuf.com/articles/web/213359.html" target="_blank" rel="noopener">利用PHP的字符串解析特性Bypass</a></p><p>我们知道PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，/?%20news[id%00=42会转换为Array([news_id] =&gt; 42)。如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/news.php?%20news[id%00=42&quot;+AND+1=0–</span><br></pre></td></tr></table></figure><p>上述PHP语句的参数%20news[id%00的值将存储到$_GET[“news_id”]中。</p><p>HP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：</p><blockquote><p>1.删除空白符</p></blockquote><blockquote><p>2.将某些字符转换为下划线（包括空格）</p></blockquote><p>我的理解：<br>假如waf不允许num变量传递字母：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.com/index.php?num = aaaa   //显示非法输入的话</span><br></pre></td></tr></table></figure><p>那么我们可以在num前加个空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.com/index.php? num = aaaa</span><br></pre></td></tr></table></figure><p>这样waf就找不到num这个变量了，因为现在的变量叫“ num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。</p><h1 id="php别名"><a href="#php别名" class="headerlink" title="php别名"></a>php别名</h1><blockquote><p>php2, php3, php4, php5, phps, pht, phtm, phtml </p></blockquote><h1 id="CVE-2018-12613漏洞"><a href="#CVE-2018-12613漏洞" class="headerlink" title="CVE-2018-12613漏洞"></a>CVE-2018-12613漏洞</h1><blockquote><p>这个漏洞利用了一个性值：如果将 ？双重编码，经过包含时会把你包含的文件当作一个目录，也就是说，如果你写入：</p><p>hint.php%25%3F（%25%3F是?的二次编码）</p><p>那么解析时会把hint.php当作一个目录来看。</p></blockquote><h1 id="Unicode欺骗"><a href="#Unicode欺骗" class="headerlink" title="Unicode欺骗"></a>Unicode欺骗</h1><blockquote><p>利用nodeprep.prepare函数会将unicode字符ᴬ转换成A，而A在调用一次nodeprep.prepare函数会把A转换成a。<br>所以当我们用ᴬdmin注册的话，后台代码调用一次nodeprep.prepare函数，把用户名转换成Admin，我们用ᴬdmin进行登录，可以看到index页面的username变成了Admin，证实了我们的猜想，接下来我们就想办法让服务器再调用一次nodeprep.prepare函数即可。 </p></blockquote><h1 id="超全局变量"><a href="#超全局变量" class="headerlink" title="超全局变量"></a>超全局变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$GLOBALS</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PHP字符串解析漏洞&quot;&gt;&lt;a href=&quot;#PHP字符串解析漏洞&quot; class=&quot;headerlink&quot; title=&quot;PHP字符串解析漏洞&quot;&gt;&lt;/a&gt;PHP字符串解析漏洞&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articles/web/213359.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;利用PHP的字符串解析特性Bypass&lt;/a&gt;&lt;/p&gt;&lt;p&gt;我们知道PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：/?foo=bar变成Array([foo] =&amp;gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，/?%20news[id%00=42会转换为Array([news_id] =&amp;gt; 42)。如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过：&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
